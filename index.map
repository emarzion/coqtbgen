{"version":3.0,"file":"index.js","sourceRoot":"","names":["String","null","Math","Uint8Array","this","undefined","Array","arguments","isFinite","isNaN","Infinity","Float32Array","Int32Array","Float64Array","Int8Array","Int16Array","Uint16Array","NaN","Number","Object","parseInt","Boolean","Symbol","RegExp","require","console","document","Function","ArrayBuffer","Uint32Array","Date","hI","fa","iI","cO","kl","oK","qL","rC","sh","sS","sT","sR","sZ","td","te","tf","tg","th","ti","tj","tk","tl","tm","tn","to","tp","tq","tr","ts","tt","tu","tv","tw","tx","ty","tz","tA","tB","uE","GR","G0","K","c","b","ai","a","d","e","D","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","E","F","G","H","I","hq","eZ","dl","hr","hs","oD","e0","ht","aj","oH","ao","oI","bZ","hu","hv","hw","e1","dn","oN","oQ","cw","cx","bc","b1","hy","aF","b2","e2","hz","cy","hA","hB","bt","hC","b3","cz","hG","hH","cB","cC","bH","b4","b5","hJ","e4","ds","hK","b6","b7","hL","e5","hM","e6","hN","hO","b8","Z","hP","hQ","e7","O","_","L","M","N","Q","S","T","U","W","X","Y","aa","ab","ac","ad","af","ag","ah","ak","al","am","an","ap","aq","ar","as","at","au","R","av","aw","ax","ay","aC","aD","aE","aH","aI","aJ","aK","aM","aN","aO","aP","aR","aS","aT","aU","aY","aZ","a0","a1","dt","cE","ae","az","aA","aB","aG","aL","aQ","aV","aW","aX","b9","pW","hR","du","qM","qN","qO","qP","bf","e8","dv","J","P","V","$","hS","bg","bh","hT","e9","e_","e$","fb","hU","cF","dw","hV","hW","rs","ru","rz","dx","hE","o4","dq","dy","rB","rD","fc","dz","h0","cG","cH","h1","dA","h2","cI","h3","fe","dB","h4","dC","bI","h5","b_","rK","h6","h7","h8","ff","fg","h9","h_","fh","fi","id","ie","rV","rZ","r3","r4","r7","ii","ij","hx","oM","il","im","iu","sV","iv","iw","fp","fq","ix","iy","iz","iA","iB","bw","iC","fr","dF","iD","fs","iE","bK","dG","iF","ft","iG","iH","fu","iJ","iK","iL","iM","s2","fw","fx","iN","iO","fy","s4","iP","iQ","iR","s9","s_","s$","ta","tb","tc","iS","fz","iT","dH","fA","r$","ca","iV","iW","iX","fB","fC","iY","tG","iZ","tH","tI","i2","dI","i3","cb","cM","i4","dJ","dK","i5","cN","i7","dL","i8","cP","i9","bx","bL","bM","i_","tK","fI","i$","cQ","ja","bN","fJ","jb","tS","tT","fL","dO","jd","fM","cR","a5","je","cS","fN","jj","dQ","tZ","t1","t2","t3","t4","t5","jl","fP","fQ","t0","jf","dM","jc","fK","I1","fG","fH","dN","cc","tM","i6","jg","ue","jm","jn","uq","dR","uu","fR","cT","jo","uI","uK","jC","Eh","Es","jF","Eg","f1","cf","jE","cW","f2","jG","jI","f3","jJ","cg","jK","Ew","jL","jM","jN","f4","f5","jO","f6","jP","dY","jQ","jR","jS","f7","jT","jU","jV","ch","jW","EC","jX","ED","jH","f8","jY","jZ","j0","j1","j2","j3","j4","ci","j5","EI","j6","j7","j8","j9","j_","EL","j$","ka","f9","kb","EM","EN","dZ","Fe","Fi","bP","kc","cj","kd","ga","kh","gb","ki","bQ","d0","Fo","kj","d1","kk","km","f$","kq","kr","kv","kw","cX","FR","FW","FY","F0","F$","d3","d4","d5","d6","bR","by","cY","bS","GZ","G_","kx","ks","gd","FE","FF","d2","gg","kg","Fl","kt","fD","FB","FC","FD","fE","i0","i1","ge","kn","kp","kf","ke","Fk"],"sources":["/builtin/+mlBytes.js","/builtin/+sys.js","/builtin/+backtrace.js","/builtin/+stdlib.js","/builtin/+jslib.js","/builtin/+fail.js","/builtin/+effect.js","/builtin/+obj.js","/builtin/+array.js","/builtin/+ieee_754.js","/builtin/+int64.js","/builtin/+bigarray.js","/builtin/+ints.js","/builtin/+hash.js","/builtin/+marshal.js","/builtin/+compare.js","/builtin/+weak.js","/builtin/+format.js","/builtin/+fs_node.js","/builtin/+fs.js","/builtin/+unix.js","/builtin/+fs_fake.js","/builtin/+jslib_js_of_ocaml.js","/builtin/+lexing.js","/builtin/+md5.js","/builtin/+io.js","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/lexing.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/printexc.ml","/workspace_root/bin/query/RomanWheel.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/re/cset.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/lwt/lwt.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/stdlib.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/camlinternalFormat.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/hashtbl.ml","/workspace_root/bin/query/uint63.ml","/workspace_root/bin/query/ExtractQuery.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/tyxml/functor/svg_f.ml","/workspace_root/bin/web/index.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/camlinternalFormatBasics.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/camlinternalAtomic.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/tyxml/functor/html_f.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/list.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/camlinternalLazy.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/obj.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/char.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/reactiveData/reactiveData.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/int.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/bytes.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/string.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/array.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/map.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/stack.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/queue.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/buffer.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/yojson/codec.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/printf.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/random.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/digest.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/weak.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/format.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/yojson/common.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/yojson/lexer_utils.ml","/workspace_root/bin/query/TB.ml","/workspace_root/bin/query/Sort.ml","/workspace_root/bin/query/Datatypes.ml","/workspace_root/bin/query/Graph.ml","/workspace_root/bin/query/IntMap.ml","/workspace_root/bin/query/List0.ml","/workspace_root/bin/query/BearGame.ml","/workspace_root/bin/query/OMap.ml","/workspace_root/bin/query/OCamlTB.ml","/workspace_root/bin/query/read_file.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/callback.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml/js.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml/dom_html.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml/dom.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml/firebug.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/re/category.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/re/automata.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/re/color_map.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/re/core.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/tyxml/functor/xml_wrap.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/tyxml/functor/xml_print.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml-tyxml/tyxml_js.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml-tyxml/tyxml_cast.ml","/workspace_root/bin/web/draw.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/lwt/lwt_sequence.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml-lwt/lwt_js.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/js_of_ocaml-lwt/lwt_js_events.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/option.ml","/home/runner/work/coqtbgen/coqtbgen/_opam/lib/ocaml/std_exit.ml"],"mappings":"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Q,qC;;K;;K;E;O,M,mB,M;E;E;E;E,e9B+FlBsC;E,eAJAF;E,eAEAC;EsBzHA6C,S,M,sB;E,e;G;uB,U,eZFA1B;yB,M,qB;;K;E;M,2B,M,sB,M,qB,M,sB,M;O,M,sB;I,M,qB;;K;E;O,M,mB,M;K,M,qB,M,sB,M,qB,M,sB,M;O,M,sB;;M;E,M;E,M,oC,C,W,G;O,M,mB,M,S,C,W;G;uB,U,sBAAAA;yB,M,qB;;K;E;M;O,M,sB;I,M,qB;;K;E;O,M,mB,M;K,M;O,M,sB;;M;E,M;E,M,oC,C,W,G;O,M,mB,M,S,C,W;G;uB,U,eAAAA;yB,M,qB;;K;E;M;O,M,sB;I,M,qB;;K;E;O,M,mB,M;K,M;O,M,sB;;M;E,M;E,M,oC,C,W,G;O,M,mB,M,S,C,W;G,M,qB,M,sB,M,qB;;K;E;O,M,mB,M;K;E,M,sB,M,qB;;K;E;O,M,mB,M;K;E,M;E,M,oC,C,W;E;E,M,wB,M,gB,C,W;G,M;G,Q,M;G,M;G,M;E,I;W,Q,W;gC,K,S;E,kC;;e,K,S;;kB;uB;E,I;O,Q,W;+B,K,S;E,kC;;e,K,S;;kB;uB,kC,C,W;;K;;K;E;WYvBAyB;;OAuIwBzE,cAAPE,OARjB0E,KASc,SADG1E,EAAOF,GAC1B,MAAA;E,M,wB,G;mB;E;O,M,mB,M;E;aC3KIiB,U,M;EAAAA,U,M;EAAAA,W,M;EAAAA,W,M;EAAAA,W,M;EAAAA,U,M;E,G;iB,iB,iB,qB,W,oD,G;mB;E;O,M,mB,M;E,G;iB,iB,iB,qB,W,WA4C2BnB,4BAAAA,UAAAA,GA7C7BoO,4BA6C6BpO,cACd,MAAA,Q,M;E,M,wB,M,gB,E,YA9CfoO,W,M;E,M,wB,M,gB,E;O,M,mB,M,S,C,W;;I;;K;E;E;E,M;E,Q,M;O,M,mB,M,S,C,W;Q;;K;E,oB,qB;O,M,mB,M,S,C,W;;K;;K;E;E,Q,M;E,M;E,Q,M;E;O,M,mB,M,S,C,W;U;;K;E;ED6DAxJ,S,M;K3BoIkB7E;OAEpB,SqB3HE8D,QrByHkB9D,OAAAA;E,M,wB,M;O,M,mB,M,S,C,W;U;;K;E;E;E,M,wB,M;O,M,mB,M,S,C,W;c,e,U,SkC7LlBsO;yBlC+I2B,GAeMtO;EAfN,YAQjB,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,GE8YavT,IAAeC,CAIN,SAGlB2U;GAAU9T,EAAIG,IAAehB,IAAgBG,EAAIC,EAAMC,EAAMC,UAA1CY;IAAmBD;;EA6C1C,YFtbAwS,GEyYc5S,KAAIG;EA+ClB,YF1bAwS,GE2Yc3S,KAAIG;EAmDf;EF9bHwS,GE2Yc3S,EH1jBd6R,IG2mBA,YFndAlJ,GEkac3I,KFzYd4S,GEyYc5S,QAAIG;EAwDf;EFncHwS,GE2Yc3S,KAsDd,YFxdA2I,GEkac3I,KFzYd4S,GEyYc5S,EH1jBd6R,OG0jBkB1R;EAgEJ,GAAA;EF3cdwS,GE2Yc3S,UFlad2I,GEkac3I,KFzYd4S,GEyYc5S,WA6DA,EFxcd2S,GE2Yc3S,EH1jBd6R,IGqnBA,YFleAU,GEuacvS,KFlad2I,GEkac3I,KFzYd4S,GEyYc5S,EH1jBd6R,WG0jBkB1R;EAmElB,YF5cAyS,GEyYc5S,EH3jBd4R,IG2jBkBzR;EAqElB,YFhdAwS,GE2Yc3S,EH3jBd4R,IG2jBkBzR;EAuElB,YFldAwS,GE2Yc3S,MAAIG;EAyElB,YFldAyS,GEyYc5S,EHtjBd8R,IGsjBkB3R,YA2ElB,YFtdAwS,GE2Yc3S,EHtjBd8R,IGsjBkB3R;KA3OCnB;aAAAA,IAAAA;EAAAA,KpDzOlB6B,OAAW,GAAA,EAAXA;KAAAA;YkDwCOP;ElDzBR+R,GoD4NuB,EAyO0C5S,cAvOzD,GAAJqB;KpDpQAsR,GoDgQepT,GAAAA,GAKnB,IACE,GAAA;mBAFE8B,EAuOuDtB,MF5anDc;;yBlD3BgB,GoDoOlBjB;ExCzOFyD,cwC4OiB9D,GAAZ,GAAMD;OAAmC,EAAA,EAgOeU,QAhOvC,MpD7UtB8H,IoD+TJ2L,GAc2C,EAgOsBzT,EAhOlDV,MAAMC,EAAuC,EAXzCA,EpD5NLmT,IoDuc6C3S,qBAvOvDsB,EAIEzB,EAmOqDG,SF5anDc;EEyMFjB,GFxML;EADOiB,MACP,IAHDgS,GE8actS,GFlbdwG,GEkbcxG,KF5aNM,IE8aR,cAFkBH;KAGT0J;OACR,MAAA,IAkHDkK,GAtHc/T,EAAIG,EAAKE,IAAmBD,EAAOd,EAAIC,EAAMC,EAAMC,EAGxDoK,cACT,cAJkB1J;EAMN,G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ClDsB,iBf4jCkD,MAAA,wBAFpC;OAGKV,OAALC,OACoC,MAAA,GJpChDmI,GImCiBpI,cACO;iBADZC,GACoC,MAAA,Ge9jClDS,iBf8jCkD,MAAA,gBAA8B,CAE7D,MAAA,GK9iCjBa,ELuiCEnC,EADgBG,cAQD,oBAAc,CAaF;MAtM7BO,EA2IAgC,IAJAxB,EAnCAN,EA0BAG,EAKAC,EAsCAU,EAHAD,EAjLAtB,EA8KAqB,EAHAD,EAPAF,EAwBAM,WAUwBxB,KAC1B,SAD0BA;0BAAAA,EAGhB,qBACAH;EAJgBG,QAIhBH,EAAQ,eAARA,IAFY,YAEkB,EA1CtCoB,EAJAD,iC;M,SkB3iCFoL,Q;Q,MAuBAI,W;U;EAAAA,WAiBAC,oB,MAxBAF,a;Q;EARAF,sB;EARAD,mBAwCAK,2BAxBAF,wC;M;kB,MAAAA,a;U,G;mB;Y;EAOAC,kC;;gB;U,G;U;kC;Q;I,Q,G;mB,Q,e;0D;I,C;;M,sB;Q,Y;O;e,oC;c,U,gB;uD;a;S;Q;kB;Y;EAAAA,2B;;a;Q;;K;O;;O,M,S,C,M,GjB+DI9I,mB,oB,C;O;;O,M,S,C,M,GAAAA,mB,oB,C;K,0B;K;O,Q;O;S;U,Q;ciBtEJ6I,a,M,Y;;U,M,mB,M,mB;oB,M,a;Q,M,mB;W,wB,a;O,M,Y,C,M,GjBsEI7I,mB,M,mB,K,M,c,C,W,YV9EJpC,W;Q,G;U;O,yB;a,M;;O;;W,M,mB,M,kB,c,a;Q,W;Q,W;M,6B;Q;O;;gB2BeAkL,YAPAD,iB,K;;K,Q;kB,oB;U,oB,C;;M,6C3BRAjL,K;M;e,Y,K,c;M,qB;U,a,W;U;O;O,oD;M;Y,Y,K,c;Q,mB;c,yB,G;c,M,mB,M;;K,yB,qC;Y;;c,M,sB,K;iE;Q;0C;;Q,M,S;O;O,oB;O;Q,M,mB,qB,C,W,yBqD2RE6V;M,W;M;;gB,MrD5RFpV;O,Q;Y;yB,kB;O,M,mB,kB;O;O,oB;O;Q,M,mB,M,gB,C,c,M,iBcsBO,GA8GLqV;aAxGAC;GA4MMrX,EAAEF,GACV,SAZwBgB;IAAEJ,EAWlBV,EAVR,aADwBc,EACxB,KAAA,mBAD0BJ;EAAAA,4BAAFS;OAAEhB,EAAAO,QAAFI,EAAAK,aAAAL;EAAAK,EAAET,EAAAP;;IAYvB,MAGD,MJnJEwD,aImJkB3D,EAAEF,GAAK,OAALA;EA5FtB,GADGU;EA6FmBV,KA7FhB4B,EA6FgB5B,KA3FNK,KAFbK,EAAAA,GJnJL8C,GIgPsBtD,QA7FjBQ,IAESE,IAGRD,EAHYN,EAAEI,EA2FEP,EA3FE,eAGlBS,EAF2B,MJxH7B8C,IIuHU7C,KAFNgB,EAEYnB,QAAAA,EAEN,MdnJdwB,UciJcrB;KAAMH,KAANG,GAGRD,EAAAA,MAHcF,EAAAA;EAMlB,GADEI;EAsFoBb,KApFN8B,KAFdjB,EAAAA,EJ1JJ2C,GIgPsBtD,GAtFlBW,IAEUE,IAGRD,EAHYgB,EAAExB,EAoFEJ,EApFE,eAGlBY,GAHcR,EACJ,MJ/HZmD,II8HU1C,EAAMT,UAAAA,EAEN,Md1Jd2B,UcwJclB;KAAMT,KAANS,GAGRD,EAAAA,MAHcR,EAAAA;EAMlB,GADGU;EA+EmBhB,KA/EhB+B,EA+EgB/B,KA9ElBkB,KADDF,EAAAA,EJjKLwC,GIgPsBtD,GA/EjBc,IAECG,EIrCNqD,GJkHsBtE,GA5EpB,EADIiB,EADAD,KAAAA,GADEa,EAGN,MIhDFwC,IJ+CMpD,WAII,GADFf;EA0EgBJ,KA1EnBiB,EA0EmBjB,KAzElBG,EIzCNqE,GJkHsBtE,GAxEhBkB,EADAjB,WAEAJ,KAHDkB,EAAAA,EAECG,EAFDH,IAICI,IAHAlB,EAEAJ,KAAAA,GAEJ,KALMK,MAEFgB,IACArB,EAHEK,KdlKR6B;GcqKMlC,EAHEK,eAGFL,MAKFQ;EALER,UAMA,GAAA;EADFQ,MACW,IARTJ,UAQA,EARAA,EAOFI,KAAAA,KACE;EADFA,aAAAA,WAAAA;;EALER,EAHEK,IAWJ,EAVED,UAGAkB,WADAtB,EAHEK,OdlKR6B;GcqKMlC,EAHEK,YAGFL,SAYFS;EAZET,UAaA,GAAA;EADFS,MACW,IAfTL,UAeA,EAfAA,EAcFK,KAAAA,KACE;EADFA,aAAAA,WAAAA;;EAZET,EAHEK,IAkBJ,EAjBED,UAGAkB,EAcF,MIpEJkD,IJmDMpE,GAyEkC,EAJ9BH,EAAFE,MAnCYI;IAAII,IAAGX,EAmCnBG,EAnCqBE,EAmCnBJ,EAlCV,WAD2BD;EAAAA,oBACpBQ;EADaD,EAmBdH,EAnBuBC,UAGrBe;UAHgBT,EAGhBS,YAfgBN;EAYJP,EAZQK,EAepBQ,EAHgBT,IAZMD,EAYDL,EAX7B,aAD4BO,EAC5B,KAAA,qBAD4BA,YAAEF,aAANI;KAAMJ,KAANI,GAAIF,EAAAA,MAAEF,EAAAA;KAAAA,EAANI;EdxLxBW,ScqMOjB;OAkBDJ;GAlBCI;EADaD,EAmBdH,EAnBuBC;GACtBG;EADaD,EAmBdH,EAnBuBC,MAAFL,EAoBzB,MJ/LE0D,II4KGlD,EAkBDJ;EAnBqBJ;KAAPO;EACbC,EADiBG,OAAGX,EAAAA,KAAEK,UAmBvBD;KAnBqBoB;EAAAxB,KAAH0B,WAmBlBtB,EALJ,MdlNFqB,UcoMoBlB;EACbC,EADiBG,EAAAe,EAAG1B,EAAAwB,EAAEnB,EAmBvBD;KAnBqBuB;EAAA3B,KAenB4B,OAfgBC,WAmBlBzB,EADJ,MdtNFqB,UcoMoBlB;EACbC,EADiBG,EAAAkB,EAAG7B,EAAA2B,EAAEtB,KAerBuB,EAIFxB,oBAGJ,Md3NF8B,Qc4O6C,SAa3CuV;GAAatX,KACf;sB,kBAE2BmM,iBACnB,MAAA,gBAAJlM;EACWD,KAAK,MAAA,QADhBC,EACWD,MAAiB,CAAhC,MAAA,GJ/KI0D,KI0KW1D,cAKf,MAAA,SADIC,QAEG,CAhNG,GAxCZsX;MA6HIH,YA3HJI;GAmDexX,EAAEF,GACD,GAAVD;KADSG,GAQb,YAPIH,cACyBG,KADzBH,SACyBG,KAlC3BqX,GAkC2BrX,KADzBH,MACyBG,KAKzB,SALyBA,EAKtB,EAPQF,IAQI,SApDrB2X;GA0EUzX,GAAI,WAAJA,KAAAA,KAAAA,UAEe,SAzEzB0X;GA2EU1X,GAAI,WAAJA,QAAAA,OAEU,SAtFpB2X;GA4GkB3X,EAAUF,KAC1B,GA0ImBoB;EA3IHlB,EAAAA,mB,iBAAUF;KAEG,SA/G/B0X,MA6G4B1X,gB,Y;EAAAA,K,e;O,oB;O,GAuLbA;Q,gBAAFD;eAAEC,GACb,GA7CsCc;WA6C9BZ,EAAIF,EAAED,GAAI,YAANC,EAAED,GAANG,EAAyB,EA7CHc,WA8CnBd,EAAIF,GAAI,YAAJA,GAAJE,EAAkB,EA9CJI,IACd,MAAA,GATTkX,GAoDSzX,WA3CPsB,GACO,MAAA,GAVTmW,GAoDWxX,WA1CTE,GAiCJ,GAhC2BC;IAAXC;EAAWE,EAAHN,EAAHD,EAALI,KACd,GADmBJ,MAAAW;EAAAX,KAiBjBgB,EAjBiBhB,SAAGC,EAKpB,MAAA,KALuBM,IAANI,EAALP,EAHca,IAGHV,OAqBfK;EArBYX,KAAAiB,EAAAjB,KAcE,MAjBPoB,GAoBfL,EAIQJ,GANR,IAfuBL,MAAHW,EAAHP,EAALP,KAiBa,EAlBzBD,EAkBAa,cAAyB,SAIA,EAvBzBM,EAuBQV,cAAiB,MACf,MAAA,KAtBaL,MAAHW,EAAHlB,EAALI,EAHsBW,IAGXR,EAqBfK,IAIa,GAzBTR,EA2BZ,MAAA,KA3BuBG,EAAHN,EAAHU,IAHSM,IAGHV,OAAHE;EAAAR,KA6BV,MAAA,KA7BaM,MAAHE,EAAHT,IAHiBe,IAGXR,EAqBfK,MAFR,IAnBuBL,EAAHN,EAAHU,EAALP,EAHca,IAGHV,SAAHN,MAAAuB;EAAAvB,KAQV,MAAA,KARaM,MAAHiB,IAARpB,EAHsBW,IAGXR,EAAHN,UAkCPa;gBAAY,GAAZK;EAAAL,EAAAA,OAAY,M,eAAZK,YAAAL;aAAAK,WAJkB,CAEnC,SAhC2Bf,EAyCdH,EAAFD,EAzCKK,EAHSE;M,uB;K,uB,C,G;c,M,mB,M,oB,W,c;gB;;YaxQzBgM,yB,G;;U;4B,qB,qC,c,Q,sB,c,c,kB,uBb+H+C,SuC0K7CwL;GvCwDY5X,KACd,GAAIE;Q,S,QACEL;S,O;kB,U,M;ed3VNyB,uCAAAA;M,oBc4Va,GAATlB;EApVNoX;EAqV2BxX,KACrB,MAJAE,OAAAA,OAOO,EANLL,eAEmBG,WAMX,EARRH,eAEmBG,SAMK,CANV;IAAZ,MAAA,UAJMA,cAIN,SADJI,IAQE,SAEJyX;GAAoCvX,EAAED,KACxC,GAAIa;EAxVNuW,GAuVwCnX,GAElCa,EAzVNsW,GAuV0CpX,GAGpCJ,QACAC,QACJ,QAAIkB;EAAgBpB,K;EAAAA;EAAAA,wBAGG,QACvB,QAAII;EAAcJ,EAAMF,GAANE,KJpXlBsD,GIoXwBxD,SAAwB,CAA5CM,EANAH,EAFAiB,GAQAd,EALAF,EAFAiB;EAY8BnB,KAC9B,OAD8BA;EAG1B,GADKI;EAFqBJ,KAEjBQ,EAFiBR,KAGtBS,KADCL,EAAAA,EAAAA,EAZTF,OAWIL,KAEIY,EADKD;EAGM,GAAXH;EALsBL,KAKtBU,KAAAL,EAAAA,EAAAA,EAfRH,OAWIL,KAIIa;KACCJ;EANqBN,KAMjBW,EANiBX,KAMrBY,KAAAN,EAAAA,EAAAA,EAhBTJ,OAWIL,KAKKe,EAAID,oBACJJ;EAPqBP,KAOnBa,EAPmBb,KAOrBc,KAAAP,EAAAA,EAAAA,EAjBTL,OAWIL,KAMKiB,EAAED,GAhBXO,EAFAnB,EAYIJ,GAQJ,SARIA,EASH,CAVe,QAAhBwB;O,SAvVFW;EAkWgChC,KAC9B,OAD8BA;KAErBI;EAFqBJ,KAEjBQ,EAFiBR,UAErBI,EAxBTH,KAwBSG,IAAAA,EADLP,OACSW;EACM,GAAXH;EAHsBL,KAGX,KAAXK,EAzBRJ,KAyBQI,IAAAA,EAFJR;KAGKS;EAJqBN,KAIjBW,EAJiBX,UAIrBM,EA1BTL,KA0BSK,IAAAA,EAHLT,OAGSc,oBACJJ;EALqBP,KAKnBa,EALmBb,UAKrBO,EA3BTN,KA2BSM,IAAAA,EAJLV,OAIOgB,GAzBXO,EADAlB,EAsBIL,GAMJ,SANIA,EAOH,CARe,QAAhByB;O,SAlWFU,SAkWkB,GAAA;IAiBc,EA9XpC0V,GAoV0CrX,oBA0ClBL,KAAK,eAALA,GAAU,QADE,EA7XpC0X,GAoVwCpX,6BAyChBN,KAAK,eAALA,GAAU,uB,G;Q,EJjXhCwD,M,wB,SAwCAC,e,W,K,kB,GImUqBxD;uB,YAAAA;c,gB,GAAIC;QAGhBI,EAHYL,SAGZK,SAHgBJ;mBAAAA,SAAJD;QAAIC,MAAJD,uBAAAA,YAAIC;mBAAAA,SAAJD;KAGZK,KAHgBJ;MAIZ;O,kB,oB,E,M,GJ/TTwD,mB,GI0TA5D;YASAS,cAA6BP,KAC7B;EAD6BA;EAAAA;MA4Bd;uBAXKG;OAAa,MAAA,GAnCjCmB,EAmCoBnB,cAAO,qBARTuB;OA3ClBtB,EALAF,EAgDkBwB,GAEhB,YJrYNe,GIRFgV,GAuVwCnX,GAoDhBoB;;EATW1B,KAgBfc,aAAmB,MAAA,GA7CjCO,EA6CcP,cAAa;uBAJIa;OACpB,MAAA,GA1CXN,EA6CcP,WAHRjB,GACK,MAAA,GAhCXyB,EA8B+BK,WAEzB3B,GACJ,YJzYNyC,GIuYU5C,EACAG,SAKK,GADiBiB;OACtBC,EArZZuW,GAuVwCnX,GASlCF,EANAH,EA2DMiB,GArDNd,EALAF,EAyD4Be,GAI1B,YJhZNwB,GI6YUvB,EADsBD;EAlBCjB,KAMjBH,cAxCZO,EANAH,EA8CYJ,GAEV,YJlYN4C,GIgYgB5C,EAxYlB4X,GAuV0CpX;oBASpCD,EANAH,EA8CYJ,GAmBD,GAAL0B;EA3ZZkW,GAuV0CpX,GASpCD,EALAF,EAgEMqB,GAEJ,YJrZNkB,GIgYgB5C,EAmBN0B,QAvBqBC;OApC3BpB,EANAH,EA8CYJ,GAxCZO,EALAF,EAyC2BsB,GAGzB,YJ/XNiB,GIgYgB5C,EAJe2B,IA0BA,EArC3B1B,GAuCJ,SAvaF0X,GJeE/U,GIgVIvB,EACAC,GAyCAZ;;;;OA8B0B,IuCna5BuX;;UAIJ,QALEC;GAKW/X,EAAOF,GAClB,GV8ISD;EUnJPiY,OAIS9X,GACPC,EV8IKJ,IAlFPmS,MAkWFK;GAhRSxS,EU9ILI,OADcH,GAJhBgY,OAIS9X,EACPC,SAIc,SAkWd+X;GArVYhY,GAAI,MAAJA,EAAK,SAqBnBiY;GAAKjY,EAAKF,GAAI,SAATE,WAAKF,KAAuC,SAEjDoY;GAAalY,EAAKF,KAAiB,SAFnCmY,GAEajY,EAAKF,cAAqD,SAEvEqY;GAAWnY,EAAKF,KAAQ,SAJxBmY,GAIWjY,EAAKF,cAA0C,SAE1DsY;GAAcpY,EAAKF,KAAQ,SAN3BmY,GAMcjY,EAAuB,EAAlBF,IAAmC,SAEtDuY;GAAiBrY,EAAKF,KAAS,SAR/BmY,GAQiBjY,EAAwB,QAAnBF,KAAyD,SAE/EwY;GAAiBtY,EAAKF,KAAS,SAV/BmY,GAUiBjY,EAAwB,QAAnBF,KAAyD,SAE/EyY;GAAqBvY,EAAMF,KAAyB,YAA/BE,KAAMF,IAA0C,SAErE0Y;GAA2BxY,EAAMF,KACnC,YAD6BE,KAAMF,IACb,SAEpB2Y;GAA8BzY,EAAMF,KACtC,YADgCE,KAAMF,IACb,SAEvB4Y;GAA2B1Y,EAAMF,KACnC,YAD6BE,KAAMF,IACb,SAEpB6Y;GAAW3Y,EAAKF,KAAQ,SAvBxBmY,GAuBWjY,EAAuB,EAAlBF,IAAmC,SA2VjD8Y;GA/UM5Y,GAAK,MTyrEfoI,kBSzrEgD,EAAtCpI,GAAmD,SAE3D6Y;GAAO7Y,KAAK,STurEdoI,kBSvrEgD,EAAvCpI,IAAoD,SAE3D8Y;GAAc9Y,GTqrEhBoI,kBSrrEuD,EAAvCpI,UAAoD,SAGhE+Y;GAAY/Y,EAAGF,EAAKD,EAAMI,KAC5B,GAAII;KADkBR,OAARG,WAAGF;I,SACbO;EACJP,GACU,GAAJD;EAAI,EAHIG,EAEdF,KADIO,KAGG,MAAA,GAJqBJ,IAGtBJ,cAFFQ,OACJ;EAAAP,iBAAAA,8BAFiBA,EAMf,CAEJ,QAAIkZ;GAAenZ,KAAI,MAAS,G7B9FhCsB,iB6B8FgC,MAAA,KAAbtB,cAAa,SrD1GhCkC,SqD0GsE,SAOlEkX;GAAWjZ,EAAKI,EAAKF,KACvB,MAA8B,GAhB5B6Y,GAeqB7Y,EAAVF,aACsBA,EAAIF,KACnC,UADmCA,UAAAA,SAAAA;MAAAA,kCAAAA;MAAAA,kCAAAA;KAAAA;aAE5BO;OAAO,GAAPA,EAHOD,cACiBJ,EADjBI,GAGPC,KAFX,MAAA,GARE2Y,GAOqB9Y,IAIgB,IAAC,SApBxCgZ;GA0BErZ,KACF,GAAIG;IADFH,GAGG,KAFDG;EACAA,GTupENoI,kBSvpEMpI,cAwBmB,CAvBN,MAAW,EAH1BH,WAMO,GAAA;KALLG,iBAIIA,GAGG,SV0NbsS,gBU7NUtS,GAG8B,UAFQ,GAAb,EAN/BH,WAMuD,EANvDA,kBAOS,MAAA,GAjBToZ,QAUApZ,KAQS,MAAA,GAlBToZ,QAUApZ;EAWgDG,EAAIF,KAKxC,IALoCE,EAKpC,SALoCA,GAfjC;EAeqCF,0EAdZ,YACnC,WAkB4B,CALU,GAAA;QAAnC,MAAA,GApCRiZ,GAyBAlZ,oBAWQ,YAXRA,QAAAA,YAAAA,aAAAA,WAAAA,WAAAA,YAyBS,GAA8B,SAzBvCA,yCAwBU,EAzCVmZ,GAiBAnZ,KA0BK,EA3CLmZ,GAiBAnZ,MA4BsD,SAUxDsZ;GAAoBnZ,EAAKF,EAAKD,GAF7B;EVHCuS,GUKkBpS,EAAKF,OAAAA,WAGjB,YADHI;OAAK,IAAM;EAFcL,EAEzBK,GAAW,kBAAc,SACpB,SAyMVkZ;KAvMoBtZ,KACtB,MAAA,G3CxFI4D,iB2CyFF,GAAUtD;OAAJC,OACAR,EAAI,EADJQ,GAEJ,OAFQD;KAwBAE;EAxBAF,KAwBK,EAvBTP,GAuB8B,YAAuBG,KAAM,MAAQ,GAA/DM,EAAiDN,cAAM,eAAc,GAAhE;KACAQ;EAzBLJ,KA0BJ,EAzBAP,GAyBqB,YAAuBG,KAAM,MAAQ,GADjDQ,EACmCR,cAAM,eAAc,GAAhE;KACYS;EA3BRL,KA4BJ,EA3BAP,GA2BqB,YAAuBG,KAAM,MAAQ,GAD9CS,EACgCT,cAAM,eAAc,GAAhE;KACSU;EA7BLN,KA8BJ,EA7BAP,GA6BqB,YAAuBG,KAAM,MAAQ,GADjDU,EACmCV,cAAM,eAAc,GAAhE,oBAxBI,GAHDa;EAHCT,qBAMA;OAEa,eAPjBP,eADAQ,QAPN8Y,KAQMtZ,WAW8CG,GAC5B,SAD4BA,IACH,yBAE1B,kBAdjBH,aADAQ,QAPN8Y,KAQMtZ,WAkB8CG,GAC5B,SAD4BA,GTkiBtD+R,ESjiByD,wBAAG,EAdhD,IADF,MAAA,UAFClR,WACEb,GAmBL,SAnLR+X,KAgKa/X,MA0B8D,EAhCrDF,IAiCnB,SA+OCuZ;GA7OKrZ,EAAQF,KACjB,GADSI;EAAAF,EAAAA,OACLC,ET0kEJmI,iBS1kEyC,EADxBtI,IAEjB,MAAA,GAkKEsZ,GAnKEnZ,EADKC,cAET,SADID,IAEgB,SAElBqZ;GAAOtZ,EAAQF,EAAKD,KACtB,GADSO;EAAAJ,EAAAA,OACLE,ETqkEJkI,iBSrkEyC,EADxBtI,IAEjB,MAAA,GA6JEsZ,GA9JElZ,EADKE;EAGMJ,KAFXE,cAEWF,GAAY,WAAkB,CAA7C,MAAA,G3ClII0D,K2C+HkB7D,cAGtB,SAFIK,MAGgB,SAsPhBqZ;GA1OKvZ,EAAQF,KACjB,GADSI;EAAAF,EAAAA,OACLC,ETqjEJmI,sBSrjEyD,EADxCtI,IAEjB,MAAA,GA6IEsZ,GA9IEnZ,EADKC,cAET,SADID,IAEgB;gBAvKlBiY,IAIAE,GAEAC,GAEAC,GAEAC,GAEAC,IAMAE,GAGAC,KA2VEC,GA7UFC,GAEAC,IAyWES,YArOKvZ,EAAQF,EAAKD,KACtB,GADSO;EAAAJ,EAAAA,OACLE,ETgjEJkI,sBShjEyD,EADxCtI,IAEjB,MAAA,GAwIEsZ,GAzIElZ,EADKE;EAGMJ,KAFXE,cAEWF,GAAY,WAAkB,CAA7C,MAAA,G3CvJI0D,K2CoJkB7D,cAGtB,SAFIK,MAGgB,mBAiJhB8X,IA9TFE,GAEAC,GAEAC,GAEAC,GAEAC,GAEAC,GAEAC,GAGAC,GAGAC,GAGAC,KA2VEC,GA7UFC,GAEAC,GAEAI,GAqVEG,GAxOFC,0VAmCAE,kBC5OAC;GAAQzZ,GAAM,MD4OdwZ,IC5OQxZ,EAAgC,SDyRxC0Z;GAAK7Z,KAAI;IAAA,uB,cAAJA,QAAiB,SAEtB8Z;MAAS,MvCzRbpC,GuCyRqC,SAIjCqC;GAAK5Z,EAAEF,KAAK,MAA0B,GAFtC8X,GAEK5X,cAAO,MAAA,GvCmEZ6X,KuCnEO/X,MAA+C,SAEtD+Z;GAAI7Z,GAAI,MAAwB,SAEhC8Z;GAAO9Z,EAAEF,KAAI,MAAA,GvC+Db+X,GuC/DO7X,EAAEF,IAAiC,SAO1Cia;GAAS/Z,EAAIF,EAAED,GACjB;EADWG,aAEJ,GAFQF,WAEf,KAAA,eACG,GAHYA,cAAJE,cAAMH,GAIL,OAJDG,eAAMH,EAKgB,OALlBC,IAKH,MAAqC,SA0B3Cka;GAAeha,GACrB,QAAM;EVrMFmS,GUoMiBnS,mBAEX,OAFWA,oBAKC,SAYpBia;GAAiBha,EAAsBH,KAjBnCka,GAiBa/Z,WvCzPZC;IuC2PoCJ,KAAO,OAAPA,SANnCI;EAMmCJ,KAJvC,MAAA,G3C9QA4D,Y2CuOqC1D,K,OAAAA;EAG1B,GADVE;EAFoCF,KAEjCiB,EAFiCjB,KAGjCkB,EADHhB,KAuCcD,yBAvCdC,IAAAA,EAED,SAXF6Z,GAgDiB9Z,EAtCXiB,EADAD;EAIO,GADXb;EALqCJ,KAMjCK,EADJD,IAoCeH,oBApCfG,IAAAA,IAoCeH,aAjCG,MAFdI,GAAAA;WAG6BL,KAgClBC,cAhCkBD,GRhOY,WQgOc,EAA/B,MAAA,GVhM5BiS,GUgMY,OAHR5R;MAEJ;EAGW,GADVC;EAVoCN,KAUjCoB,EAViCpB,KAWjCqB,EADHf,IA+BcL,oBA/BdK,IAAAA,EAEK,EVxLN6R,GUqNelS,kBA9BXoB,UA8BWpB,eA/BXmB,QAGiB;MACd,gCAEI,GADPvB;EAfiCG,KAepCO,EAfoCP,KAgBjCW,EADHJ,IA0BcN,oBA1BdM,IAAAA,EAEE,GAFCV,MAGC,YAEG;EVhMRsS,GUqNelS,kBAzBXU,UAKgC,GAA3BW;OAA2B,IANhCzB,EAAAA,MAAAA,EAMW,SA5BjBka,GAgDiB9Z,EAzBXU,MAKKW;MACA,0BAeLpB,QAJFE;EAUqCN,KAnBrCka,GAiBa/Z,GANf,MAAA,G3C1QAyD,Y2C2Qe1D,KAKAC,cALAD,GAAY,WAAoB,EAH7CI,IAU6D;EAF1BN;EAErCE,GArVJ+X,GAmVmB9X,EAEfD,GACJ,sBvC1PkC;KuCuPOF,MvCvPd,MAAA,GAFpBI,kBAEoB,kBAET,GADZG;EuCsPmCP,KvCrPvB,KADZO,SACM,MAAA,GAJLH,kBAKL;EAFIG,K;S,iB,M,gB;O;O,oB;O;gB;O,M,M,GAHCH,kB,M,gB,C,W,M,sBuC6PL,SAqCEga;GAAKha,EAAKJ,EAAED,KACd,MAAQ,GA3GR6Z,GA0GY5Z,cACJ,MAAA,KADMD,WACVG,GACJ,YAFOE,KACHF,QACY,SAEdma;GAAana,EAAKF,KAAI,MAAA,GAJtBoa,GAIala,WAAwBA,KAAK,YAALA,cAAgC,EAAnDF,IAAsD,SAExEsa;GAAWpa,EAAKF,KAAI,MAAA,GANpBoa,GAMWla,WAAwBA,KAAK,YAALA,cAA8B,EAAjDF,IAAoD,SAEpEua;GAAcra,EAAKF,KAAI,MAAA,GARvBoa,GAQcla,WAAwBA,KAAK,YAAK,EAAVA,IAAuB,EAA1CF,IAA6C,SAEhEwa;GAAiBta,EAAKF,KACxB,MAAA,GAXEoa,GAUiBla,WACJA,KAAK,YAAK,QAAVA,KAA2C,EADlCF,IACqC,SAE3Dya;GAAiBva,EAAKF,KACxB,MAAA,GAdEoa,GAaiBla,WACJA,KAAK,YAAK,QAAVA,KAA2C,EADlCF,IACqC,SAE3D0a;GAAqBxa,EAAKF,KAAI,MAAA,GApVhCyY,GAoVuBvY,EAAKF,IAAmC,SAE7D2a;GAA2Bza,EAAKF,KAAI,MAAA,GApVtC0Y,GAoV6BxY,EAAKF,IAAyC,SAEzE4a;GAA8B1a,EAAKF,KAAI,MAAA,GAnVzC2Y,GAmVgCzY,EAAKF,IAA4C,SAE/E6a;GAA2B3a,EAAKF,KAAI,MAAA,GAlVtC4Y,GAkV6B1Y,EAAKF,IAAyC,SAEzE8a;GAAW5a,EAAKF,KAAI,MAAA,GAxBpBoa,GAwBWla,WAAwBA,KAAK,YAAK,EAAVA,IAAuB,EAA1CF,IAA6C,SAY7D+a;GAAO7a,KACD;ETu2DVoI;ESt2DgCpI,KAAK,gBAAY,EAAjBA,GAA4B,CAAjC;IAAZ,MAAA,UAFJA,WAELA,GAlaN+X,KAkaM/X,GACJ,aACoB,SAElB8a;GAAc9a,KAAI,MAAA,GANlB6a,GAMc7a,IAAY,SAE1B+a;GAAO/a,KAAI,MAAA,GAnVbkZ,GAmVSlZ,IAAgB,SAIvBgb;GAAOhb,EAAQF,EAAKD,KACtB,GADSO;EAAAJ,EAAAA,OACLE,ET21DNkI,iBS31D2C,EADxBtI,IAEjB,MAAA,GA7EAsZ,GA4EIlZ,EADKE,cAGT,MAAA,GA5FA6Z,GA0FI/Z,EADkBL,cAGtB,SAFIK,MAGgB;eAhKpBiX,GAEAuC,GAEAC,GAEA/B,GAEAgC,GAIAE,GAFAD,MAsGEM,IAIAE,GAEAC,GAGAC,GAGAC,GAEAC,IAIAE,GAEAC,KAUAhC,GAEAiC,GAMAC,IAsBAvB,YAEOvZ,EAAQF,EAAKD,KACtB,GADSO;EAAAJ,EAAAA,OACLE,ETy0DNkI,sBSz0D2D,EADxCtI,IAEjB,MAAA,GA/FAsZ,GA8FIlZ,EADKE,cAGT,MAAA,GA9GA6Z,GA4GI/Z,EADkBL,cAGtB,SAFIK,MAGgB,oBAlLpBiX,GAEAuC,GAEAC,GAEA/B,GAEAgC,GAIAE,GAFAD,IAkFE7B,IAoBAmC,GAEAC,GAEAC,GAEAC,GAGAC,GAGAC,GAEAC,GAEAC,GAEAC,GAEAC,KAUAhC,GAEAiC,GAMAC,GAEAC,GAEA1B,GAEA2B,oWEhdJC;GAAOjb,GAAI,GAAJA,SAAAA;SAAAA;EAIe;EASH,kBASA;SAtBZA;EAKe;EASH,kBASA;SAvBZA;EAMe;EASH,kBASA;SAxBZA;EAOe;EASH,kBASA;SAzBZA;EAQe;EASH,kBASA;SA1BZA;EASe;EASH,kBASA;SA3BZA;EAUe;EASH,kBASA,yBA5BZA;EAWe;EASH,kBASA,WA3BT,SA4BX,CAEU,GAAPkb;GAAO,EzCsBPlZ,YyCtBqBhC,KACvB,GAAA;gBAEqC,MAAA,KAHdA;kBAGrB,MAAA;uBADwC,MAAA;kBAA/B,MAAA,oBADX,MAAA,iCAGC,OAWCmb,GAAQ,EzCORnZ,YyCPsBhC,KACxB,GAAA;gBAEqC,MAAA,KAHbA;kBAGtB,MAAA;uBADwC,MAAA;kBAA/B,MAAA,oBADX,MAAA,iCAGC,8B,0BxDqiBKob;GAEFpb,GAEJ;EAFIA;EAGc,MAHdA;EAIY,MAJZA;EAKW,MALXA,WAOQ,GADJC;OACFH,EATAsb,GAQEnb,SACFH,IADEG,OANJD,QAOEF,GAGJ,MAHIA,GAGD,SAQHub;GACErb,EADkBF,GAClBE,KADkBF,EAGtB,MAFIE,EAEoB,CAsJJ,GAzCtBsb;qBA2FIC;GAAyBvb,EAAGF,GAC9B,aAD2BE;aAAGF,QAAAA;aAAHE,KAAAA,EAAGF,EAK3B,SAWG0b;GAIJxb,GAJ8B,SAI9BA;oBAAAA;EAMS,GADyBF;EALlCE,KAMIH,EAVA2b,GAIJxb,MAQA,MA5BAub,IA0BI1b,EAVA2b,GAS8B1b;MALlCE,QAFA,eAKA,MAHAA,EAQ8B,CAmRhC,GApFFyb;eAoFWzb,KCznBT+C,OD2nBe,MAAA,GHpiCfuI,GGkiCStL,cCznBT+C,MADe,GArLfJ,ODmzBE,MAAA,GHp8BF6I,GIiJA7I,eDozBE,GCpzBFA,IA6PF,MAAA,GAHEO,iBAIF,SAAA,YDujBU,WAlGVwY;GAoGqC1b,EAAEF,KAKrC,YACKE,GACH,MAAA,GAnGJyb,MAkGOzb,IACsB,GAFvB,MAAA,GAL+BA,EAAEF,c,IAKjC,aAEuB,CAI7B;wBAYI6b;GACC7b,EACAM,KAwDH,GAAIF;MAxDDE,KAAAA;KA+DD,GApCwBF;EA5BvBJ,aA6BOG;EAAmBD,EAAGF,KAC5B,GADyBG;EAAAD,EAAGE,EAAAJ,EAC5B,iBADyBG;aAGvB,MAAA,GAcAI,EAjB0BH,YAAHD;EAeD,GAfIQ;KAAHR,KAAGC,GAAHD,EAAAA,KAAGC,EAAAO;KAIwBC;EAJ3BT,KAKvB,MAAA,GADkDS,EAhCrDN,cAiCG,MAAA,GAYAC,EAjB0BH;EAAHD,cASvB,MAAA,GAQAI,EAjB0BH,QAWPS;OACnB,MAAA,GADmBA,EAvCtBP,cAwCG,MAAA,GAKAC,EAjB0BH,QAeO,SAEjCG;EAAUL,KACZ,MADYA,GAGE,EApBRC,EAiBMD,KAAAA,YAG4B,CAI1C,MAAA,GAxBQC,EADgBC,MAoCuB,CADjD,IANIA,EAMJ,eA5DyBI;EAHtBR,aAIOG;EAAmBD,EAAGF,KAC5B,GADyBG;EAAAD,EAAGI,EAAAN,EAC5B,iBADyBG;aAGvB,MAAA,GAWAI,EAd0BD,YAAHH;EAYD,GAZIK;KAAHL,KAAGG,GAAHH,EAAAA,KAAGG,EAAAE;KAIcC;EAJjBN,KA9a/Bqb,MA8a+Brb,KAMvB;IAAA,MAAA,GAtIRyb,GAoIgDnb,gBAExC,MAAA,GAQAF,EAd0BD,kByD9mCzBF;EzD8mCsBD,QyD9mCtBC,MAAAA,OAAAA,QAAAA,KAAAA,QAAAA,KzDunCD,MAAA,GAKAG,EAd0BD,MAYO,SAEjCC;EAAUL,KACZ,MADYA,GAGE,EAjBRC,EAcMD,KAAAA,YAG4B,CAI1C,MAAA,GArBQC,EADeK,MA8DwB,CAMd,GAAjCsb;SsBpmCOC,GAjFTjX,MtBmrCEkX,cA6BAC;GAAuB/b,KA3BvB4b,MAAAA,aA4BE1b;EA7gBNob,MA8gBe,MAAA,GAFYtb,aAErBA,GAXJ;MAlBE4b;KsBnmCJ,OADWC,MtBunCG,WAC2B;EsB/pCvC9W,GAuCS8W,ItBynCL,MAAA,GA7FFF,esB3hCQ;ItBmmCRC,MAAAA,UAjfJN,MA6gBMpb,EAEJ,WALmC,kBAAA,EAM7B,SAtPR8b;GAoRahc,EAAiBF,EAA+BD,EAAEI,KAC7D,GAdEI;EAayDR,QA9pBzDwb,GA8pByDxb,EAAEI,GAX7D,GAJIG;EAeOJ,EAAAA,OAdPO,EAcwBT,EAAAA,KA/D1Bgc,GAoDErb,EAJAL,EACAG,GA/CFqb,UA8CExb;KAmBJ,YAVA,MALIK,IsB5tCJqE,MtB0tCEzE,EAa2DJ,GsBjqCpD4b,UtB8pCgB,EA/BvBE,iBAgCE,MADF,GAlIAJ,GAwHAtb,EAa2DJ,IAF3B,IASjC,SA7QHgc;GAgRMjc,EACQE,EACTL,KAEH,GAJIO;EAAAJ,EAAAA,OAIJ,GAJII,EAKF,MAAA,GAJUF,OAYV,MApFA0b,MAsGyB,MAAA,GA3EzBG,iBA4EI,MAAA,GA/BM7b,MA+BF,KAjBJ;EAbHL,KsBnvCHiF,+BAsES+W,ItBqsCL,WAMO,SAwLbK;GAeiBlc,GACf,mBADeA,MASR,IyD39CDmc;SAAAA,MAAAA,GAAAA,aCNNC;GAAapc,GXwFbyS,OWxFsC,EAAzBzS,UAAsC,C1D++BrDyb,e0D3+BMzb,KAJJoc,OAMe,MAAA,G7D2Bf9Q,G6D7BItL,cAJJoc,MAME,MAAA,G7D6HF5Q,GIiJA7I,OyD7QiC,UCnBjC0Z;GAAQrc,K,YAAAA,8BpDaNsc;GAAgBtc,EAAGF,GACrB,MAAG,GADkBA,EAAHE,SAGV,EAHaF,EAAHE,SAKV,EALaF,EAAHE,SAOV,EAPaF,EAAHE,UAST,SAkFPuc;GAAK1c,KACP;EADOA;EACHG,GACJ,OADIA;EAa0B,GAHRC;EAVlBD,KAUgBE,EAVhBF,WADGH,KAcuB,oBAAA,YAHVK,EAAED,MAElB,YAbGJ;EAIG,GADiBU;EAFvBP,KAGEQ,E+BzDNsP,GjC/DcpF,EEoHP7K,KACHG,MAKA,YAFEQ,EADqBD,EAHpBV,iBAkBA,SNzHPkC,kCWFAsB,YL2H2D,SA2DzDmZ;GAASxc,KACX;KADWA;EACPA,GACJ,OADIA;KAIkBH;EAJlBG,KAIgBC,EAJhBD,KAI6B,2BAAA,YAAbC,EAAEJ;KAFIK;EAFtBF,KAEoBI,EAFpBJ,KAEkBK,EAFlBL,KAEmC,2BAAA,YAAjBK,EAAED,EAAEF,kBACDI;EAHrBN,KAGmBO,EAHnBP,KAGmC,2BAAA,YAAhBO,EAAED,mBAJdN,eKtLXqD,GLsLWrD,OAAAA,EAK8C,SAsHvDyc;QAAa;KACC5c;SAAAA;;uBACHqB;OAAHD,OAAHD;ENjTPe,MMiTab,OAAHD,OAAHD,OAKL,eANcnB,QACTmB,EAAGC,EAAGC,EADGrB;KAcHS;SAAAA;;uBACAe;OAAHD,OAAHD;EN/TPY,MM+TaV,OAAHD,OAAHD,OAKL,eANWb,QACNa,EAAGC,EAAGC,EADAf;EAcM,8BACLK;SAAAA;;uBACDa;OAAHD,OAAHD;EN9UPS,MM8UaP,OAAHD,OAAHD,OAKL,eANYX,QACPW,EAAGC,EAAGC,EADCb,aAaX,SAmBD+b;QAAc;EACM;EAIH;EAKL,GADD7c;OACC,EFrXd4R,GEoXa5R,KAAAA,KAAAA,KAAAA,KAAAA,mCNtXbkC,eM+XoB,mBAAc,SAEhC4a;QAAsB,YAEjB,SNnYP5a,UMkYalC;OAAM,eAANA,KAAAA,KAAAA,KAAAA,OAAAA,OAC+E,SAE1F+c;QAAsB,YAEjB,SNvYP7a,UMsYalC;OAAM,eAANA,KAAAA,KAAAA,KAAAA,OAAAA,OAC+E,SAa1F8J;GAAQ3J,IAA6BH,KAC/B,GADqBS;OACzBG,oBADMT;oBAAAA;;gB;EAtQR,GADgBE;cAChB,QAGuB,MAAA,GF6DzB0R,KEjEkB1R,EAuQqBL,cArQ7B,GADJA;KADYK,eAAAA;KAQhB,yBAA+C,EA9C/Cqc,GAuCI1c,OAAAA;EAjBJ,GADaO;cACb,QAEuB,MAAA,GF+EzBwR,KElFexR,EAwRwBP,cAvRrC,eADaO;;OAQb,wDAQiB,SN5InB2B;;gB;EM0KE,GADgB7B;cAChB,QAGuB,MAAA,GFiCzB0R,KErCkB1R,EA2OqBL,cAzO7B,GADJA;KADYK,eAAAA;KAQhB,yBAA+C,EA1E/Cqc,GAmEI1c,OAAAA;EAjBJ,GADaO;cACb,QAEuB,MAAA,GFmDzBwR,KEtDexR,EA4PwBP,cA3PrC,eADaO;;OAQb,wDAQiB,SNxKnB2B;;gB;EM2WsB;EAdH;EAIL,GADDlC;OACC,EF/Vd4R,GE8Va5R,KAAAA,KAAAA,KAAAA,KAAAA,iCNhWbkC,eMwWoB;;EAzDlB0a;;EA8DAC;;EAoBAC;EAIAC,eAeQ5c,QAtTGK;EAsTHL,qB,wB+BlWV8P,GjC/DcpF,UE2GDrK,UN9Fb0B;GM2Lc7B;EAyNJF,qB;EAvGU;;OAjHoCY,OAAXN,OAAlBF,OAAZC,OACb,GADsDO,GAkC1C,GAANC;E+BvNRgP,GjCpBcnF,EEyMCrK,EAAyCO,KAD1CV,GAoCV,GADIW,MAEGC;EAFHD,UAlCmBT,2BAqCjBJ,GACF,OADEA,KAUK,SN3Of+B,OMoOkB,GADelC;EAFvBG,KAvJEE,E+BxBZ4P,GjC/DcpF,EEyMCrK,EAoCJS,GAKU,MAAA,GAFYjB,EAHtBiB,WAtJad,GAAxB;KAAwBA;EACpBA,GACJ,OADIA;KAUkBC;EAVlBD,KAUgBI,EAVhBJ,cADQE,oBAckB,YAHVE,EAAEH,MAuGuBK;KA/GnBC;EAFtBP,U+BzBJ8P,GjC/DcpF,EEuFFxK,EACRF,MAEsBO,EA+GmBD;EN5L7CyB,MMqO8C,2BA3JtB/B,eK5ExBqD,GL4EwBrD,OAAAA,EAkBsC,eAgGnCI,eK9L3BiD,GL8L2BjD,OAAAA,GAiDb;IAEe,MAAA,GA3D3Boc,GAQyBpc,cAiDb,eAjDCC,IAA8BC,YAAAA,G+BpJ5C;EFtCGiP,G/BfU7E,KEwMAxK,EACCG,UAmBN,MAKmB;KAzBdH,GAuBiB,MAAA,GA9B7Bsc,GAQyBpc,cAoBd,eApBEC,IAA8BC,SA0BhC;IAEkB,MAAA,GApC7Bkc,GAQyBpc,cA0Bd,eA1BEC,IAA8BC,S+B/I5C;EjC1DaoK,eEwMAxK,EACCG,UAKN,MAKmB;KAXdH,GASiB,MAAA,GAhB7Bsc,GAQyBpc,cAMd,eANEC,IAA8BC,SAYhC;IAEkB,MAAA,GAtB7Bkc,GAQyBpc,cAYd,eAZEC,IAA8BC;EA0D3C,GADWT;OACX,EADWA,YAGG;EA5Odyc,GAyOWzc,EA1DCK,oBA0DDL,KAAAA,KAAAA,KAAAA,KAAAA,yBAAAA,KAAAA,KAAAA,KAAAA,KAAAA,aASJ+B;UAlPP0a,GAyOWzc,EA1DCK,GAsEH,eAZEL,KAAAA,KAAAA,KAAAA,KAAAA,iBASJ+B;;KATI/B,KA1DCK,EA0DDL,KAAAA,KAAAA;;KAAAA,KAAAA,KA1DCK,EA0DDL,KAAAA;;KAAAA,KAAAA,KAAAA,KA1DCK,EA0DDL;KA1DCK,EA0DDL,KAAAA,KAAAA,KAAAA,QAWC;OAKcsB,OAAZlB,OACd,IAD0BkB,QAAZlB,MAeP,EAzFKC,EA0EED,cAAAA,KA1EFC,cA0EED,OI5GZ6D,GJkCU5D,EA0EED,cAAAA,KA1EFC,cA0EED,OA0BF,GAANmB;E+BxRRyO,GjCpBcnF,EEkREzK,EAAYkB,KA1EdjB,GAqGV,MADIkB,W+B7OR0O,GjC/DcpF,EEkREzK,EA0BRmB,mBA1BQnB,SAiJR,MAAA,KADJQ,WACAT,GACF,MAAA,GAH2BM,IAEzBN,OASQ;MAAmG,uBAA1B,wBAAvB,wBAAd,kBAApC,SAAC,mBAFX6c,GAEA,wBAGAC;GAAY9c,KACd,GADcA,GAET,GAAA;YAAiH,MAAA;kBAA1B,MAAA;kBAAlC,MAAA;kBAArB,MAAA,oBAAD,0BAC/B,GAAA;YAAwF,MAAA;kBAAnC,MAAA;kBAArB,MAAA,oBAAD,uBAA0F,SAE5H+c;GAAY/c,KACd,GADcA,GAET,GAAA;YAAiH,MAAA;kBAA1B,MAAA;kBAAlC,MAAA;kBAArB,MAAA,oBAAD,0BAC/B,GAAA;YAAyF,MAAA;kBAApC,MAAA;kBAArB,MAAA,oBAAD,uBAA2F,CAGhG;MAA+D,uBAAzC,kBADnDgd,MAC8B,0BAE9BC;QACwD,GAD7Cpd;WAC6C,sBAAL,MAAA,mBAAf;UAAA,KADzBA,cACoB,MAAA,mBAAF,sBAuId,GAAfqd;GAAe,aACfC,GAAa,aACbC,GAAW,qBAEXC;QAAW,GAAA;WAAwB,MAAA,oBAAD,MAAA,uBAAU,CAImC,GAAA;MAAC,sBAA1B,sBAAlB,kBAAlB,SAAC,SAFnB3d,UACA4d,GACa,gBAIoE,MAAC,sBAA1B,sBAAlB,kBAApB,SAAC,SAFnB3d,gBAEa,mBAIb,MATA2d,MASQ,EAZRD,aAUAE,GACF,gBA8H0C,QP0iCjCC;QOvjCX;KAEe,KAAA,cAAY,CADzB,GARYrc;EqC7iBR+Q,GCipEJ9J,iCtCzlDF;KAEe,KAAA,cAAY,CADzB,GAZmB/G;EqC7iBf6Q,GCipEJ9J,kC,wB,+B,QtClnDgB9H;S,G;e,M,sB,K,mB;6B,W,M;eNjqBhBgB,uCAAAA;wC,GMiqBarB;gBAtLgD;EA1DpCD,KACzB,OADyBA;EAuDnB,GAXYE;EA5COF,QAuDnB,EFtfQ0K,KEsfR,MAAA,GQ3cJ1I,WRicchC,KACZ,GAAIC;EiDxfRgb,GjDufgBjb,GAGP,EAAA,EAHOA,EADEE;EAGVL;IAOsB,MAAA,GAzD5Bod,GAiDMhd,cAQQ;KIhdhBwC,GJycQ5C,MAMJ,MAAA,kBALK,SACI,EAjEXid,QIzQEhZ,GJsUY9D,EADEE,MAOH,EA9Db6c,UAKAC,GA4D8C;EAvC1C;EAfmBhd,KAEVS,OAAYM,OAarB,EF9cQ2J,KE8cR,MAAA,GQnaJ1I,WRuZcnC,KACZ,GAAIO;EiD9cR6a,GjD6cgBpb,GAERK,EAAc,KAFNL,GADWkB,WAInBH;OAAgB,GAAiC;KA0O5CX,EAAGK,GA1O0B,KAH1BT,GAGQ,MAAA,GApCtB8J,OAiSGxB,eA7PmB,aAAkD,CAEjE;EAAA,EALOtI,EADDY;EAKCZ,GAMZ;IAC6C,MAAA,GAjB/Cod,GAOM7c;QAUS,MAAA,KARTQ,cAQQ;KIxahB6B,QJiagB5C,OAMZ,MAAA,mBAC+D,CAN1D,SACiB,EAzBxBid,GAqBM5c,KI9RJ4D,GJ4RYjE,EADDY,MASa,EAtB1Bsc,GAgBM7c,OAXN8c,GAoBiE;EAe7D,GAxbYnd;EA2ZOG,KA6BnB,EF5dQ0K,KE4dR,MAAA,GQjbJ1I,WRqac9B,KACZ,GAAIY;EiD5dRma,GjD2dgB/a,GqDxcVO,ErD4BYZ,QqD5BZY,UAAAA;;ErD4BYZ;;EAAAA;;EAAAA;EAAAA;;;IA8aI,GAAdgB;EAAc,KAFNX,cAGRa;OAAgB,GAAiC;KA4N5Cd,EAAGK,GA5N0B,KAH1BJ,GAGQ,MAAA,GAlDtByJ,OAiSGxB,eA/OmB,aAAkD,CAEjE;EAAA,EALOjI,EA5aEL;EAgbFA,GAMZ;IAC6C,MAAA,GA/B/Cod,GAqBMnc;QAUS,MAAA,KARTC,cAQQ;KItbhB0B,QJ+agB5C,OAMZ,MAAA,mBAC+D,CAN1D,SACiB,EAvCxBid,GAmCMjc,KI5SJiD,GJ0SY5D,KA5aEL,QAAAA,QAAAA,WAobU,EApC1Bkd,GA8BMlc,OAzBNmc,GAkCiE,eAe7D;EA3CmBhd,KA8BTa,OAAYK,OAatB,EF1eQwJ,KE0eR,MAAA,GQ/bJ1I,WRmbcnC,KACZ,GAAIO;EiD1eR6a,GjDyegBpb,GAERK,EAAc,KAFNL,GADYqB,WAIpBT;OAAgB,GAAiC;KA8M5CR,EAAGK,GA9M0B,KAH1BT,GAGQ,MAAA,GAhEtB8J,OAiSGxB,eAjOmB,aAAkD,CAEjE;EAAA,EALOtI,EADAgB;EAKAhB,GAMZ;IAC6C,MAAA,GA7C/Cod,GAmCM7c;QAUS,MAAA,KARTK,cAQQ;KIpchBgC,QJ6bgB5C,OAMZ,MAAA,mBAC+D,CAN1D,SACiB,EArDxBid,GAiDM5c,KI1TJ4D,GJwTYjE,EADAgB,MASY,EAlD1Bkc,GA4CM7c,OAvCN8c,GAgDiE,QAgBN;IAAb,MAAA,UAsLnC/c,cAtLmC;IAA/B,MAAA,GQlenB0X,gBRkeM3X,GAAa,GAAA;kBAEV,MAAA,OAFHA,cAEE,GAAA;UAAA,YAAA,MAAA,qBAyKJ,GAAA;EI/nBFyC,MJqYEoa,GiDtYA1B,I7CCF1Y,G6ChBEyY,ajD+oBA,YADkE,MAAA;iBAA9B,MAAA;kBAAhC,MAAA,oBAAD,GAAA;uBACH,MAAA;UANqD;EAhDtBlb,KACjC,OADiCA;;OAqCd,MAAA,iBAAbE,WACAE;OACF,GAAmC;KA0B1BH,EAAGK,GA1BuB,IAAnC,MAAA,GApPFqJ,OAiSGxB,eA7CD,aAAoD,SAClD9H;OACF,GAAmC;KAwB1BJ,EAAGK,GAxBuB,IAAnC,MAAA,GAtPFqJ,OAiSGxB,eA3CD,aAAoD;WAC2C,MAAA,oBAAD,GAAA;eAL5FjI,aAKiD,MAAA,KAJjDE;kBAIqC,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAA/BH,GAA+B,GAAA;WAC8D,MAAA,oBAAD,GAAA;eAN5FC,aAMiD,MAAA,KAHjDG;kBAGqC,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAA/BH,GAA+B,GAAA;WACoB,MAAA,oBAAD,GAAA;UAAf,QAtFvCgd,cAsFkC,MAAA,kBAA9Brd;KADAK,KAE2B,MAAA,GAnF/Bmd,iBAmFA,YADIxd,KAFAI;EAtCJ,GAAIQ;EAJ2BT,yBAQsB,MAAA,KAJjDS,cAIgD,GAAA;UAAf,QAlDrCyc,cAkDgC,MAAA,kBAA5Bjd,GAA4B,GAAA;WAC0B,MAAA,oBAAD,GAAA;UAAf,QAnD1Cid,cAmDqC,MAAA,kBAAjCld,GACJ,YADIA,KADAC;EAIJ,GAAIc;EAZ2Bf,QAa3BgB,gBACF,GAAmC;KAmD1Bf,EAAGK,GAnDuB,IAAnC,MAAA,GA3NFqJ,OAiSGxB,eAtED,aAAoD,EAClDlH,gBACF,GAAmC;KAiD1BhB,EAAGK,GAjDuB,IAAnC,MAAA,GA7NFqJ,OAiSGxB,eApED,aAAoD,KAJlDpH,KAKeX;EAzDnBgd,GAyDKld,EA1DLid;GA0DmB/c;EA1DnB+c,GA0DKjd,EAzDLkd,GA8DA,GAAA;WAAuD,MAAA,oBAAD,GAAA;UAAf,QAhEvCF,cAgEkC,MAAA,kBAA9Bjd,GAA8B,GAAA;WACiE,MAAA,oBAAD,GAAA;eAN/EG,aAMkC,MAAA,KAVjDY;kBAUqC,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAA/BZ,GAA+B,GAAA;WACgE,MAAA,oBAAD,GAAA;eAP7FF,aAOgD,MAAA,KATjDe;kBASqC,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAA/BjB;KAAAA,KAEqC,MAAA,GAhEzCqd;KA6DIjd,WAGY,MAAA,GAhEhBid,iBAgEA,YAJIpd,4CAOJ,GAAImB;EA7B2BpB,4BAiCsB,MAAA,KAJjDoB,cAIgD,GAAA;UAAf,QA3ErC8b,cA2EgC,MAAA,kBAA5Bjd,GAA4B,GAAA;WACuB,MAAA,oBAAD,GAAA;UAAf,QA5EvCid,cA4EkC,MAAA,kBAA9Bld,GACJ,YADIA,KADAC,gBAeiD;IAAb,MAAA,UAiB7BA,cAjB6B;IAA/B,MAAA,GQvoBb0X,gBRuoBM3X,GACJ,GAAA;aAAA,MAAA,OADIA;UAnDmD;EArBxBA,K,OAAAA;KACRK;EAjBrB+c,GAiBYhd,EAlBZ+c,GAkBGjd,EAlBHid;KAkBqB9c;EAlBrB8c,GAkBY/c,EAlBZ+c,GAkBGjd,EAjBHkd,oBAiBqB/c;EAlBrB8c,GAkBY/c,EAjBZgd,GAiBGld,EAlBHid,WAyBE1c;OACF,GAA4B;KAgFjBR,EAAGK,GAhFc,IAA5B,MAAA,GA9LAqJ,OAiSGxB,eAnGH,aAA6C,SAC3CtH;OACF,GAA4B;KA8EjBZ,EAAGK,GA9Ec,IAA5B,MAAA,GAhMAqJ,OAiSGxB,eAjGH,aAA6C,SAC3CrH;OACF,GAA6B;KA4ElBb,EAAGK,GA5Ee,IAA7B,MAAA,GAlMAqJ,OAiSGxB,eA/FH,aAA8C;WAC2B,MAAA,oBAAD,GAAA;eAbrEjI,aAauC,MAAA,KANxCO;kBAM4B,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAAtBR,GAAsB,GAAA;WACiD,MAAA,oBAAD,GAAA;eAd5DG,aAc8B,MAAA,KALxCS;kBAK4B,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAAtBX,GAAsB,GAAA;WACmD,MAAA,oBAAD,GAAA;eAfrDG,aAesB,MAAA,KAJzCS;kBAI6B,MAAA,oBAAD,GAAA;qBAAL,MAAA,kBAAvBV,GAAuB,GAAA;WACyB,MAAA,oBAAD,GAAA;UAAf,QAnClC8c,cAmC6B,MAAA,kBAA3Brd;KAFAK,KAGyC,MAAA,GAhC3Cmd;KA4BEpd,WAIyB,MAAA,GAhC3Bod;KA8BEjd,WAEQ,MAAA,GAhCVid,iBAgCF,YADIxd,8CAImD;IAAb,MAAA,UAoE7BI,cApE6B;IAA/B,MAAA,GQplBb0X,gBRolBM3X,GACJ,GAAA;aAAA,MAAA,OADIA,cA6Dc,GAAA;KAtFhBud,YAsFgB,YAAA,MAAA,qBuC9jBlBhL,GvCmlBYpR,EgD3qBVsY;IhD+iBqD;EA/B1BzZ,KAC7B,OAD6BA,KA4BtB,eF/WUK;EEmVYL,QAGf,MAAA,G+BhddiQ,GjCrFcvF,EA+MGrK,WEsVXL;EAC0BH,KAC5B,GAAIG;E+BxeR8P,GjC/DcpF,EA+MGrK,EEuVeR,GAExB,MAAA,GFnVR8R,GE6eKxJ,GA3JGnI,cACJ,YAF4BH,OAEO,CAFrB,MAAA,GQ3fhBmC,IR0fIhC,WIrPUA,WAAJI;OJ0PuB,MiC9hBnCwQ,InCmMiBvQ,oBE6VZ,SIzOCI;EAAKT,EAAEF,GACb,OADWE,MAAEF;EAAAA,WAGE,GADJW;OAANC,EAFQZ,KAEIwB,OACTC,IAtBInB,EAqBPM,EAAMD,MAAAA,KAANC,SAAAA,KAAMD,MAEP,SADIc,EADSD,iBAFNtB,GAAEF;EAAAA;aAOJ,GAFQD;OAANI,OAANC,EALQJ,KAKU4B,OACfC,IAzBIvB,EAwBPF,EAAMD,KAxBCG,EAwBPF,EAAYL,KAxBLO,EAwBDH,EAAMJ,MAAAA,KAANI,KAANC,UAAMD,KAAMJ,KAAZK,UAAMD,KAANC,KAAYL,SAxBLO,EAwBDH,EAAMJ,KAxBLO,EAwBPF,EAAYL,MAAAA,KAAZK,KAAMD,UAANC,KAAYL,KAANI,UAANC,KAAMD,KAAMJ,OAUb,SATI8B,EADeD,KAcN,GAFTV;EAjBGhB,KAmBM,EAGfe,EALMC,EAjBKlB,GATO0B,OA6BH,EAEfT,EAtBSf,EAiBHgB,UAvBNT,EAHkBiB,EAEdlB,OAFoBD,IA6BdoB,OA5BZ,WAEElB,MADID,MAEIO;EAFJP,KAEJQ,EADAP,KAHqBa,EAEjBd,KAFce,EAGlBd,KAEK,KAfKH,EAcVU,EAAQD,OADRN;EAHkBc,EAAMhB,KAIxBS,EAJwBT,eAEpBC;EAFiBc,EAAGf,KAIhBQ,EAJgBR;EAnRtBkD,GAsRFhD,EAHwBF;;EAnRtBkD,GAqREjD,EAFoBD,GA8BtB,WADQoB,GACoB,SAC9BV;EAASf,EAAEF,GACb,OADWE,MAAEF;EAAAA,WAGE,GADJY;OAANC,EAFQb,KAEIwB,OACTC,IA5CInB,EA2CPO,EAAMD,MAANC,KAAMD,SAAAA,KAANC,MAED,SADIY,EADSD,iBAFNtB,GAAEF;EAAAA;aAOJ,GAFQD;OAANI,OAANC,EALQJ,KAKU4B,OACfC,IA/CIvB,EA8CPF,EAAMD,KA9CCG,EA8CDH,EAAMJ,MAAZK,KAAMD,KAAMJ,SA9CLO,EA8CPF,EAAYL,MAAZK,KAAYL,KAANI,UAAMJ,KAAZK,KAAMD,SA9CCG,EA8CPF,EAAYL,MAANI,KAANC,KAAYL,SA9CLO,EA8CDH,EAAMJ,MAANI,KAAMJ,KAAZK,UAAYL,KAANI,KAANC,OAUD,SATIyB,EADeD,KAcN,GAFTV;EAjBGhB,KAmBM,EAzCXS,EAuCEO,EAjBKlB,GAxCG0B,OA4DC,EA1CXf,EAsBKT,EAiBHgB,UAtDNT,EAHciB,EAEVlB,OAFgBD,IA4DVoB,OA3DZ,WAEElB,MADID,MAEIQ;EAFJR,KAEJS,EADAR,KAHiBa,EAEbd,KAFUe,EAGdd,KAEK,KANKH,EAKVW,EAAQD,OAFJR;EAFac,EAAGf,KAIZS,EAJYT,eAGpBE;EAHcc,EAAMhB,KAIpBU,EAJoBV;EA1QlBkD,GA6QFhD,EAHoBF;;EA1QlBkD,GA4QEjD,EAFgBD,GA6DlB,WADQoB,GACgB,CAEpB,GAAN3B;EAvWFwD,GAuSgBtD,GAxDHc,KAwHXhB,EA7CIW,EA6CJX,EAhEcE,MAAAA;IAvDJF,G,MACJ,SA9MR0D,GA6MY1D,OAEVO;OJoTwBQ,EIpTxBR,KJoTsBD,EIpTtBC,KAAKe,OJqTH,GADsBP,EAGF;EAHEA,KAGRE,OAFVC,cAEUD,UAAAA;GAFVC;KASoC;OATpCA,UADgBZ;OFtZxBsR,GEsZwBtR,WFpWtB;GAJOK;EEwWeL,KFvWXiB,EADJZ,KAIP,EAlDFiR,GA8CSjR,eA9CTiR,GA+CarQ,OEiXE,GAAPG;SAAO,iBAEX,MAAA;qBADmH,MAAA,KAD/GA,cAC8G,GAAA;UAAA,aAAjC,MAAA;iBAAtB,MAAA;UAAf;OAZZ,GAAA;KAiIvBvB,EAAGK,GAjIM,KACEF,GADpB,MAAA,GA7IFuJ,OAiSGxB,eApJD;QAYkC,MAAA;kBAAZ,MAAA,oBAAD,GAAA;qBAAL,MAAA,qBI7TjB,MAAA,KAFI/G,EApNHmC,WAkNQzD,kBAKX,SANYgB,SJyU0C;IAAb,MAAA,UA8G7Bb,cA9G6B;IAA/B,MAAA,GQ1iBb0X,gBR0iBM3X,GACJ,GAAA;aAAA,MAAA,OADIA;UAlCuD;EA5BxCA,K,OAAAA;KAEJC;EAFID,QAIT,MAAA,G+B/ZVkQ,GjCxGcxF,EEqgBCzK,c,SAGJC;OAAO,GAAPA;EAAAA,WAFLD;GAAAA;;GAAAA;KASJ;IAAA,WAA6C,MAAA,KATzCA,cASwC,GAAA;UAAA,WAAtB,MAAA,oBAAD,GAAA;qBAAL,MAAA,qBAAhB;EAGA;EAfiBD,QAgBT,MAAA,GF9TV2R,GE6eKxJ,iB,KA9KiB;OAAN/H,OAFVC,cAEUD,UAAAA;GAFVC;KASJ;IAAA,WAA6C,MAAA,KATzCA,cASwC,GAAA;UAAA,WAAtB,MAAA,oBAAD,GAAA;qBAAL,MAAA,qBAAhB,kCACK,aAGoD;IAAb,MAAA,UAgJjCJ,cAhJiC;IAA/B,MAAA,GQxgBjB0X,gBRwgBM3X,GACJ,GAAA;aAAA,MAAA,OADIA,cAiJc,GAAA;UAAA,YAAA,MAAA,qBuCtkBlBuS,GvCmlBmBlR,EgD3qBjBoY,OvDi7CgB,gE2Dl7CX,GAALgE;MdytBF1L,I7CumBS2L,GAgJXxB,M2Dj9CsCyB,KAAbC,KAGzB,Q3D0tEgBC;Q2D1tEA,MAAA,GfyHV5L,Ge3HFwL,Mdm6BFjL,Kcj6B0D,C3D8tE1D;GApqDM4I,GAowBGsC;;eAs6BH,wBAAe,MAAA,GAxvCvBhC,GA8uCgBmC,OAU4C,KAAgB,EADzD,EA7vCnB5B,qBA4vC2B,MAAA,GAtvC3BP,GA8uCgBmC,OAQgD;EAjyCnD,GADWC;SAClBC,MAnQNzC,MA4hDgBuC,IAzxCVG,SADkBF;iBAClBC,MAAAA,GADkBD,OAAAA,MAClBE,iB8CxrBIC;GahQqBxd,KACnB,MAAA,G3DgtEIod,iBA55BC,GAlBsB5d;K2DnyCRQ,G3DqyCzBP,EApvBEkb,GAowBGsC,IAdT,EAFIxd;K2DlyCM;wB3D0yCR,EyBvzCFgL,GxBJA5J,iBD2zCE,MAAA,KAVe/D;KAaX8C;MAb+BJ,QAAAA,SAAAA,MAcJ,MAAA,GAlWnC+b,QAsVM9b,EAWEG,aALJ,MAAA,GyBrzCF6K,GxBJA5J,iBDyzCE,MAAA,KARe/D,QAkB8B,E2DlzCzB,Cb+PtB,GA4D+E2gB;GA5D/E,YAAyBre,KAEpB,MAFoBA,GD4czBkS,QCnciB,MAAA,GAXTkM,GAEiBpe,WASdG,G,MAAAA,KATcH,mBAUW,SADzBG,KALI;QACE,MAAA,GAPTie,iB,2BAQ4B,aAK1B,GAiD6DE,Ga9UvE9B,e,WAIoCsB,Ib0U6BS,KAATC,Ga9UxDhC,e,WAIuBuB,Ib2UlB,GFlLDxL,wBEyLkC,GAAA;MAClCkM,YAAKte,EAAEF,GACT,GADOE,EAGK,MAHHF,GAAFE,MAEG,MACK,EAHbse,GAToDD,eAcjC,mBAAmB,GALtCC,GAT6DF,eAe7C,gBAAgB,GANhCE,GATmEH,eAgBhD,mBAAmB,GACjC,sBAjBsED;iBAkBrE,kCAlBqEA,OAkBjB,OAfrD,GAALK;GAAK,cACLC,YAASxe,KAAmB;KAJ+Cke,GAIlEle,OAAmB,yB,qBAAY,EACnC,cAFLue,GACAC;iBAEM,uBAHND,GACAC,IAEmD,Ea/UrDf,S3D4uDM,GAAJgB;GAhrCErD,GAowBGsC,YA+bLgB;MACF,GAyCuC7d;EAzV3Cqb,MA4RMuC,KA+BExe,EA3kCRqb,MAinCI,mBATItb,KA1BF,OA0BEA,MAEU,GAANE;EA9uCJkb,GA6uCmCva,OAIjC,MAAA,GAn1BVmb,QAg1BY9b,EAFJF,WAI2BA,GAE3B,cA9mCRsb,MA2kCQrb;EAWaD,GAIH,GA9FZE;EAhoCEkb,GA6uCmCva,GAvGrCZ,EAtoCEmb,GA0tCapb,GAlFhB,EAFCC,IANAC;KAwGE,YAhGH,KAAA;EAFCD;WAxuBN+b,QAkuBM9b,EAMAD;EAp0BF,GAFiBG;OAAMP,EAg0BrBK,QA3zBAM,EAtGF+a,GAiGuB1b,KAANO,MAKIK,EALEZ,KAANO,aAKIK,KAAAE;IAAnBD,EAtFE8a,GAsFFhb;GAAmBG;EAAAF,EAAnBC,EAAAF,KA/FyBF;EA0FVF,KA1FOG,EA0FDV,KAYrBiB,QAtGsBP;aAAGD,QAAAA;aAAHC,KAAAA,EAAGD,GA0FJT,KAKrBa,EALqBb,KAYrBiB,EAZqBjB,KAKFc,EALEd,KAANO,KA5SjBib,GAknCEpb,KANAC,IA8BA,6BAhwBN8b,QAkuBM9b,EAMAD,qBAiFiBD,GA3VrB,eA2VqBA,IA3VmB,GA2V5B,MAAA,GAzCHwd,iB,IAyCG,aA2BI,EAGmB,CAGnC;GAxEIiB;EA90BQ,GAFsBE;SAVSC,MA62BvCF,UAx2BAG,GAK8BF,MAVSG,SAKvCD;cALuCD,MAAAA,GAKvCC,IAK8BF,MAVSG;;eAw6BrC,GAAUhf;EA3DZ4e,SA6DE,UAFU5e,EA9EZ2e,MAgF0B,EAHb,EAj1BnBxC,qBAg1B2B,MACR,GA/ERuB,OA8EmB,O6Dv0DxB,E5DoiBJta,c","sourcesContent":["// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010-2014 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// An OCaml string is an object with three fields:\n// - tag 't'\n// - length 'l'\n// - contents 'c'\n//\n// The contents of the string can be either a JavaScript array or\n// a JavaScript string. The length of this string can be less than the\n// length of the OCaml string. In this case, remaining bytes are\n// assumed to be zeroes. Arrays are mutable but consumes more memory\n// than strings. A common pattern is to start from an empty string and\n// progressively fill it from the start. Partial strings makes it\n// possible to implement this efficiently.\n//\n// When converting to and from UTF-16, we keep track of whether the\n// string is composed only of ASCII characters (in which case, no\n// conversion needs to be performed) or not.\n//\n// The string tag can thus take the following values:\n//   full string     BYTE | UNKNOWN:      0\n//                   BYTE | ASCII:        9\n//                   BYTE | NOT_ASCII:    8\n//   string prefix   PARTIAL:             2\n//   array           ARRAY:               4\n//\n// One can use bit masking to discriminate these different cases:\n//   known_encoding(x) = x&8\n//   is_ascii(x) =       x&1\n//   kind(x) =           x&6\n\n//Provides: caml_str_repeat\nfunction caml_str_repeat(n, s) {\n  if(n == 0) return \"\";\n  if (s.repeat) {return s.repeat(n);} // ECMAscript 6 and Firefox 24+\n  var r = \"\", l = 0;\n  for(;;) {\n    if (n & 1) r += s;\n    n >>= 1;\n    if (n == 0) return r;\n    s += s;\n    l++;\n    if (l == 9) {\n      s.slice(0,1); // flatten the string\n      // then, the flattening of the whole string will be faster,\n      // as it will be composed of larger pieces\n    }\n  }\n}\n\n//Provides: caml_subarray_to_jsbytes\n//Weakdef\n// Pre ECMAScript 5, [apply] would not support array-like object.\n// In such setup, Typed_array would be implemented as polyfill, and [f.apply] would\n// fail here. Mark the primitive as Weakdef, so that people can override it easily.\nfunction caml_subarray_to_jsbytes (a, i, len) {\n  var f = String.fromCharCode;\n  if (i == 0 && len <= 4096 && len == a.length) return f.apply (null, a);\n  var s = \"\";\n  for (; 0 < len; i += 1024,len-=1024)\n    s += f.apply (null, a.slice(i,i + Math.min(len, 1024)));\n  return s;\n}\n\n//Provides: caml_utf8_of_utf16\nfunction caml_utf8_of_utf16(s) {\n  for (var b = \"\", t = b, c, d, i = 0, l = s.length; i < l; i++) {\n    c = s.charCodeAt(i);\n    if (c < 0x80) {\n      for (var j = i + 1; (j < l) && (c = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    if (c < 0x800) {\n      t += String.fromCharCode(0xc0 | (c >> 6));\n      t += String.fromCharCode(0x80 | (c & 0x3f));\n    } else if (c < 0xd800 || c >= 0xdfff) {\n      t += String.fromCharCode(0xe0 | (c >> 12),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    } else if (c >= 0xdbff || i + 1 == l ||\n               (d = s.charCodeAt(i + 1)) < 0xdc00 || d > 0xdfff) {\n      // Unmatched surrogate pair, replaced by \\ufffd (replacement character)\n      t += \"\\xef\\xbf\\xbd\";\n    } else {\n      i++;\n      c = (c << 10) + d - 0x35fdc00;\n      t += String.fromCharCode(0xf0 | (c >> 18),\n                               0x80 | ((c >> 12) & 0x3f),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    }\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: caml_utf16_of_utf8\nfunction caml_utf16_of_utf8(s) {\n  for (var b = \"\", t = \"\", c, c1, c2, v, i = 0, l = s.length; i < l; i++) {\n    c1 = s.charCodeAt(i);\n    if (c1 < 0x80) {\n      for (var j = i + 1; (j < l) && (c1 = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    v = 1;\n    if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n      c = c2 + (c1 << 6);\n      if (c1 < 0xe0) {\n        v = c - 0x3080;\n        if (v < 0x80) v = 1;\n      } else {\n        v = 2;\n        if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n          c = c2 + (c << 6);\n          if (c1 < 0xf0) {\n            v = c - 0xe2080;\n            if ((v < 0x800) || ((v >= 0xd7ff) && (v < 0xe000))) v = 2;\n          } else {\n            v = 3;\n            if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128) &&\n                (c1 < 0xf5)) {\n              v = c2 - 0x3c82080 + (c << 6);\n              if (v < 0x10000 || v > 0x10ffff) v = 3;\n            }\n          }\n        }\n      }\n    }\n    if (v < 4) { // Invalid sequence\n      i -= v;\n      t += \"\\ufffd\";\n    } else if (v > 0xffff)\n      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF))\n    else\n      t += String.fromCharCode(v);\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: jsoo_is_ascii\nfunction jsoo_is_ascii (s) {\n  // The regular expression gets better at around this point for all browsers\n  if (s.length < 24) {\n    // Spidermonkey gets much slower when s.length >= 24 (on 64 bit archs)\n    for (var i = 0; i < s.length; i++) if (s.charCodeAt(i) > 127) return false;\n    return true;\n  } else\n    return !/[^\\x00-\\x7f]/.test(s);\n}\n\n//Provides: caml_bytes_unsafe_get mutable\nfunction caml_bytes_unsafe_get (s, i) {\n  switch (s.t & 6) {\n  default: /* PARTIAL */\n    if (i >= s.c.length) return 0;\n  case 0: /* BYTES */\n    return s.c.charCodeAt(i);\n  case 4: /* ARRAY */\n    return s.c[i]\n  }\n}\n\n//Provides: caml_bytes_unsafe_set\n//Requires: caml_convert_bytes_to_array\nfunction caml_bytes_unsafe_set (s, i, c) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t != 4 /* ARRAY */) {\n    if (i == s.c.length) {\n      s.c += String.fromCharCode (c);\n      if (i + 1 == s.l) s.t = 0; /*BYTES | UNKOWN*/\n      return 0;\n    }\n    caml_convert_bytes_to_array (s);\n  }\n  s.c[i] = c;\n  return 0;\n}\n\n//Provides: caml_string_bound_error\n//Requires: caml_invalid_argument\nfunction caml_string_bound_error () {\n  caml_invalid_argument (\"index out of bounds\");\n}\n\n//Provides: caml_bytes_bound_error\n//Requires: caml_invalid_argument\nfunction caml_bytes_bound_error () {\n  caml_invalid_argument (\"index out of bounds\");\n}\n\n//Provides: caml_string_get\n//Requires: caml_string_bound_error, caml_string_unsafe_get\n//Requires: caml_ml_string_length\nfunction caml_string_get (s, i) {\n  if (i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();\n  return caml_string_unsafe_get (s, i);\n}\n\n//Provides: caml_string_get16\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_ml_string_length\nfunction caml_string_get16(s,i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get (s, i),\n      b2 = caml_string_unsafe_get (s, i + 1);\n  return (b2 << 8 | b1);\n}\n\n//Provides: caml_bytes_get16\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\nfunction caml_bytes_get16(s,i) {\n  if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();\n  var b1 = caml_bytes_unsafe_get (s, i),\n      b2 = caml_bytes_unsafe_get (s, i + 1);\n  return (b2 << 8 | b1);\n}\n\n//Provides: caml_string_get32\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_ml_string_length\nfunction caml_string_get32(s,i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get (s, i),\n      b2 = caml_string_unsafe_get (s, i + 1),\n      b3 = caml_string_unsafe_get (s, i + 2),\n      b4 = caml_string_unsafe_get (s, i + 3);\n  return (b4 << 24 | b3 << 16 | b2 << 8 | b1);\n}\n\n//Provides: caml_bytes_get32\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\nfunction caml_bytes_get32(s,i) {\n  if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();\n  var b1 = caml_bytes_unsafe_get (s, i),\n      b2 = caml_bytes_unsafe_get (s, i + 1),\n      b3 = caml_bytes_unsafe_get (s, i + 2),\n      b4 = caml_bytes_unsafe_get (s, i + 3);\n  return (b4 << 24 | b3 << 16 | b2 << 8 | b1);\n}\n\n//Provides: caml_string_get64\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_int64_of_bytes\n//Requires: caml_ml_string_length\nfunction caml_string_get64(s,i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();\n  var a = new Array(8);\n  for(var j = 0; j < 8; j++){\n    a[7 - j] = caml_string_unsafe_get (s, i + j);\n  }\n  return caml_int64_of_bytes(a);\n}\n\n//Provides: caml_bytes_get64\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\n//Requires: caml_int64_of_bytes\nfunction caml_bytes_get64(s,i) {\n  if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();\n  var a = new Array(8);\n  for(var j = 0; j < 8; j++){\n    a[7 - j] = caml_bytes_unsafe_get (s, i + j);\n  }\n  return caml_int64_of_bytes(a);\n}\n\n//Provides: caml_bytes_get\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_get\nfunction caml_bytes_get (s, i) {\n  if (i >>> 0 >= s.l) caml_bytes_bound_error();\n  return caml_bytes_unsafe_get (s, i);\n}\n\n//Provides: caml_string_set\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_set (s, i, c) {\n  caml_failwith(\"caml_string_set\");\n}\n\n//Provides: caml_string_set\n//Requires: caml_string_unsafe_set, caml_string_bound_error\n//If: !js-string\nfunction caml_string_set (s, i, c) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_set (s, i, c);\n}\n\n//Provides: caml_bytes_set16\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set16(s,i,i16){\n  if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();\n  var b2 = 0xFF & i16 >> 8,\n      b1 = 0xFF & i16;\n  caml_bytes_unsafe_set (s, i + 0, b1);\n  caml_bytes_unsafe_set (s, i + 1, b2);\n  return 0\n}\n\n//Provides: caml_string_set16\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_set16(s,i,i16){\n  caml_failwith(\"caml_string_set16\");\n}\n\n//Provides: caml_string_set16\n//Requires: caml_bytes_set16\n//If: !js-string\nfunction caml_string_set16(s,i,i16){\n  return caml_bytes_set16(s,i,i16);\n}\n\n//Provides: caml_bytes_set32\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set32(s,i,i32){\n  if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();\n  var b4 = 0xFF & i32 >> 24,\n      b3 = 0xFF & i32 >> 16,\n      b2 = 0xFF & i32 >> 8,\n      b1 = 0xFF & i32;\n  caml_bytes_unsafe_set (s, i + 0, b1);\n  caml_bytes_unsafe_set (s, i + 1, b2);\n  caml_bytes_unsafe_set (s, i + 2, b3);\n  caml_bytes_unsafe_set (s, i + 3, b4);\n  return 0\n}\n\n//Provides: caml_string_set32\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_set32(s,i,i32){\n  caml_failwith(\"caml_string_set32\");\n}\n\n//Provides: caml_string_set32\n//Requires: caml_bytes_set32\n//If: !js-string\nfunction caml_string_set32(s,i,i32){\n  return caml_bytes_set32(s,i,i32);\n}\n\n//Provides: caml_bytes_set64\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\n//Requires: caml_int64_to_bytes\nfunction caml_bytes_set64(s,i,i64){\n  if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();\n  var a = caml_int64_to_bytes(i64);\n  for(var j = 0; j < 8; j++) {\n    caml_bytes_unsafe_set (s, i + 7 - j, a[j]);\n  }\n  return 0\n}\n\n//Provides: caml_string_set64\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_set64(s,i,i64){\n  caml_failwith(\"caml_string_set64\");\n}\n\n//Provides: caml_string_set64\n//Requires: caml_bytes_set64\n//If: !js-string\nfunction caml_string_set64(s,i,i64){\n  return caml_bytes_set64(s,i,i64);\n}\n\n//Provides: caml_bytes_set\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set (s, i, c) {\n  if (i >>> 0 >= s.l) caml_bytes_bound_error();\n  return caml_bytes_unsafe_set (s, i, c);\n}\n\n//Provides: caml_bytes_of_utf16_jsstring\n//Requires: jsoo_is_ascii, caml_utf8_of_utf16, MlBytes\nfunction caml_bytes_of_utf16_jsstring (s) {\n  var tag = 9 /* BYTES | ASCII */;\n  if (!jsoo_is_ascii(s))\n    tag = 8 /* BYTES | NOT_ASCII */, s = caml_utf8_of_utf16(s);\n  return new MlBytes(tag, s, s.length);\n}\n\n\n//Provides: MlBytes\n//Requires: caml_convert_string_to_bytes, jsoo_is_ascii, caml_utf16_of_utf8\nfunction MlBytes (tag, contents, length) {\n  this.t=tag; this.c=contents; this.l=length;\n}\nMlBytes.prototype.toString = function(){\n  switch (this.t) {\n  case 9: /*BYTES | ASCII*/\n    return this.c;\n  default:\n    caml_convert_string_to_bytes(this);\n  case 0: /*BYTES | UNKOWN*/\n    if (jsoo_is_ascii(this.c)) {\n      this.t = 9; /*BYTES | ASCII*/\n      return this.c;\n    }\n    this.t = 8; /*BYTES | NOT_ASCII*/\n  case 8: /*BYTES | NOT_ASCII*/\n    return this.c;\n  }\n};\nMlBytes.prototype.toUtf16 = function (){\n  var r = this.toString();\n  if(this.t == 9) return r\n  return caml_utf16_of_utf8(r);\n}\nMlBytes.prototype.slice = function (){\n  var content = this.t == 4 ? this.c.slice() : this.c;\n  return new MlBytes(this.t,content,this.l);\n}\n\n//Provides: caml_convert_string_to_bytes\n//Requires: caml_str_repeat, caml_subarray_to_jsbytes\nfunction caml_convert_string_to_bytes (s) {\n  /* Assumes not BYTES */\n  if (s.t == 2 /* PARTIAL */)\n    s.c += caml_str_repeat(s.l - s.c.length, '\\0')\n  else\n    s.c = caml_subarray_to_jsbytes (s.c, 0, s.c.length);\n  s.t = 0; /*BYTES | UNKOWN*/\n}\n\n//Provides: caml_convert_bytes_to_array\nfunction caml_convert_bytes_to_array (s) {\n  /* Assumes not ARRAY */\n  var a = new Uint8Array(s.l);\n  var b = s.c, l = b.length, i = 0;\n  for (; i < l; i++) a[i] = b.charCodeAt(i);\n  for (l = s.l; i < l; i++) a[i] = 0;\n  s.c = a;\n  s.t = 4; /* ARRAY */\n  return a;\n}\n\n//Provides: caml_uint8_array_of_bytes mutable\n//Requires: caml_convert_bytes_to_array\nfunction caml_uint8_array_of_bytes (s) {\n  if (s.t != 4 /* ARRAY */) caml_convert_bytes_to_array(s);\n  return s.c;\n}\n\n//Provides: caml_uint8_array_of_string mutable\n//Requires: caml_convert_bytes_to_array\n//Requires: caml_ml_string_length, caml_string_unsafe_get\nfunction caml_uint8_array_of_string (s) {\n  var l = caml_ml_string_length(s);\n  var a = new Array(l);\n  var i = 0;\n  for (; i < l; i++) a[i] = caml_string_unsafe_get(s,i);\n  return a;\n}\n\n//Provides: caml_create_string const\n//Requires: MlBytes, caml_invalid_argument\n//If: !js-string\nfunction caml_create_string(len) {\n  if(len < 0) caml_invalid_argument(\"String.create\");\n  return new MlBytes(len?2:9,\"\",len);\n}\n\n//Provides: caml_create_string const\n//Requires: caml_invalid_argument\n//If: js-string\nfunction caml_create_string(len) {\n  caml_invalid_argument(\"String.create\");\n}\n\n//Provides: caml_create_bytes const\n//Requires: MlBytes,caml_invalid_argument\nfunction caml_create_bytes(len) {\n  if (len < 0) caml_invalid_argument(\"Bytes.create\");\n  return new MlBytes(len?2:9,\"\",len);\n}\n\n//Provides: caml_string_of_array\n//Requires: caml_subarray_to_jsbytes, caml_string_of_jsbytes\nfunction caml_string_of_array (a) {\n  return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length));\n}\n\n//Provides: caml_bytes_of_array\n//Requires: MlBytes\nfunction caml_bytes_of_array (a) {\n  if(! (a instanceof Uint8Array)) {\n    a = new Uint8Array(a);\n  }\n  return new MlBytes(4,a,a.length);\n}\n\n//Provides: caml_bytes_compare mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_compare(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?-1:(s1.c > s2.c)?1:0;\n}\n\n\n//Provides: caml_bytes_equal mutable (const, const)\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_equal(s1, s2) {\n  if(s1 === s2) return 1;\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c == s2.c)?1:0;\n}\n\n//Provides: caml_string_notequal mutable (const, const)\n//Requires: caml_string_equal\nfunction caml_string_notequal(s1, s2) { return 1-caml_string_equal(s1, s2); }\n\n//Provides: caml_bytes_notequal mutable (const, const)\n//Requires: caml_bytes_equal\nfunction caml_bytes_notequal(s1, s2) { return 1-caml_bytes_equal(s1, s2); }\n\n//Provides: caml_bytes_lessequal mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessequal(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c <= s2.c)?1:0;\n}\n\n//Provides: caml_bytes_lessthan mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessthan(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?1:0;\n}\n\n//Provides: caml_string_greaterequal\n//Requires: caml_string_lessequal\nfunction caml_string_greaterequal(s1, s2) {\n  return caml_string_lessequal(s2,s1);\n}\n//Provides: caml_bytes_greaterequal\n//Requires: caml_bytes_lessequal\nfunction caml_bytes_greaterequal(s1, s2) {\n  return caml_bytes_lessequal(s2,s1);\n}\n\n//Provides: caml_string_greaterthan\n//Requires: caml_string_lessthan\nfunction caml_string_greaterthan(s1, s2) {\n  return caml_string_lessthan(s2, s1);\n}\n\n//Provides: caml_bytes_greaterthan\n//Requires: caml_bytes_lessthan\nfunction caml_bytes_greaterthan(s1, s2) {\n  return caml_bytes_lessthan(s2, s1);\n}\n\n//Provides: caml_fill_bytes\n//Requires: caml_str_repeat, caml_convert_bytes_to_array\n//Alias: caml_fill_string\nfunction caml_fill_bytes(s, i, l, c) {\n  if (l > 0) {\n    if (i == 0 && (l >= s.l || (s.t == 2 /* PARTIAL */ && l >= s.c.length))) {\n      if (c == 0) {\n        s.c = \"\";\n        s.t = 2; /* PARTIAL */\n      } else {\n        s.c = caml_str_repeat (l, String.fromCharCode(c));\n        s.t = (l == s.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n      }\n    } else {\n      if (s.t != 4 /* ARRAY */) caml_convert_bytes_to_array(s);\n      for (l += i; i < l; i++) s.c[i] = c;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_bytes\n//Requires: caml_subarray_to_jsbytes, caml_convert_bytes_to_array\nfunction caml_blit_bytes(s1, i1, s2, i2, len) {\n  if (len == 0) return 0;\n  if ((i2 == 0) &&\n      (len >= s2.l || (s2.t == 2 /* PARTIAL */ && len >= s2.c.length))) {\n    s2.c = (s1.t == 4 /* ARRAY */)?\n      caml_subarray_to_jsbytes(s1.c, i1, len):\n      (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else if (s2.t == 2 /* PARTIAL */ && i2 == s2.c.length) {\n    s2.c += (s1.t == 4 /* ARRAY */)?\n      caml_subarray_to_jsbytes(s1.c, i1, len):\n      (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else {\n    if (s2.t != 4 /* ARRAY */) caml_convert_bytes_to_array(s2);\n    var c1 = s1.c, c2 = s2.c;\n    if (s1.t == 4 /* ARRAY */) {\n      if (i2 <= i1) {\n        for (var i = 0; i < len; i++) c2 [i2 + i] = c1 [i1 + i];\n      } else {\n        for (var i = len - 1; i >= 0; i--) c2 [i2 + i] = c1 [i1 + i];\n      }\n    } else {\n      var l = Math.min (len, c1.length - i1);\n      for (var i = 0; i < l; i++) c2 [i2 + i] = c1.charCodeAt(i1 + i);\n      for (; i < len; i++) c2 [i2 + i] = 0;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_string\n//Requires: caml_blit_bytes, caml_bytes_of_string\nfunction caml_blit_string(a,b,c,d,e) {\n  caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);\n  return 0\n}\n\n//Provides: caml_ml_bytes_length const\nfunction caml_ml_bytes_length(s) { return s.l }\n\n//Provides: caml_string_unsafe_get const\n//If: js-string\nfunction caml_string_unsafe_get (s, i) {\n  return s.charCodeAt(i);\n}\n\n//Provides: caml_string_unsafe_set\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_unsafe_set (s, i, c) {\n  caml_failwith(\"caml_string_unsafe_set\");\n}\n\n//Provides: caml_ml_string_length const\n//If: js-string\nfunction caml_ml_string_length(s) {\n  return s.length\n}\n\n//Provides: caml_string_compare const\n//If: js-string\nfunction caml_string_compare(s1, s2) {\n  return (s1 < s2)?-1:(s1 > s2)?1:0;\n}\n\n//Provides: caml_string_equal const\n//If: js-string\nfunction caml_string_equal(s1, s2) {\n  if(s1 === s2) return 1;\n  return 0;\n}\n\n//Provides: caml_string_lessequal const\n//If: js-string\nfunction caml_string_lessequal(s1, s2) {\n  return (s1 <= s2)?1:0;\n}\n\n//Provides: caml_string_lessthan const\n//If: js-string\nfunction caml_string_lessthan(s1, s2) {\n  return (s1 < s2)?1:0;\n}\n\n//Provides: caml_string_of_bytes\n//Requires: caml_convert_string_to_bytes, caml_string_of_jsbytes\n//If: js-string\nfunction caml_string_of_bytes(s) {\n  (s.t & 6) && caml_convert_string_to_bytes(s);\n  return caml_string_of_jsbytes(s.c);\n}\n\n//Provides: caml_bytes_of_string const\n//Requires: caml_bytes_of_jsbytes, caml_jsbytes_of_string\n//If: js-string\nfunction caml_bytes_of_string(s) {\n  return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));\n}\n\n//Provides: caml_string_of_jsbytes const\n//If: js-string\nfunction caml_string_of_jsbytes(x) { return x }\n\n//Provides: caml_jsbytes_of_string const\n//If: js-string\nfunction caml_jsbytes_of_string(x) { return x }\n\n//Provides: caml_jsstring_of_string const\n//Requires: jsoo_is_ascii, caml_utf16_of_utf8\n//If: js-string\nfunction caml_jsstring_of_string(s) {\n  if(jsoo_is_ascii(s))\n    return s;\n  return caml_utf16_of_utf8(s); }\n\n//Provides: caml_string_of_jsstring const\n//Requires: jsoo_is_ascii, caml_utf8_of_utf16, caml_string_of_jsbytes\n//If: js-string\nfunction caml_string_of_jsstring (s) {\n  if (jsoo_is_ascii(s))\n    return caml_string_of_jsbytes(s)\n  else return caml_string_of_jsbytes(caml_utf8_of_utf16(s));\n}\n\n//Provides: caml_bytes_of_jsbytes const\n//Requires: MlBytes\nfunction caml_bytes_of_jsbytes(s) { return new MlBytes(0,s,s.length); }\n\n\n// The section below should be used when use-js-string=false\n\n//Provides: caml_string_unsafe_get const\n//Requires: caml_bytes_unsafe_get\n//If: !js-string\nfunction caml_string_unsafe_get (s, i) {\n  return caml_bytes_unsafe_get(s,i);\n}\n\n//Provides: caml_string_unsafe_set\n//Requires: caml_bytes_unsafe_set\n//If: !js-string\nfunction caml_string_unsafe_set (s, i, c) {\n  return caml_bytes_unsafe_set(s,i,c);\n}\n\n//Provides: caml_ml_string_length const\n//Requires: caml_ml_bytes_length\n//If: !js-string\nfunction caml_ml_string_length(s) {\n  return caml_ml_bytes_length(s)\n}\n\n//Provides: caml_string_compare\n//Requires: caml_bytes_compare\n//If: !js-string\nfunction caml_string_compare(s1, s2) {\n  return caml_bytes_compare(s1,s2)\n}\n\n//Provides: caml_string_equal\n//Requires: caml_bytes_equal\n//If: !js-string\nfunction caml_string_equal(s1, s2) {\n  return caml_bytes_equal(s1,s2)\n}\n\n//Provides: caml_string_lessequal\n//Requires: caml_bytes_lessequal\n//If: !js-string\nfunction caml_string_lessequal(s1, s2) {\n  return caml_bytes_lessequal(s1,s2)\n}\n\n//Provides: caml_string_lessthan\n//Requires: caml_bytes_lessthan\n//If: !js-string\nfunction caml_string_lessthan(s1, s2) {\n  return caml_bytes_lessthan(s1,s2)\n}\n\n//Provides: caml_string_of_bytes\n//If: !js-string\nfunction caml_string_of_bytes(s) { return s }\n\n//Provides: caml_bytes_of_string const\n//If: !js-string\nfunction caml_bytes_of_string(s) { return s }\n\n//Provides: caml_string_of_jsbytes const\n//Requires: caml_bytes_of_jsbytes\n//If: !js-string\nfunction caml_string_of_jsbytes(s) { return caml_bytes_of_jsbytes(s); }\n\n//Provides: caml_jsbytes_of_string const\n//Requires: caml_convert_string_to_bytes\n//If: !js-string\nfunction caml_jsbytes_of_string(s) {\n  (s.t & 6) && caml_convert_string_to_bytes(s);\n  return s.c }\n\n//Provides: caml_jsstring_of_string mutable (const)\n//If: !js-string\nfunction caml_jsstring_of_string(s){\n  return s.toUtf16()\n}\n\n//Provides: caml_string_of_jsstring\n//Requires: caml_bytes_of_utf16_jsstring\n//If: !js-string\nfunction caml_string_of_jsstring (s) {\n  return caml_bytes_of_utf16_jsstring(s);\n}\n\n//Provides: caml_is_ml_bytes\n//Requires: MlBytes\nfunction caml_is_ml_bytes(s) {\n  return (s instanceof MlBytes);\n}\n\n//Provides: caml_ml_bytes_content\n//Requires: MlBytes, caml_convert_string_to_bytes\nfunction caml_ml_bytes_content(s) {\n  switch (s.t & 6) {\n  default: /* PARTIAL */\n    caml_convert_string_to_bytes(s);\n  case 0: /* BYTES */\n    return s.c;\n  case 4:\n    return s.c\n  }\n}\n\n//Provides: caml_is_ml_string\n//Requires: jsoo_is_ascii\n//If: js-string\nfunction caml_is_ml_string(s) {\n  return (typeof s === \"string\" && !/[^\\x00-\\xff]/.test(s));\n}\n\n//Provides: caml_is_ml_string\n//Requires: caml_is_ml_bytes\n//If: !js-string\nfunction caml_is_ml_string(s) {\n  return caml_is_ml_bytes(s);\n}\n\n// The functions below are deprecated\n\n//Provides: caml_js_to_byte_string const\n//Requires: caml_string_of_jsbytes\nfunction caml_js_to_byte_string(s) { return caml_string_of_jsbytes(s) }\n\n//Provides: caml_new_string\n//Requires: caml_string_of_jsbytes\nfunction caml_new_string (s) { return caml_string_of_jsbytes(s) }\n\n//Provides: caml_js_from_string mutable (const)\n//Requires: caml_jsstring_of_string\nfunction caml_js_from_string(s) {\n  return caml_jsstring_of_string(s)\n}\n\n//Provides: caml_to_js_string mutable (const)\n//Requires: caml_jsstring_of_string\nfunction caml_to_js_string(s) {\n  return caml_jsstring_of_string(s)\n}\n\n//Provides: caml_js_to_string const\n//Requires: caml_string_of_jsstring\nfunction caml_js_to_string (s) {\n  return caml_string_of_jsstring(s);\n}\n\n\n//Provides: caml_array_of_string\n//Requires: caml_uint8_array_of_string\nfunction caml_array_of_string(x) { return caml_uint8_array_of_string(x) }\n\n//Provides: caml_array_of_bytes\n//Requires: caml_uint8_array_of_bytes\nfunction caml_array_of_bytes(x) { return caml_uint8_array_of_bytes(x) }\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Sys\n\n//Provides: caml_raise_sys_error (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_raise_sys_error (msg) {\n  caml_raise_with_string(caml_global_data.Sys_error, msg);\n}\n\n//Provides: caml_sys_exit\n//Requires: caml_invalid_argument\nfunction caml_sys_exit (code) {\n  if(globalThis.quit) globalThis.quit(code);\n  //nodejs\n  if(globalThis.process && globalThis.process.exit)\n    globalThis.process.exit(code);\n  caml_invalid_argument(\"Function 'exit' not implemented\");\n}\n\n//Provides: caml_is_special_exception\nfunction caml_is_special_exception(exn){\n  switch(exn[2]) {\n  case -8: // Match_failure\n  case -11: // Assert_failure\n  case -12: // Undefined_recursive_module\n    return 1;\n  default:\n    return 0;\n  }\n}\n\n//Provides: caml_format_exception\n//Requires: MlBytes, caml_is_special_exception\nfunction caml_format_exception(exn){\n  var r = \"\";\n  if(exn[0] == 0) {\n    r += exn[1][1];\n    if(exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1])) {\n\n      var bucket = exn[2];\n      var start = 1;\n    } else {\n      var start = 2\n      var bucket = exn;\n    }\n    r += \"(\";\n    for(var i = start; i < bucket.length; i ++){\n      if(i > start) r+=\", \";\n      var v = bucket[i]\n      if(typeof v == \"number\")\n        r+= v.toString();\n      else if(v instanceof MlBytes){\n        r+= '\"' + v.toString() + '\"';\n      }\n      else if(typeof v == \"string\"){\n        r+= '\"' + v.toString() + '\"';\n      }\n      else r += \"_\";\n    }\n    r += \")\"\n  } else if (exn[0] == 248){\n    r += exn[1]\n  }\n  return r\n}\n\n//Provides: caml_fatal_uncaught_exception\n//Requires: caml_named_value, caml_format_exception, caml_callback\nfunction caml_fatal_uncaught_exception(err){\n  if(err instanceof Array && (err[0] == 0 || err[0] == 248)) {\n    var handler = caml_named_value(\"Printexc.handle_uncaught_exception\");\n    if(handler) caml_callback(handler, [err,false]);\n    else {\n      var msg = caml_format_exception(err);\n      var at_exit = caml_named_value(\"Pervasives.do_at_exit\");\n      if(at_exit) caml_callback(at_exit, [0]);\n      console.error(\"Fatal error: exception \" + msg);\n      if(err.js_error) throw err.js_error;\n    }\n  }\n  else {\n    throw err\n  }\n}\n\n//Provides: caml_set_static_env\nfunction caml_set_static_env(k,v){\n  if(!globalThis.jsoo_static_env)\n    globalThis.jsoo_static_env = {}\n  globalThis.jsoo_static_env[k] = v;\n  return 0;\n}\n\n//Provides: jsoo_sys_getenv (const)\nfunction jsoo_sys_getenv(n) {\n  var process = globalThis.process;\n  //nodejs env\n  if(process\n     && process.env\n     && process.env[n] != undefined)\n    return process.env[n];\n  if(globalThis.jsoo_static_env\n     && globalThis.jsoo_static_env[n])\n    return globalThis.jsoo_static_env[n]\n}\n\n//Provides: caml_sys_getenv (const)\n//Requires: caml_raise_not_found\n//Requires: caml_string_of_jsstring\n//Requires: caml_jsstring_of_string\n//Requires: jsoo_sys_getenv\nfunction caml_sys_getenv (name) {\n  var r = jsoo_sys_getenv(caml_jsstring_of_string(name));\n  if(r === undefined)\n    caml_raise_not_found ();\n  return caml_string_of_jsstring(r)\n}\n\n//Provides: caml_sys_unsafe_getenv\n//Requires: caml_sys_getenv\nfunction caml_sys_unsafe_getenv(name){\n  return caml_sys_getenv (name);\n}\n\n//Provides: caml_argv\n//Requires: caml_string_of_jsstring\nvar caml_argv = ((function () {\n  var process = globalThis.process;\n  var main = \"a.out\";\n  var args = []\n\n  if(process\n     && process.argv\n     && process.argv.length > 1) {\n    var argv = process.argv\n    //nodejs\n    main = argv[1];\n    args = argv.slice(2);\n  }\n\n  var p = caml_string_of_jsstring(main);\n  var args2 = [0, p];\n  for(var i = 0; i < args.length; i++)\n    args2.push(caml_string_of_jsstring(args[i]));\n  return args2;\n})())\n\n//Provides: caml_executable_name\n//Requires: caml_argv\nvar caml_executable_name = caml_argv[1]\n\n//Provides: caml_sys_get_argv\n//Requires: caml_argv\nfunction caml_sys_get_argv (a) {\n  return [0, caml_argv[1], caml_argv];\n}\n\n//Provides: caml_sys_argv\n//Requires: caml_argv\nfunction caml_sys_argv (a) {\n  return caml_argv;\n}\n\n//Provides: caml_sys_modify_argv\n//Requires: caml_argv\nfunction caml_sys_modify_argv(arg){\n  caml_argv = arg;\n  return 0;\n}\n\n//Provides: caml_sys_executable_name const\n//Requires: caml_executable_name\nfunction caml_sys_executable_name(a){\n  return caml_executable_name\n}\n\n//Provides: caml_sys_system_command\n//Requires: caml_jsstring_of_string\nfunction caml_sys_system_command(cmd){\n  var cmd = caml_jsstring_of_string(cmd);\n  if (typeof require != \"undefined\"){\n    var child_process = require('child_process');\n    if(child_process && child_process.execSync)\n      try {\n        child_process.execSync(cmd,{stdio: 'inherit'});\n        return 0\n      } catch (e) {\n        return 1\n      }\n  }\n  else return 127;\n}\n\n//Provides: caml_sys_system_command\n//Requires: caml_jsstring_of_string\n//If: browser\nfunction caml_sys_system_command(cmd){\n  return 127;\n}\n\n//Provides: caml_sys_time mutable\nvar caml_initial_time = (new Date()).getTime() * 0.001;\nfunction caml_sys_time () {\n  var now = (new Date()).getTime();\n  return now * 0.001 - caml_initial_time;\n}\n\n//Provides: caml_sys_time_include_children\n//Requires: caml_sys_time\nfunction caml_sys_time_include_children(b) {\n  return caml_sys_time();\n}\n\n//Provides: caml_sys_random_seed mutable\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed () {\n  if (globalThis.crypto) {\n     if (globalThis.crypto.getRandomValues) {\n       var a = globalThis.crypto.getRandomValues(new Int32Array(4));\n       return [0, a[0], a[1], a[2], a[3]];\n     } else if (globalThis.crypto.randomBytes) {\n       var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);\n       return [0, a[0], a[1], a[2], a[3]];\n     }\n  }\n  var now = (new Date()).getTime();\n  var x = now^0xffffffff*Math.random();\n  return [0,x];\n}\n\n//Provides: caml_sys_const_big_endian const\nfunction caml_sys_const_big_endian () { return 0; }\n\n//Provides: caml_sys_const_word_size const\nfunction caml_sys_const_word_size () { return 32; }\n\n//Provides: caml_sys_const_int_size const\nfunction caml_sys_const_int_size () { return 32; }\n\n//Provides: caml_sys_const_max_wosize const\n// max_int / 4 so that the following does not overflow\n//let max_string_length = word_size / 8 * max_array_length - 1;;\nfunction caml_sys_const_max_wosize () { return (0x7FFFFFFF/4) | 0;}\n\n//Provides: caml_sys_const_ostype_unix const\n//Requires: os_type\nfunction caml_sys_const_ostype_unix () { return os_type == \"Unix\" ? 1 : 0; }\n//Provides: caml_sys_const_ostype_win32 const\n//Requires: os_type\nfunction caml_sys_const_ostype_win32 () { return os_type == \"Win32\" ? 1 : 0; }\n//Provides: caml_sys_const_ostype_cygwin const\n//Requires: os_type\nfunction caml_sys_const_ostype_cygwin () { return os_type == \"Cygwin\" ? 1 : 0; }\n\n//Provides: caml_sys_const_backend_type const\n//Requires: caml_string_of_jsbytes\nfunction caml_sys_const_backend_type () {\n  return [0, caml_string_of_jsbytes(\"js_of_ocaml\")];\n}\n\n//Provides: os_type\nvar os_type = (globalThis.process &&\n               globalThis.process.platform &&\n               globalThis.process.platform == \"win32\") ? \"Cygwin\" : \"Unix\";\n\n\n//Provides: caml_sys_get_config const\n//Requires: caml_string_of_jsbytes, os_type\nfunction caml_sys_get_config () {\n  return [0, caml_string_of_jsbytes(os_type), 32, 0];\n}\n\n//Provides: caml_sys_isatty\nfunction caml_sys_isatty(_chan) {\n  return 0;\n}\n\n//Provides: caml_runtime_variant\n//Requires: caml_string_of_jsbytes\nfunction caml_runtime_variant(_unit) {\n  return caml_string_of_jsbytes(\"\");\n}\n//Provides: caml_runtime_parameters\n//Requires: caml_string_of_jsbytes\nfunction caml_runtime_parameters(_unit) {\n  return caml_string_of_jsbytes(\"\");\n}\n\n//Provides: caml_install_signal_handler const\nfunction caml_install_signal_handler(){return 0}\n\n//Provides: caml_runtime_warnings\nvar caml_runtime_warnings = 0;\n\n//Provides: caml_ml_enable_runtime_warnings\n//Requires: caml_runtime_warnings\nfunction caml_ml_enable_runtime_warnings (bool) {\n  caml_runtime_warnings = bool;\n  return 0;\n}\n\n//Provides: caml_ml_runtime_warnings_enabled\n//Requires: caml_runtime_warnings\nfunction caml_ml_runtime_warnings_enabled (_unit) {\n  return caml_runtime_warnings;\n}\n\n\n//Provides: caml_spacetime_enabled const (const)\nfunction caml_spacetime_enabled(_unit) {\n  return 0;\n}\n\n//Provides: caml_sys_const_naked_pointers_checked const (const)\nfunction caml_sys_const_naked_pointers_checked(_unit) {\n  return 0;\n}\n\n//Provides: caml_register_channel_for_spacetime const (const)\nfunction caml_register_channel_for_spacetime(_channel) {\n  return 0;\n}\n\n//Provides: caml_spacetime_only_works_for_native_code\n//Requires: caml_failwith\nfunction caml_spacetime_only_works_for_native_code() {\n  caml_failwith(\"Spacetime profiling only works for native code\");\n}\n\n\n//Provides: caml_sys_is_regular_file\n//Requires: resolve_fs_device\nfunction caml_sys_is_regular_file(name) {\n  var root = resolve_fs_device(name);\n  return root.device.isFile(root.rest);\n}\n//Always\n//Requires: caml_fatal_uncaught_exception\nfunction caml_setup_uncaught_exception_handler() {\n  var process = globalThis.process;\n  if(process && process.on) {\n    process.on('uncaughtException', function (err, origin) {\n      caml_fatal_uncaught_exception(err);\n      process.exit (2);\n    })\n  }\n  else if(globalThis.addEventListener){\n    globalThis.addEventListener('error', function(event){\n      if(event.error){\n        caml_fatal_uncaught_exception(event.error);\n      }\n    });\n  }\n}\ncaml_setup_uncaught_exception_handler();\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\n//Provides: caml_record_backtrace_flag\n//Requires: jsoo_sys_getenv\nvar caml_record_backtrace_flag = FLAG(\"with-js-error\");\n\n(function () {\n  var r = jsoo_sys_getenv(\"OCAMLRUNPARAM\")\n  if(r !== undefined){\n    var l = r.split(\",\");\n    for(var i = 0; i < l.length; i++){\n      if(l[i] == \"b\") { caml_record_backtrace_flag = 1; break }\n      else if (l[i].startsWith(\"b=\")) {\n        caml_record_backtrace_flag = +(l[i].slice(2))}\n      else continue;\n    }\n  }\n}) ()\n\n\n//Provides: caml_ml_debug_info_status const\nfunction caml_ml_debug_info_status () { return 0; }\n//Provides: caml_backtrace_status\n//Requires: caml_record_backtrace_flag\nfunction caml_backtrace_status (_unit) { return caml_record_backtrace_flag ? 1 : 0; }\n//Provides: caml_get_exception_backtrace const\nfunction caml_get_exception_backtrace () { return 0; }\n//Provides: caml_get_exception_raw_backtrace const\nfunction caml_get_exception_raw_backtrace () { return [0]; }\n//Provides: caml_record_backtrace\n//Requires: caml_record_backtrace_flag\nfunction caml_record_backtrace (b) { caml_record_backtrace_flag = b; return 0; }\n//Provides: caml_convert_raw_backtrace const\nfunction caml_convert_raw_backtrace () { return [0]; }\n//Provides: caml_raw_backtrace_length\nfunction caml_raw_backtrace_length() { return 0; }\n//Provides: caml_raw_backtrace_next_slot\nfunction caml_raw_backtrace_next_slot() { return 0 }\n//Provides: caml_raw_backtrace_slot\n//Requires: caml_invalid_argument\nfunction caml_raw_backtrace_slot () {\n  caml_invalid_argument(\"Printexc.get_raw_backtrace_slot: index out of bounds\");\n}\n//Provides: caml_restore_raw_backtrace\nfunction caml_restore_raw_backtrace(exn, bt) { return 0 }\n//Provides: caml_get_current_callstack const\nfunction caml_get_current_callstack () { return [0]; }\n\n//Provides: caml_convert_raw_backtrace_slot\n//Requires: caml_failwith\nfunction caml_convert_raw_backtrace_slot(){\n  caml_failwith(\"caml_convert_raw_backtrace_slot\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_call_gen (const, shallow)\n//If: !effects\n//Weakdef\nfunction caml_call_gen(f, args) {\n  var n = (f.l >= 0)?f.l:(f.l = f.length);\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d == 0)\n    return f.apply(null, args);\n  else if (d < 0) {\n    var g = f.apply(null,args.slice(0,n));\n    if(typeof g !== \"function\") return g;\n    return caml_call_gen(g,args.slice(n));\n  }\n  else {\n    switch (d) {\n    case 1: {\n      var g = function (x){\n        var nargs = new Array(argsLen + 1);\n        for(var i = 0; i < argsLen; i++ ) nargs[i] = args[i];\n        nargs[argsLen] = x;\n        return f.apply(null, nargs)\n      };\n      break;\n    }\n    case 2: {\n      var g = function (x, y){\n        var nargs = new Array(argsLen + 2);\n        for(var i = 0; i < argsLen; i++ ) nargs[i] = args[i];\n        nargs[argsLen] = x;\n        nargs[argsLen + 1] = y;\n        return f.apply(null, nargs)\n      };\n      break;\n    }\n    default: {\n      var g = function (){\n        var extra_args = (arguments.length == 0)?1:arguments.length;\n        var nargs = new Array(args.length+extra_args);\n        for(var i = 0; i < args.length; i++ ) nargs[i] = args[i];\n        for(var i = 0; i < arguments.length; i++ ) nargs[args.length+i] = arguments[i];\n        return caml_call_gen(f, nargs)\n      };\n    }}\n    g.l = d;\n    return g;\n  }\n}\n\n//Provides: caml_call_gen (const, shallow)\n//If: effects\n//Weakdef\nfunction caml_call_gen(f, args) {\n  var n = (f.l >= 0)?f.l:(f.l = f.length);\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d == 0) {\n    return f.apply(null, args);\n  } else if (d < 0) {\n    var rest = args.slice(n - 1);\n    var k = args [argsLen - 1];\n    args = args.slice(0, n);\n    args[n - 1] = function (g) {\n      if (typeof g !== \"function\") return k(g);\n      var args = rest.slice();\n      args[args.length - 1] = k;\n      return caml_call_gen(g, args); };\n    return f.apply(null, args);\n  } else {\n    argsLen--;\n    var k = args [argsLen];\n    switch (d) {\n    case 1: {\n      var g = function (x, y){\n        var nargs = new Array(argsLen + 2);\n        for(var i = 0; i < argsLen; i++ ) nargs[i] = args[i];\n        nargs[argsLen] = x;\n        nargs[argsLen + 1] = y;\n        return f.apply(null, nargs)\n      };\n      break;\n    }\n    case 2: {\n      var g = function (x, y, z){\n        var nargs = new Array(argsLen + 3);\n        for(var i = 0; i < argsLen; i++ ) nargs[i] = args[i];\n        nargs[argsLen] = x;\n        nargs[argsLen + 1] = y;\n        nargs[argsLen + 2] = z;\n        return f.apply(null, nargs)\n      };\n      break;\n    }\n    default: {\n      var g = function (){\n        var extra_args = (arguments.length == 0)?1:arguments.length;\n        var nargs = new Array(argsLen + extra_args);\n        for(var i = 0; i < argsLen; i++ ) nargs[i] = args[i];\n        for(var i = 0; i < arguments.length; i++ )\n          nargs[argsLen + i] = arguments[i];\n        return caml_call_gen(f, nargs)\n      };\n    }}\n    g.l = d + 1;\n    return k(g);\n  }\n}\n\n//Provides: caml_named_values\nvar caml_named_values = {};\n\n//Provides: caml_register_named_value (const,mutable)\n//Requires: caml_named_values, caml_jsbytes_of_string\nfunction caml_register_named_value(nm,v) {\n  caml_named_values[caml_jsbytes_of_string(nm)] = v;\n  return 0;\n}\n\n//Provides: caml_named_value\n//Requires: caml_named_values\nfunction caml_named_value(nm) {\n  return caml_named_values[nm]\n}\n\n//Provides: caml_global_data\nvar caml_global_data = [0];\n\n//Provides: caml_build_symbols\n//Requires: caml_jsstring_of_string\nfunction caml_build_symbols(toc) {\n  var symb;\n  while(toc) {\n    if(caml_jsstring_of_string(toc[1][1]) == \"SYJS\") {\n      symb = toc[1][2];\n      break;\n    }\n    else toc = toc[2]\n  }\n  var r = {};\n  if(symb) {\n    for(var i = 1; i < symb.length; i++){\n      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2]\n    }\n  }\n  return r;\n}\n\n//Provides: caml_register_global (const, shallow, const)\n//Requires: caml_global_data, caml_callback, caml_build_symbols\n//Requires: caml_failwith\nfunction caml_register_global (n, v, name_opt) {\n  if (name_opt) {\n    var name = name_opt;\n    if(globalThis.toplevelReloc) {\n      n = caml_callback(globalThis.toplevelReloc, [name]);\n    }\n    else if (caml_global_data.toc) {\n      if(!caml_global_data.symbols) {\n        caml_global_data.symbols = caml_build_symbols(caml_global_data.toc)\n      }\n      var nid = caml_global_data.symbols[name]\n      if(nid >= 0)\n        n = nid\n      else {\n        caml_failwith(\"caml_register_global: cannot locate \" + name);\n      }\n    }\n  }\n  caml_global_data[n + 1] = v;\n  if(name_opt) caml_global_data[name_opt] = v;\n}\n\n//Provides: caml_get_global_data mutable\n//Requires: caml_global_data\nfunction caml_get_global_data () { return caml_global_data; }\n\n//Provides: caml_is_printable const (const)\nfunction caml_is_printable(c) { return +(c > 31 && c < 127); }\n\n//Provides: caml_maybe_print_stats\nfunction caml_maybe_print_stats(unit) { return 0 }\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib\n\n//Provides: caml_js_pure_expr const\n//Requires: caml_callback\nfunction caml_js_pure_expr (f) { return caml_callback(f, [0]); }\n\n//Provides: caml_js_set (mutable, const, mutable)\nfunction caml_js_set(o,f,v) { o[f]=v;return 0}\n//Provides: caml_js_get (mutable, const)\nfunction caml_js_get(o,f) { return o[f]; }\n//Provides: caml_js_delete (mutable, const)\nfunction caml_js_delete(o,f) { delete o[f]; return 0}\n\n//Provides: caml_js_instanceof (const, const)\nfunction caml_js_instanceof(o,c) { return (o instanceof c) ? 1 : 0; }\n\n//Provides: caml_js_typeof (const)\nfunction caml_js_typeof(o) { return typeof o; }\n\n//Provides:caml_trampoline\nfunction caml_trampoline(res) {\n  var c = 1;\n  while(res && res.joo_tramp){\n    res = res.joo_tramp.apply(null, res.joo_args);\n    c++;\n  }\n  return res;\n}\n\n//Provides:caml_trampoline_return\nfunction caml_trampoline_return(f,args) {\n  return {joo_tramp:f,joo_args:args};\n}\n\n//Provides:caml_stack_depth\n//If: effects\nvar caml_stack_depth = 0;\n\n//Provides:caml_stack_check_depth\n//If: effects\n//Requires:caml_stack_depth\nfunction caml_stack_check_depth() {\n    return --caml_stack_depth > 0;\n}\n\n//Provides: caml_callback\n//If: !effects\n//Requires:caml_call_gen\nvar caml_callback = caml_call_gen;\n\n//Provides: caml_callback\n//If: effects\n//Requires:caml_stack_depth, caml_call_gen, caml_exn_stack, caml_fiber_stack, caml_wrap_exception, caml_resume_stack, caml_fresh_oo_id, caml_named_value, caml_raise_with_arg, caml_string_of_jsbytes\n//Requires: caml_raise_constant\nfunction caml_callback(f,args) {\n  function uncaught_effect_handler(eff,k,ms) {\n    // Resumes the continuation k by raising exception Unhandled.\n    caml_resume_stack(k[1],ms);\n    var exn = caml_named_value(\"Effect.Unhandled\");\n    if(exn) caml_raise_with_arg(exn, eff);\n    else {\n      exn = [248,caml_string_of_jsbytes(\"Effect.Unhandled\"), caml_fresh_oo_id(0)];\n      caml_raise_constant(exn);\n    }\n  }\n  var saved_stack_depth = caml_stack_depth;\n  var saved_exn_stack = caml_exn_stack;\n  var saved_fiber_stack = caml_fiber_stack;\n  try {\n    caml_exn_stack = 0;\n    caml_fiber_stack =\n      {h:[0, 0, 0, uncaught_effect_handler], r:{k:0, x:0, e:0}};\n    var res = {joo_tramp: f,\n               joo_args: args.concat(function (x){return x;})};\n    do {\n      caml_stack_depth = 40;\n      try {\n        res = caml_call_gen(res.joo_tramp, res.joo_args);\n      } catch (e) {\n        /* Handle exception coming from JavaScript or from the runtime. */\n        if (!caml_exn_stack) throw e;\n        var handler = caml_exn_stack[1];\n        caml_exn_stack = caml_exn_stack[2];\n        res = {joo_tramp: handler,\n               joo_args: [caml_wrap_exception(e)]};\n      }\n    } while(res && res.joo_args)\n  } finally {\n    caml_stack_depth = saved_stack_depth;\n    caml_exn_stack = saved_exn_stack;\n    caml_fiber_stack = saved_fiber_stack;\n  }\n  return res;\n}\n\n//Provides: caml_is_js\nfunction caml_is_js() {\n  return 1;\n}\n\n//Provides: caml_jsoo_flags_use_js_string\nfunction caml_jsoo_flags_use_js_string(unit){\n  return FLAG(\"use-js-string\")\n}\n\n//Provides: caml_jsoo_flags_effects\nfunction caml_jsoo_flags_effects(unit){\n  return FLAG(\"effects\")\n}\n\n//Provides: caml_wrap_exception const (mutable)\n//Requires: caml_global_data,caml_string_of_jsstring,caml_named_value\nfunction caml_wrap_exception(e) {\n  if (FLAG(\"excwrap\")) {\n    if(e instanceof Array) return e;\n    var exn;\n    //Stack_overflow: chrome, safari\n    if(globalThis.RangeError\n       && e instanceof globalThis.RangeError\n       && e.message\n       && e.message.match(/maximum call stack/i))\n      exn = caml_global_data.Stack_overflow;\n    //Stack_overflow: firefox\n    else if(globalThis.InternalError\n       && e instanceof globalThis.InternalError\n       && e.message\n       && e.message.match(/too much recursion/i))\n      exn = caml_global_data.Stack_overflow;\n    //Wrap Error in Js.Error exception\n    else if(e instanceof globalThis.Error && caml_named_value(\"jsError\"))\n      exn = [0,caml_named_value(\"jsError\"),e];\n    else\n      //fallback: wrapped in Failure\n      exn = [0,caml_global_data.Failure,caml_string_of_jsstring (String(e))];\n    // We already have an error at hand, let's use it.\n    if (e instanceof globalThis.Error)\n      exn.js_error = e;\n    return exn;\n  } else\n    return e;\n}\n\n//Provides: caml_maybe_attach_backtrace\n//Requires: caml_exn_with_js_backtrace\n//Requires: caml_record_backtrace_flag\nfunction caml_maybe_attach_backtrace(exn, force) {\n  if(caml_record_backtrace_flag)\n    return caml_exn_with_js_backtrace(exn, force);\n  else return exn\n}\n\n// Experimental\n//Provides: caml_exn_with_js_backtrace\n//Requires: caml_global_data\nfunction caml_exn_with_js_backtrace(exn, force) {\n  //never reraise for constant exn\n  if(!exn.js_error || force || exn[0] == 248) exn.js_error = new globalThis.Error(\"Js exception containing backtrace\");\n  return exn;\n}\n\n\n//Provides: caml_js_error_option_of_exception\nfunction caml_js_error_option_of_exception(exn) {\n  if(exn.js_error) { return [0, exn.js_error]; }\n  return 0;\n}\n\n\n\n//Provides: caml_js_from_bool const (const)\nfunction caml_js_from_bool(x) { return !!x; }\n//Provides: caml_js_to_bool const (const)\nfunction caml_js_to_bool(x) { return +x; }\n//Provides: caml_js_from_float const (const)\n//Alias: caml_js_from_int32\n//Alias: caml_js_from_nativeint\nfunction caml_js_from_float(x) { return x; }\n//Provides: caml_js_to_float const (const)\nfunction caml_js_to_float(x) { return x; }\n//Provides: caml_js_to_int32 const (const)\n//Alias: caml_js_to_nativeint\nfunction caml_js_to_int32(x) { return x|0; }\n\n//Provides: caml_js_from_array mutable (shallow)\nfunction caml_js_from_array(a) {\n  return a.slice(1);\n}\n//Provides: caml_js_to_array mutable (shallow)\nfunction caml_js_to_array(a) {\n  var len = a.length;\n  var b = new Array(len+1);\n  b[0] = 0;\n  for(var i=0;i<len;i++) b[i+1] = a[i];\n  return b;\n}\n\n//Provides: caml_list_of_js_array const (mutable)\nfunction caml_list_of_js_array(a){\n  var l = 0;\n  for(var i=a.length - 1; i>=0; i--){\n    var e = a[i];\n    l = [0,e,l];\n  }\n  return l\n}\n\n//Provides: caml_list_to_js_array const (mutable)\nfunction caml_list_to_js_array(l){\n  var a = [];\n  for(; l !== 0; l = l[2]) {\n    a.push(l[1]);\n  }\n  return a;\n}\n\n//Provides: caml_js_var mutable\n//Requires: caml_jsstring_of_string\nfunction caml_js_var(x) {\n  var x = caml_jsstring_of_string(x);\n  //Checks that x has the form ident[.ident]*\n  if(!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/)){\n    console.error(\"caml_js_var: \\\"\" + x + \"\\\" is not a valid JavaScript variable. continuing ..\");\n    //console.error(\"Js.Unsafe.eval_string\")\n  }\n  return eval(x);\n}\n//Provides: caml_js_call (const, mutable, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_call(f, o, args) { return f.apply(o, caml_js_from_array(args)); }\n//Provides: caml_js_fun_call (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_fun_call(f, a) {\n  switch (a.length) {\n  case 1: return f();\n  case 2: return f (a[1]);\n  case 3: return f (a[1],a[2]);\n  case 4: return f (a[1],a[2],a[3]);\n  case 5: return f (a[1],a[2],a[3],a[4]);\n  case 6: return f (a[1],a[2],a[3],a[4],a[5]);\n  case 7: return f (a[1],a[2],a[3],a[4],a[5],a[6]);\n  case 8: return f (a[1],a[2],a[3],a[4],a[5],a[6],a[7]);\n  }\n  return f.apply(null, caml_js_from_array(a));\n}\n//Provides: caml_js_meth_call (mutable, const, shallow)\n//Requires: caml_jsstring_of_string\n//Requires: caml_js_from_array\nfunction caml_js_meth_call(o, f, args) {\n  return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));\n}\n//Provides: caml_js_new (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_new(c, a) {\n  switch (a.length) {\n  case 1: return new c;\n  case 2: return new c (a[1]);\n  case 3: return new c (a[1],a[2]);\n  case 4: return new c (a[1],a[2],a[3]);\n  case 5: return new c (a[1],a[2],a[3],a[4]);\n  case 6: return new c (a[1],a[2],a[3],a[4],a[5]);\n  case 7: return new c (a[1],a[2],a[3],a[4],a[5],a[6]);\n  case 8: return new c (a[1],a[2],a[3],a[4],a[5],a[6],a[7]);\n  }\n  function F() { return c.apply(this, caml_js_from_array(a)); }\n  F.prototype = c.prototype;\n  return new F;\n}\n//Provides: caml_ojs_new_arr (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_ojs_new_arr(c, a) {\n  switch (a.length) {\n  case 0: return new c;\n  case 1: return new c (a[0]);\n  case 2: return new c (a[0],a[1]);\n  case 3: return new c (a[0],a[1],a[2]);\n  case 4: return new c (a[0],a[1],a[2],a[3]);\n  case 5: return new c (a[0],a[1],a[2],a[3],a[4]);\n  case 6: return new c (a[0],a[1],a[2],a[3],a[4],a[5]);\n  case 7: return new c (a[0],a[1],a[2],a[3],a[4],a[5],a[6]);\n  }\n  function F() { return c.apply(this, a); }\n  F.prototype = c.prototype;\n  return new F;\n}\n//Provides: caml_js_wrap_callback const (const)\n//Requires: caml_callback\nfunction caml_js_wrap_callback(f) {\n  return function () {\n    var len = arguments.length;\n    if(len > 0){\n      var args = new Array(len);\n      for (var i = 0; i < len; i++) args[i] = arguments[i];\n    } else {\n      args = [undefined];\n    }\n    var res = caml_callback(f, args);\n    return (res instanceof Function)?caml_js_wrap_callback(res):res;\n  }\n}\n\n//Provides: caml_js_wrap_callback_arguments\n//Requires: caml_callback\nfunction caml_js_wrap_callback_arguments(f) {\n  return function() {\n    var len = arguments.length;\n    var args = new Array(len);\n    for (var i = 0; i < len; i++) args[i] = arguments[i];\n    return caml_callback(f, [args]);\n  }\n}\n//Provides: caml_js_wrap_callback_strict const\n//Requires: caml_callback\nfunction caml_js_wrap_callback_strict(arity, f) {\n  return function () {\n    var n = arguments.length;\n    var args = new Array(arity);\n    var len = Math.min(arguments.length, arity)\n    for (var i = 0; i < len; i++) args[i] = arguments[i];\n    return caml_callback(f, args);\n  };\n}\n//Provides: caml_js_wrap_callback_unsafe const (const)\n//Requires: caml_callback, caml_js_function_arity\nfunction caml_js_wrap_callback_unsafe(f) {\n  return function () {\n    var len = caml_js_function_arity(f);\n    var args = new Array(len);\n    for (var i = 0; i < len; i++) args[i] = arguments[i];\n    return caml_callback(f, args); }\n}\n//Provides: caml_js_wrap_meth_callback const (const)\n//Requires: caml_callback, caml_js_wrap_callback\nfunction caml_js_wrap_meth_callback(f) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len + 1);\n    args[0] = this;\n    for (var i = 0; i < len; i++) args[i+1] = arguments[i];\n    var res = caml_callback(f,args);\n    return (res instanceof Function)?caml_js_wrap_callback(res):res;\n  }\n}\n//Provides: caml_js_wrap_meth_callback_arguments const (const)\n//Requires: caml_callback\nfunction caml_js_wrap_meth_callback_arguments(f) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    for (var i = 0; i < len; i++) args[i] = arguments[i];\n    return caml_callback(f,[this,args]);\n  }\n}\n//Provides: caml_js_wrap_meth_callback_strict const\n//Requires: caml_callback\nfunction caml_js_wrap_meth_callback_strict(arity, f) {\n  return function () {\n    var args = new Array(arity + 1);\n    var len = Math.min(arguments.length, arity)\n    args[0] = this;\n    for (var i = 0; i < len; i++) args[i+1] = arguments[i];\n    return caml_callback(f, args);\n  };\n}\n//Provides: caml_js_wrap_meth_callback_unsafe const (const)\n//Requires: caml_callback, caml_js_function_arity\nfunction caml_js_wrap_meth_callback_unsafe(f) {\n  return function () {\n    var len = caml_js_function_arity(f) - 1;\n    var args = new Array(len + 1);\n    args[0] = this;\n    for (var i = 0; i < len; i++) args[i+1] = arguments[i];\n    return caml_callback(f, args); }\n}\n\n//Provides: caml_js_function_arity\n//If: !effects\nfunction caml_js_function_arity(f) {\n  return (f.l >= 0)?f.l:(f.l = f.length)\n}\n\n//Provides: caml_js_function_arity\n//If: effects\nfunction caml_js_function_arity(f) {\n  // Functions have an additional continuation parameter. This should\n  // not be visible when calling them from JavaScript\n  return ((f.l >= 0)?f.l:(f.l = f.length)) - 1\n}\n\n//Provides: caml_js_equals mutable (const, const)\nfunction caml_js_equals (x, y) { return +(x == y); }\n\n//Provides: caml_js_strict_equals mutable (const, const)\nfunction caml_js_strict_equals (x, y) { return +(x === y); }\n\n//Provides: caml_js_eval_string (const)\n//Requires: caml_jsstring_of_string\nfunction caml_js_eval_string (s) {return eval(caml_jsstring_of_string(s));}\n\n//Provides: caml_js_expr (const)\n//Requires: caml_jsstring_of_string\nfunction caml_js_expr(s) {\n  console.error(\"caml_js_expr: fallback to runtime evaluation\\n\");\n  return eval(caml_jsstring_of_string(s));}\n\n//Provides: caml_pure_js_expr const (const)\n//Requires: caml_jsstring_of_string\nfunction caml_pure_js_expr (s){\n  console.error(\"caml_pure_js_expr: fallback to runtime evaluation\\n\");\n  return eval(caml_jsstring_of_string(s));}\n\n//Provides: caml_js_object (object_literal)\n//Requires: caml_jsstring_of_string\nfunction caml_js_object (a) {\n  var o = {};\n  for (var i = 1; i < a.length; i++) {\n    var p = a[i];\n    o[caml_jsstring_of_string(p[1])] = p[2];\n  }\n  return o;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Raise exception\n\n//Provides: caml_raise_constant (const)\nfunction caml_raise_constant (tag) { throw tag; }\n\n//Provides: caml_raise_with_arg (const, mutable)\n//Requires: caml_maybe_attach_backtrace\nfunction caml_raise_with_arg (tag, arg) { throw caml_maybe_attach_backtrace([0, tag, arg]); }\n\n//Provides: caml_raise_with_args (const, mutable)\n//Requires: caml_maybe_attach_backtrace\nfunction caml_raise_with_args (tag, args) { throw caml_maybe_attach_backtrace([0, tag].concat(args)); }\n\n//Provides: caml_raise_with_string (const, const)\n//Requires: caml_raise_with_arg, caml_string_of_jsbytes\nfunction caml_raise_with_string (tag, msg) {\n  caml_raise_with_arg (tag, caml_string_of_jsbytes(msg));\n}\n\n//Provides: caml_failwith (const)\n//Requires: caml_raise_with_string, caml_global_data, caml_string_of_jsbytes\nfunction caml_failwith (msg) {\n  if(!caml_global_data.Failure)\n    caml_global_data.Failure=[248,caml_string_of_jsbytes(\"Failure\"),-3];\n  caml_raise_with_string(caml_global_data.Failure, msg);\n}\n\n\n//Provides: caml_invalid_argument (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_invalid_argument (msg) {\n  caml_raise_with_string(caml_global_data.Invalid_argument, msg);\n}\n\n//Provides: caml_raise_end_of_file\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_end_of_file () {\n  caml_raise_constant(caml_global_data.End_of_file);\n}\n\n//Provides: caml_raise_zero_divide\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_zero_divide () {\n  caml_raise_constant(caml_global_data.Division_by_zero);\n}\n\n//Provides: caml_raise_not_found\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_not_found () {\n  caml_raise_constant(caml_global_data.Not_found); }\n\n\n//Provides: caml_array_bound_error\n//Requires: caml_invalid_argument\nfunction caml_array_bound_error () {\n  caml_invalid_argument(\"index out of bounds\");\n}\n","/*\nTo deal with effects, the execution context is intuitively composed of\na stack of fibers. Each fiber has a current low-level continuation\n(one-argument JavaScript function), a stack of exception handlers and\na triple of handlers, which are invoked when the fiber terminates\n(either with a value or an exception) or when an effect is performed.\nThe low-level continuation of the topmost fiber (which is currently\nexecuting) is passed from function to function as an additional\nargument. Its stack of exception handlers is stored in\n[caml_exn_stack]. Exception handlers are pushed into this stack when\nentering a [try ... with ...] and popped on exit. Then, handlers and\nthe remaining fibers are stored in [caml_fiber_stack]. To install an\neffect handler, we push a new fiber into the execution context.\n\nWe have basically the following type for reified continuations (type\n[continuation] in module [Effect] of the standard library):\n\n  type ('a, 'b) continuation = ('a, 'b) stack ref\n\n  and (_, _) stack =\n      Cons : ('b -> unit) *             (* low-level continuation *)\n             (exn -> unit) list *       (* exception handlers *)\n             ('b, 'c) handler *\n             ('a, 'b) stack\n             -> ('a, 'c) stack\n    | Empty : ('a, 'a) stack\n\n  and ('a,'b) handler =   (* As in module Effect from the standard library *)\n    { retc: 'a -> 'b;\n      exnc: exn -> 'b;\n      effc: 'c.'c Effect.t -> (('c,'b) continuation -> 'b) option }\n\nContinuations are one-shot. A continuation [ref Empty] has already\nbeen resumed.\n\nA continuation is basically composed of a list of fibers, which each\nhas its low-level continuation, its stack of exception handlers and a\ntriple of handlers to deal with when the fiber terminates or an\neffect is performed. When resuming a continuation, the innermost fiber\nis resumed first.\n\nThe handlers are CPS-transformed functions: they actually take an\nadditional parameter which is the current low-level continuation.\n*/\n\n//Provides: caml_exn_stack\n//If: effects\n// This is an OCaml list of exception handlers\nvar caml_exn_stack = 0;\n\n//Provides: caml_push_trap\n//Requires: caml_exn_stack\n//If: effects\nfunction caml_push_trap(handler) {\n  caml_exn_stack=[0,handler,caml_exn_stack];\n}\n\n//Provides: caml_pop_trap\n//Requires: caml_exn_stack\n//If: effects\nfunction caml_pop_trap() {\n  if (!caml_exn_stack) return function(x){throw x;}\n  var h = caml_exn_stack[1];\n  caml_exn_stack=caml_exn_stack[2];\n  return h\n}\n\n//Provides: caml_fiber_stack\n//If: effects\n// This has the shape {h, r:{k, x, e}} where h is a triple of handlers\n// (see effect.js) and k, x and e are the saved continuation,\n// exception stack and fiber stack of the parent fiber.\nvar caml_fiber_stack;\n\n//Provides:caml_resume_stack\n//Requires: caml_named_value, caml_raise_constant, caml_exn_stack, caml_fiber_stack\n//If: effects\nfunction caml_resume_stack(stack, k) {\n  if (!stack) caml_raise_constant\n                 (caml_named_value(\"Effect.Continuation_already_resumed\"));\n  // Update the execution context with the stack of fibers in [stack] in\n  // order to resume the continuation\n  do {\n    caml_fiber_stack =\n      {h:stack[3], r:{k:k, x:caml_exn_stack, e:caml_fiber_stack}};\n    k = stack[1];\n    caml_exn_stack = stack[2];\n    stack = stack[4];\n  } while (stack)\n  return k;\n}\n\n//Provides: caml_pop_fiber\n//Requires: caml_exn_stack, caml_fiber_stack\n//If: effects\nfunction caml_pop_fiber() {\n  // Move to the parent fiber, returning the parent's low-level continuation\n  var rem = caml_fiber_stack.r;\n  caml_exn_stack = rem.x;\n  caml_fiber_stack = rem.e;\n  return rem.k;\n}\n\n//Provides: caml_perform_effect\n//Requires: caml_pop_fiber, caml_stack_check_depth, caml_trampoline_return, caml_exn_stack, caml_fiber_stack\n//If: effects\nfunction caml_perform_effect(eff, cont, k0) {\n  // Allocate a continuation if we don't already have one\n  if (!cont) cont = [245 /*continuation*/, 0];\n  // Get current effect handler\n  var handler = caml_fiber_stack.h[3];\n  // Cons the current fiber onto the continuation:\n  //   cont := Cons (k, exn_stack, handlers, !cont)\n  cont[1] = [0,k0,caml_exn_stack,caml_fiber_stack.h,cont[1]];\n  // Move to parent fiber and execute the effect handler there\n  // The handler is defined in Stdlib.Effect, so we know that the arity matches\n  var k1 = caml_pop_fiber();\n  return caml_stack_check_depth()?handler(eff,cont,k1,k1)\n         :caml_trampoline_return(handler,[eff,cont,k1,k1]);\n}\n\n//Provides: caml_alloc_stack\n//Requires: caml_pop_fiber, caml_fiber_stack, caml_call_gen, caml_stack_check_depth, caml_trampoline_return\n//If: effects\nfunction caml_alloc_stack(hv, hx, hf) {\n  function call(i, x) {\n    var f=caml_fiber_stack.h[i];\n    var args = [x, caml_pop_fiber()];\n    return caml_stack_check_depth()?caml_call_gen(f,args)\n           :caml_trampoline_return(f,args);\n  }\n  function hval(x) {\n    // Call [hv] in the parent fiber\n    return call(1, x);\n  }\n  function hexn(e) {\n    // Call [hx] in the parent fiber\n    return call(2, e);\n  }\n  return [0, hval, [0, hexn, 0], [0, hv, hx, hf], 0];\n}\n\n//Provides: caml_alloc_stack\n//If: !effects\nfunction caml_alloc_stack(hv, hx, hf) {\n  return 0;\n}\n\n//Provides: caml_continuation_use_noexc\nfunction caml_continuation_use_noexc(cont) {\n  var stack=cont[1];\n  cont[1]=0;\n  return stack;\n}\n\n//Provides: caml_continuation_use_and_update_handler_noexc\n//Requires: caml_continuation_use_noexc\nfunction caml_continuation_use_and_update_handler_noexc(cont, hval, hexn, heff) {\n  var stack = caml_continuation_use_noexc(cont);\n  stack[3] = [0, hval, hexn, heff];\n  return stack;\n}\n\n//Provides: caml_get_continuation_callstack\nfunction caml_get_continuation_callstack () { return [0]; }\n\n//Provides: caml_ml_condition_new\nfunction caml_ml_condition_new(unit){\n    return {condition:1};\n}\n\n//Provides: caml_ml_condition_wait\nfunction caml_ml_condition_wait(t,mutext){\n    return 0;\n}\n\n//Provides: caml_ml_condition_broadcast\nfunction caml_ml_condition_broadcast(t){\n    return 0;\n}\n\n//Provides: caml_ml_condition_signal\nfunction caml_ml_condition_signal(t){\n    return 0;\n}\n\n//Provides: jsoo_effect_not_supported\n//Requires: caml_failwith\n//!If: effects\nfunction jsoo_effect_not_supported(){\n  caml_failwith(\"Effect handlers are not supported\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_update_dummy\nfunction caml_update_dummy (x, y) {\n  if( y.fun ) { x.fun = y.fun; return 0; }\n  if( typeof y===\"function\" ) { x.fun = y; return 0; }\n  var i = y.length; while (i--) x[i] = y[i]; return 0;\n}\n\n//Provides: caml_alloc_dummy_infix\n//Requires: caml_call_gen\nfunction caml_alloc_dummy_infix () {\n  return function f (x) { return caml_call_gen(f.fun, [x]) }\n}\n\n//Provides: caml_obj_is_block const (const)\nfunction caml_obj_is_block (x) { return +(x instanceof Array); }\n\n\n//Provides: caml_obj_tag\n//Requires: caml_is_ml_bytes, caml_is_ml_string\nfunction caml_obj_tag (x) {\n  if ((x instanceof Array) && x[0] == (x[0] >>> 0))\n    return x[0]\n  else if (caml_is_ml_bytes(x))\n    return 252\n  else if (caml_is_ml_string(x))\n    return 252\n  else if ((x instanceof Function) || typeof x == \"function\")\n    return 247\n  else if (x && x.caml_custom)\n    return 255\n  else\n    return 1000\n}\n\n//Provides: caml_obj_set_tag (mutable, const)\nfunction caml_obj_set_tag (x, tag) { x[0] = tag; return 0; }\n//Provides: caml_obj_block const (const,const)\nfunction caml_obj_block (tag, size) {\n  var o = new Array(size+1);\n  o[0]=tag;\n  for (var i = 1; i <= size; i++) o[i] = 0;\n  return o;\n}\n\n//Provides: caml_obj_with_tag\nfunction caml_obj_with_tag(tag,x) {\n  var l = x.length;\n  var a = new Array(l);\n  a[0] = tag;\n  for(var i = 1; i < l; i++ ) a[i] = x[i];\n  return a;\n}\n\n//Provides: caml_obj_dup mutable (mutable)\nfunction caml_obj_dup (x) {\n  var l = x.length;\n  var a = new Array(l);\n  for(var i = 0; i < l; i++ ) a[i] = x[i];\n  return a;\n}\n\n//Provides: caml_obj_truncate (mutable, const)\n//Requires: caml_invalid_argument\nfunction caml_obj_truncate (x, s) {\n  if (s<=0 || s + 1 > x.length)\n    caml_invalid_argument (\"Obj.truncate\");\n  if (x.length != s + 1) x.length = s + 1;\n  return 0;\n}\n\n//Provides: caml_obj_make_forward\nfunction caml_obj_make_forward (b,v) {\n  b[0]=250;\n  b[1]=v;\n  return 0\n}\n\n//Provides: caml_obj_compare_and_swap\nfunction caml_obj_compare_and_swap(x,i,old,n){\n  if(x[i+1] == old) {\n    x[i+1] = n;\n    return 1;\n  }\n  return 0\n}\n\n//Provides: caml_obj_is_shared\nfunction caml_obj_is_shared(x){\n  return 1\n}\n\n//Provides: caml_lazy_make_forward const (mutable)\nfunction caml_lazy_make_forward (v) { return [250, v]; }\n\n///////////// CamlinternalOO\n//Provides: caml_get_public_method const\nvar caml_method_cache = [];\nfunction caml_get_public_method (obj, tag, cacheid) {\n  var meths = obj[1];\n  var ofs = caml_method_cache[cacheid];\n  if (ofs === undefined) {\n    // Make sure the array is not sparse\n    for (var i = caml_method_cache.length; i < cacheid; i++)\n      caml_method_cache[i] = 0;\n  } else if (meths[ofs] === tag) {\n    return meths[ofs - 1];\n  }\n  var li = 3, hi = meths[1] * 2 + 1, mi;\n  while (li < hi) {\n    mi = ((li+hi) >> 1) | 1;\n    if (tag < meths[mi+1]) hi = mi-2;\n    else li = mi;\n  }\n  caml_method_cache[cacheid] = li + 1;\n  /* return 0 if tag is not there */\n  return (tag == meths[li+1] ? meths[li] : 0);\n}\n\n//Provides: caml_oo_last_id\nvar caml_oo_last_id = 0;\n\n//Provides: caml_set_oo_id\n//Requires: caml_oo_last_id\nfunction caml_set_oo_id (b) {\n  b[2]=caml_oo_last_id++;\n  return b;\n}\n\n//Provides: caml_fresh_oo_id const\n//Requires: caml_oo_last_id\nfunction caml_fresh_oo_id() {\n  return caml_oo_last_id++;\n}\n\n//Provides: caml_obj_raw_field\nfunction caml_obj_raw_field(o,i) { return o[i+1] }\n\n//Provides: caml_obj_set_raw_field\nfunction caml_obj_set_raw_field(o,i,v) { return o[i+1] = v }\n\n//Provides: caml_obj_reachable_words\nfunction caml_obj_reachable_words(o) { return 0; }\n\n//Provides: caml_obj_add_offset\n//Requires: caml_failwith\nfunction caml_obj_add_offset(v,offset) {\n  caml_failwith(\"Obj.add_offset is not supported\");\n}\n\n//Provides: caml_obj_update_tag\nfunction caml_obj_update_tag(b,o,n) {\n    if(b[0]==o) { b[0] = n; return 1 }\n    return 0\n}\n\n//Provides: caml_lazy_update_to_forcing\n//Requires: caml_obj_update_tag\nfunction caml_lazy_update_to_forcing(o) {\n  if ((o instanceof Array) && o[0] == (o[0] >>> 0) &&\n      caml_obj_update_tag(o, 246, 244)) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n//Provides: caml_lazy_update_to_forward\n//Requires: caml_obj_update_tag\n  function caml_lazy_update_to_forward(o) {\n  caml_obj_update_tag(o,244,250);\n  return 0; // unit\n}\n\n\n//Provides: caml_lazy_reset_to_lazy\n//Requires: caml_obj_update_tag\nfunction caml_lazy_reset_to_lazy(o) {\n  caml_obj_update_tag(o,244,246);\n  return 0;\n}\n\n//Provides: caml_lazy_read_result\n//Requires: caml_obj_tag\nfunction caml_lazy_read_result(o) {\n  return (caml_obj_tag(o) == 250)?o[1]:o;\n}\n\n\n//Provides: caml_is_continuation_tag\n//Version: < 5\nfunction caml_is_continuation_tag(t) {\n  return 0;\n}\n\n//Provides: caml_is_continuation_tag\n//Version: >= 5\nfunction caml_is_continuation_tag(t) {\n  return (t == 245) ? 1 : 0;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Array\n\n//Provides: caml_array_sub mutable\nfunction caml_array_sub (a, i, len) {\n  var a2 = new Array(len+1);\n  a2[0]=0;\n  for(var i2 = 1, i1= i+1; i2 <= len; i2++,i1++ ){\n    a2[i2]=a[i1];\n  }\n  return a2;\n}\n\n//Provides: caml_array_append mutable\nfunction caml_array_append(a1, a2) {\n  var l1 = a1.length, l2 = a2.length;\n  var l = l1+l2-1\n  var a = new Array(l);\n  a[0] = 0;\n  var i = 1,j = 1;\n  for(;i<l1;i++) a[i]=a1[i];\n  for(;i<l;i++,j++) a[i]=a2[j];\n  return a;\n}\n\n//Provides: caml_array_concat mutable\nfunction caml_array_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_array_blit\nfunction caml_array_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for (var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];\n  } else {\n    for (var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];\n  };\n  return 0;\n}\n\n//Provides: caml_floatarray_blit\nfunction caml_floatarray_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for (var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];\n  } else {\n    for (var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];\n  };\n  return 0;\n}\n\n///////////// Pervasive\n//Provides: caml_array_set (mutable, const, mutable)\n//Requires: caml_array_bound_error\nfunction caml_array_set (array, index, newval) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  array[index+1]=newval; return 0;\n}\n\n//Provides: caml_array_get mutable (mutable, const)\n//Requires: caml_array_bound_error\nfunction caml_array_get (array, index) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  return array[index+1];\n}\n\n//Provides: caml_array_fill\nfunction caml_array_fill(array, ofs, len, v){\n  for(var i = 0; i < len; i++){\n    array[ofs+i+1] = v;\n  }\n  return 0;\n}\n\n//Provides: caml_check_bound (mutable, const)\n//Requires: caml_array_bound_error\nfunction caml_check_bound (array, index) {\n  if (index >>> 0 >= array.length - 1) caml_array_bound_error();\n  return array;\n}\n\n//Provides: caml_make_vect const (const, mutable)\n//Requires: caml_array_bound_error\nfunction caml_make_vect (len, init) {\n  if (len < 0) caml_array_bound_error();\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=0;\n  for (var i = 1; i < len; i++) b[i] = init;\n  return b;\n}\n\n//Provides: caml_make_float_vect const (const)\n//Requires: caml_array_bound_error\nfunction caml_make_float_vect(len){\n  if (len < 0) caml_array_bound_error();\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b\n}\n//Provides: caml_floatarray_create const (const)\n//Requires: caml_array_bound_error\nfunction caml_floatarray_create(len){\n  if (len < 0) caml_array_bound_error();\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: jsoo_floor_log2\nvar log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020\nfunction jsoo_floor_log2(x) {\n  if(log2_ok) return Math.floor(Math.log2(x))\n  var i = 0;\n  if (x == 0) return -Infinity;\n  if(x>=1) {while (x>=2) {x/=2; i++} }\n  else {while (x < 1) {x*=2; i--} };\n  return i;\n}\n\n//Provides: caml_int64_bits_of_float const\n//Requires: jsoo_floor_log2, caml_int64_create_lo_mi_hi\nfunction caml_int64_bits_of_float (x) {\n  if (!isFinite(x)) {\n    if (isNaN(x))\n      return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);\n    if (x > 0)\n      return caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)\n    else\n      return caml_int64_create_lo_mi_hi(0, 0, 0xfff0)\n  }\n  var sign = (x==0 && 1/x == -Infinity)?0x8000:(x>=0)?0:0x8000;\n  if (sign) x = -x;\n  // Int64.bits_of_float 1.1235582092889474E+307 = 0x7fb0000000000000L\n  // using Math.LOG2E*Math.log(x) in place of Math.log2 result in precision lost\n  var exp = jsoo_floor_log2(x) + 1023;\n  if (exp <= 0) {\n    exp = 0;\n    x /= Math.pow(2,-1026);\n  } else {\n    x /= Math.pow(2,exp-1027);\n    if (x < 16) {\n      x *= 2; exp -=1; }\n    if (exp == 0) {\n      x /= 2; }\n  }\n  var k = Math.pow(2,24);\n  var r3 = x|0;\n  x = (x - r3) * k;\n  var r2 = x|0;\n  x = (x - r2) * k;\n  var r1 = x|0;\n  r3 = (r3 &0xf) | sign | exp << 4;\n  return caml_int64_create_lo_mi_hi(r1, r2, r3);\n}\n\n//Provides: caml_int32_bits_of_float const\n//Requires: jsoo_floor_log2\nfunction caml_int32_bits_of_float (x) {\n  var float32a = new Float32Array(1);\n  float32a[0] = x;\n  var int32a = new Int32Array(float32a.buffer);\n  return int32a[0] | 0;\n}\n\n//FP literals can be written using the hexadecimal\n//notation 0x<mantissa in hex>p<exponent> from ISO C99.\n//https://github.com/dankogai/js-hexfloat/blob/master/hexfloat.js\n//Provides: caml_hexstring_of_float const\n//Requires: caml_string_of_jsstring, caml_str_repeat\nfunction caml_hexstring_of_float (x, prec, style) {\n  if (!isFinite(x)) {\n    if (isNaN(x)) return caml_string_of_jsstring(\"nan\");\n    return caml_string_of_jsstring ((x > 0)?\"infinity\":\"-infinity\");\n  }\n  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;\n  if(sign) x = -x;\n  var exp = 0;\n  if (x == 0) { }\n  else if (x < 1) {\n    while (x < 1 && exp > -1022)  { x *= 2; exp-- }\n  } else {\n    while (x >= 2) { x /= 2; exp++ }\n  }\n  var exp_sign = exp < 0 ? '' : '+';\n  var sign_str = '';\n  if (sign) sign_str = '-'\n  else {\n    switch(style){\n    case 43 /* '+' */: sign_str = '+'; break;\n    case 32 /* ' ' */: sign_str = ' '; break;\n    default: break;\n    }\n  }\n  if (prec >= 0 && prec < 13) {\n    /* If a precision is given, and is small, round mantissa accordingly */\n    var cst = Math.pow(2,prec * 4);\n    x = Math.round(x * cst) / cst;\n  }\n  var x_str = x.toString(16);\n  if(prec >= 0){\n    var idx = x_str.indexOf('.');\n    if(idx<0) {\n      x_str += '.' + caml_str_repeat(prec, '0');\n    }\n    else {\n      var size = idx+1+prec;\n      if(x_str.length < size)\n        x_str += caml_str_repeat(size - x_str.length, '0');\n      else\n        x_str = x_str.substr(0,size);\n    }\n  }\n  return caml_string_of_jsstring (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));\n}\n\n//Provides: caml_int64_float_of_bits const\nfunction caml_int64_float_of_bits (x) {\n  var lo = x.lo;\n  var mi = x.mi;\n  var hi = x.hi;\n  var exp = (hi & 0x7fff) >> 4;\n  if (exp == 2047) {\n    if ((lo|mi|(hi&0xf)) == 0)\n      return (hi & 0x8000)?(-Infinity):Infinity;\n    else\n      return NaN;\n  }\n  var k = Math.pow(2,-24);\n  var res = (lo*k+mi)*k+(hi&0xf);\n  if (exp > 0) {\n    res += 16;\n    res *= Math.pow(2,exp-1027);\n  } else\n    res *= Math.pow(2,-1026);\n  if (hi & 0x8000) res = - res;\n  return res;\n}\n\n//Provides: caml_nextafter_float const\n//Requires: caml_int64_float_of_bits, caml_int64_bits_of_float, caml_int64_add, caml_int64_sub,caml_int64_of_int32\nfunction caml_nextafter_float (x,y) {\n  if(isNaN(x) || isNaN(y)) return NaN;\n  if(x==y) return y;\n  if(x==0){\n    if(y < 0)\n      return -Math.pow(2, -1074)\n    else\n      return Math.pow(2, -1074)\n  }\n  var bits = caml_int64_bits_of_float(x);\n  var one = caml_int64_of_int32(1);\n  if ((x<y) == (x>0))\n    bits = caml_int64_add(bits, one)\n  else\n    bits = caml_int64_sub(bits, one)\n  return caml_int64_float_of_bits(bits);\n}\n\n//Provides: caml_trunc_float\nfunction caml_trunc_float(x){\n  return Math.trunc(x);\n}\n\n//Provides: caml_int32_float_of_bits const\nfunction caml_int32_float_of_bits (x) {\n  var int32a = new Int32Array(1);\n  int32a[0] = x;\n  var float32a = new Float32Array(int32a.buffer);\n  return float32a[0];\n}\n\n//Provides: caml_classify_float const\nfunction caml_classify_float (x) {\n  if (isFinite (x)) {\n    if (Math.abs(x) >= 2.2250738585072014e-308) return 0;\n    if (x != 0) return 1;\n    return 2;\n  }\n  return isNaN(x)?4:3;\n}\n//Provides: caml_modf_float const\nfunction caml_modf_float (x) {\n  if (isFinite (x)) {\n    var neg = (1/x) < 0;\n    x = Math.abs(x);\n    var i = Math.floor (x);\n    var f = x - i;\n    if (neg) { i = -i; f = -f; }\n    return [0, f, i];\n  }\n  if (isNaN (x)) return [0, NaN, NaN];\n  return [0, 1/x, x];\n}\n//Provides: caml_ldexp_float const\nfunction caml_ldexp_float (x,exp) {\n  exp |= 0;\n  if (exp > 1023) {\n    exp -= 1023;\n    x *= Math.pow(2, 1023);\n    if (exp > 1023) {  // in case x is subnormal\n      exp -= 1023;\n      x *= Math.pow(2, 1023);\n    }\n  }\n  if (exp < -1023) {\n    exp += 1023;\n    x *= Math.pow(2, -1023);\n  }\n  x *= Math.pow(2, exp);\n  return x;\n}\n//Provides: caml_frexp_float const\n//Requires: jsoo_floor_log2\nfunction caml_frexp_float (x) {\n  if ((x == 0) || !isFinite(x)) return [0, x, 0];\n  var neg = x < 0;\n  if (neg) x = - x;\n  var exp = Math.max(-1023, jsoo_floor_log2(x) + 1);\n  x *= Math.pow(2,-exp);\n  while (x < 0.5) {\n    x *= 2;\n    exp--;\n  }\n  while (x >= 1) {\n    x *= 0.5;\n    exp++;\n  }\n  if (neg) x = - x;\n  return [0, x, exp];\n}\n\n//Provides: caml_float_compare const\nfunction caml_float_compare (x, y) {\n  if (x === y) return 0;\n  if (x < y) return -1;\n  if (x > y) return 1;\n  if (x === x) return 1;\n  if (y === y) return -1;\n  return 0;\n}\n\n//Provides: caml_copysign_float const\nfunction caml_copysign_float (x, y) {\n  if (y == 0) y = 1 / y;\n  x = Math.abs(x);\n  return (y < 0)?(-x):x;\n}\n\n//Provides: caml_signbit_float const\nfunction caml_signbit_float(x) {\n  if (x == 0) x = 1 / x;\n  return (x < 0)?1:0;\n}\n\n//Provides: caml_expm1_float const\nfunction caml_expm1_float (x) { return Math.expm1(x); }\n//Provides: caml_exp2_float const\nfunction caml_exp2_float(x) { return Math.pow(2, x); }\n//Provides: caml_log1p_float const\nfunction caml_log1p_float(x) { return Math.log1p(x); }\n//Provides: caml_log2_float const\nfunction caml_log2_float(x) { return Math.log2(x); }\n//Provides: caml_hypot_float const\nfunction caml_hypot_float (x, y) { return Math.hypot(x, y); }\n//Provides: caml_log10_float const\nfunction caml_log10_float (x) { return Math.log10(x); }\n//Provides: caml_cosh_float const\nfunction caml_cosh_float (x) { return Math.cosh(x); }\n//Provides: caml_acosh_float const\nfunction caml_acosh_float (x) { return Math.acosh(x); }\n//Provides: caml_sinh_float const\nfunction caml_sinh_float (x) { return Math.sinh(x); }\n//Provides: caml_asinh_float const\nfunction caml_asinh_float (x) { return Math.asinh(x); }\n//Provides: caml_tanh_float const\nfunction caml_tanh_float (x) { return Math.tanh(x); }\n//Provides: caml_atanh_float const\nfunction caml_atanh_float (x) { return Math.atanh(x); }\n//Provides: caml_round_float const\nfunction caml_round_float (x) {\n  if (x >= 0) {\n    var y = Math.floor(x);\n    return (x - y >= 0.5)?(y + 1):y\n  } else {\n    var y = Math.ceil(x);\n    return (y - x >= 0.5)?(y - 1):y\n  }\n}\n//Provides: caml_cbrt_float const\nfunction caml_cbrt_float (x) { return Math.cbrt(x); }\n\n//Provides: caml_erf_float const\nfunction caml_erf_float(x) {\n  var a1 = 0.254829592;\n  var a2 = -0.284496736;\n  var a3 = 1.421413741;\n  var a4 = -1.453152027;\n  var a5 = 1.061405429;\n  var p = 0.3275911;\n\n  var sign = 1;\n  if (x < 0) {\n    sign = -1;\n  }\n  x = Math.abs(x);\n  var t = 1.0 / (1.0 + p * x);\n  var y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n  return sign * y;\n}\n\n//Provides: caml_erfc_float const\n//Requires: caml_erf_float\nfunction caml_erfc_float(x) {\n  return 1 - caml_erf_float(x);\n}\n\n\n//Provides: caml_fma_float const\nfunction caml_fma_float(x, y, z) {\n  var SPLIT = Math.pow(2, 27) + 1;\n  var MIN_VALUE = Math.pow(2, -1022);\n  var EPSILON = Math.pow(2, -52);\n  var C = 416;\n  var A = Math.pow(2, +C);\n  var B = Math.pow(2, -C);\n\n  function multiply (a, b) {\n    var at = SPLIT * a;\n    var ahi = at - (at - a);\n    var alo = a - ahi;\n    var bt = SPLIT * b;\n    var bhi = bt - (bt - b);\n    var blo = b - bhi;\n    var p = a * b;\n    var e = ((ahi * bhi - p) + ahi * blo + alo * bhi) + alo * blo;\n    return {\n      p: p,\n      e: e\n    };\n  };\n\n  function add (a, b) {\n    var s = a + b;\n    var v = s - a;\n    var e = (a - (s - v)) + (b - v);\n    return {\n      s: s,\n      e: e\n    };\n  };\n\n  function adjust (x, y) {\n    return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x ? x * (1 + (x < 0 ? -1 : +1) * (y < 0 ? -1 : +1) * EPSILON) : x;\n  };\n\n  if (x === 0 || x !== x || x === +1 / 0 || x === -1 / 0 ||\n      y === 0 || y !== y || y === +1 / 0 || y === -1 / 0) {\n    return x * y + z;\n  }\n  if (z === 0) {\n    return x * y;\n  }\n  if (z !== z || z === +1 / 0 || z === -1 / 0) {\n    return z;\n  }\n\n  var scale = 1;\n  while (Math.abs(x) > A) {\n    scale *= A;\n    x *= B;\n  }\n  while (Math.abs(y) > A) {\n    scale *= A;\n    y *= B;\n  }\n  if (scale === 1 / 0) {\n    return x * y * scale;\n  }\n  while (Math.abs(x) < B) {\n    scale *= B;\n    x *= A;\n  }\n  while (Math.abs(y) < B) {\n    scale *= B;\n    y *= A;\n  }\n  if (scale === 0) {\n    return z;\n  }\n\n  var xs = x;\n  var ys = y;\n  var zs = z / scale;\n\n  if (Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) {\n    return z;\n  }\n  if (Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4) {\n    zs = (z < 0 ? -1 : +1) * MIN_VALUE;\n  }\n\n  var xy = multiply(xs, ys);\n  var s = add(xy.p, zs);\n  var u = add(xy.e, s.e);\n  var i = add(s.s, u.s);\n\n  var f = i.s + adjust(i.e, u.e);\n  if (f === 0) {\n    return f;\n  }\n\n  var fs = f * scale;\n  if (Math.abs(fs) > MIN_VALUE) {\n    return fs;\n  }\n\n  // It is possible that there was extra rounding for a denormalized value.\n  return fs + adjust(f - fs / scale, i.e) * scale;\n}\n\n//Provides: caml_format_float const\n//Requires: caml_parse_format, caml_finish_formatting\nfunction caml_format_float (fmt, x) {\n  function toFixed(x,dp) {\n    if (Math.abs(x) < 1.0) {\n      return x.toFixed(dp);\n    } else {\n      var e = parseInt(x.toString().split('+')[1]);\n      if (e > 20) {\n        e -= 20;\n        x /= Math.pow(10,e);\n        x += (new Array(e+1)).join('0');\n        if(dp > 0) {\n          x = x + '.' + (new Array(dp+1)).join('0');\n        }\n        return x;\n      }\n      else return x.toFixed(dp)\n    }\n  }\n  var s, f = caml_parse_format(fmt);\n  var prec = (f.prec < 0)?6:f.prec;\n  if (x < 0 || (x == 0 && 1/x == -Infinity)) { f.sign = -1; x = -x; }\n  if (isNaN(x)) { s = \"nan\"; f.filler = ' '; }\n  else if (!isFinite(x)) { s = \"inf\"; f.filler = ' '; }\n  else\n    switch (f.conv) {\n    case 'e':\n      var s = x.toExponential(prec);\n      // exponent should be at least two digits\n      var i = s.length;\n      if (s.charAt(i - 3) == 'e')\n        s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n      break;\n    case 'f':\n      s = toFixed(x, prec); break;\n    case 'g':\n      prec = prec?prec:1;\n      s = x.toExponential(prec - 1);\n      var j = s.indexOf('e');\n      var exp = +s.slice(j + 1);\n      if (exp < -4 || x >= 1e21 || x.toFixed(0).length > prec) {\n        // remove trailing zeroes\n        var i = j - 1; while (s.charAt(i) == '0') i--;\n        if (s.charAt(i) == '.') i--;\n        s = s.slice(0, i + 1) + s.slice(j);\n        i = s.length;\n        if (s.charAt(i - 3) == 'e')\n          s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n        break;\n      } else {\n        var p = prec;\n        if (exp < 0) { p -= exp + 1; s = x.toFixed(p); }\n        else while (s = x.toFixed(p), s.length > prec + 1) p--;\n        if (p) {\n          // remove trailing zeroes\n          var i = s.length - 1; while (s.charAt(i) == '0') i--;\n          if (s.charAt(i) == '.') i--;\n          s = s.slice(0, i + 1);\n        }\n      }\n      break;\n    }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_float_of_string (const)\n//Requires: caml_failwith, caml_jsbytes_of_string\nfunction caml_float_of_string(s) {\n  var res;\n  s = caml_jsbytes_of_string(s)\n  res = +s;\n  if ((s.length > 0) && (res === res)) return res;\n  s = s.replace(/_/g,\"\");\n  res = +s;\n  if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) return res;\n  var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);\n  //          1        2             3           5\n  if(m){\n    var m3 = m[3].replace(/0+$/,'');\n    var mantissa = parseInt(m[1] + m[2] + m3, 16);\n    var exponent = (m[5]|0) - 4*m3.length;\n    res = mantissa * Math.pow(2, exponent);\n    return res;\n  }\n  if(/^\\+?inf(inity)?$/i.test(s)) return Infinity;\n  if(/^-inf(inity)?$/i.test(s)) return -Infinity;\n  caml_failwith(\"float_of_string\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_int64_offset\nvar caml_int64_offset = Math.pow(2, -24);\n\n//Provides: MlInt64\n//Requires: caml_int64_offset, caml_raise_zero_divide\nfunction MlInt64 (lo,mi,hi) {\n  this.lo = lo & 0xffffff;\n  this.mi = mi & 0xffffff;\n  this.hi = hi & 0xffff;\n}\nMlInt64.prototype.caml_custom = \"_j\"\nMlInt64.prototype.copy = function () {\n  return new MlInt64(this.lo,this.mi,this.hi);\n}\n\nMlInt64.prototype.ucompare = function (x) {\n  if (this.hi > x.hi) return 1;\n  if (this.hi < x.hi) return -1;\n  if (this.mi > x.mi) return 1;\n  if (this.mi < x.mi) return -1;\n  if (this.lo > x.lo) return 1;\n  if (this.lo < x.lo) return -1;\n  return 0;\n}\nMlInt64.prototype.compare = function (x) {\n  var hi = this.hi << 16;\n  var xhi = x.hi << 16;\n  if (hi > xhi) return 1;\n  if (hi < xhi) return -1;\n  if (this.mi > x.mi) return 1;\n  if (this.mi < x.mi) return -1;\n  if (this.lo > x.lo) return 1;\n  if (this.lo < x.lo) return -1;\n  return 0;\n}\nMlInt64.prototype.neg = function () {\n  var lo = - this.lo;\n  var mi = - this.mi + (lo >> 24);\n  var hi = - this.hi + (mi >> 24);\n  return new MlInt64(lo, mi, hi);\n}\nMlInt64.prototype.add = function (x) {\n  var lo = this.lo + x.lo;\n  var mi = this.mi + x.mi + (lo >> 24);\n  var hi = this.hi + x.hi + (mi >> 24);\n  return new MlInt64(lo, mi, hi);\n}\nMlInt64.prototype.sub = function (x) {\n  var lo = this.lo - x.lo;\n  var mi = this.mi - x.mi + (lo >> 24);\n  var hi = this.hi - x.hi + (mi >> 24);\n  return new MlInt64(lo, mi, hi);\n}\nMlInt64.prototype.mul = function (x) {\n  var lo = this.lo * x.lo;\n  var mi = ((lo * caml_int64_offset) | 0) + this.mi * x.lo + this.lo * x.mi;\n  var hi = ((mi * caml_int64_offset) | 0) + this.hi * x.lo + this.mi * x.mi + this.lo * x.hi;\n  return new MlInt64(lo, mi, hi);\n}\nMlInt64.prototype.isZero = function () {\n  return (this.lo|this.mi|this.hi) == 0;\n}\nMlInt64.prototype.isNeg = function () {\n  return (this.hi << 16) < 0;\n}\nMlInt64.prototype.and = function (x) {\n  return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);\n}\nMlInt64.prototype.or = function (x) {\n  return new MlInt64(this.lo|x.lo, this.mi|x.mi, this.hi|x.hi);\n}\nMlInt64.prototype.xor = function (x) {\n  return new MlInt64(this.lo^x.lo, this.mi^x.mi, this.hi^x.hi);\n}\nMlInt64.prototype.shift_left = function (s) {\n  s = s & 63;\n  if (s == 0) return this;\n  if (s < 24) {\n    return new MlInt64 (this.lo << s,\n                        (this.mi << s) | (this.lo >> (24 - s)),\n                        (this.hi << s) | (this.mi >> (24 - s)));\n  }\n  if (s < 48)\n    return new MlInt64 (0,\n                        this.lo << (s - 24),\n                        (this.mi << (s - 24)) | (this.lo >> (48 - s)));\n  return new MlInt64(0, 0, this.lo << (s - 48))\n}\nMlInt64.prototype.shift_right_unsigned = function (s) {\n  s = s & 63;\n  if (s == 0) return this;\n  if (s < 24)\n    return new MlInt64 (\n      (this.lo >> s) | (this.mi << (24 - s)),\n      (this.mi >> s) | (this.hi << (24 - s)),\n      (this.hi >> s));\n  if (s < 48)\n    return new MlInt64 (\n      (this.mi >> (s - 24)) | (this.hi << (48 - s)),\n      (this.hi >> (s - 24)),\n      0);\n  return new MlInt64 (this.hi >> (s - 48), 0, 0);\n}\nMlInt64.prototype.shift_right = function (s) {\n  s = s & 63;\n  if (s == 0) return this;\n  var h = (this.hi << 16) >> 16;\n  if (s < 24)\n    return new MlInt64 (\n      (this.lo >> s) | (this.mi << (24 - s)),\n      (this.mi >> s) | (h << (24 - s)),\n      ((this.hi << 16) >> s) >>> 16);\n  var sign = (this.hi << 16) >> 31;\n  if (s < 48)\n    return new MlInt64 (\n      (this.mi >> (s - 24)) | (this.hi << (48 - s)),\n      (this.hi << 16) >> (s - 24) >> 16,\n      sign & 0xffff);\n  return new MlInt64 ((this.hi << 16) >> (s - 32), sign, sign);\n}\nMlInt64.prototype.lsl1 = function () {\n  this.hi = (this.hi << 1) | (this.mi >> 23);\n  this.mi = ((this.mi << 1) | (this.lo >> 23)) & 0xffffff;\n  this.lo = (this.lo << 1) & 0xffffff;\n}\nMlInt64.prototype.lsr1 = function () {\n  this.lo = ((this.lo >>> 1) | (this.mi << 23)) & 0xffffff;\n  this.mi = ((this.mi >>> 1) | (this.hi << 23)) & 0xffffff;\n  this.hi = this.hi >>> 1;\n}\nMlInt64.prototype.udivmod = function (x) {\n  var offset = 0;\n  var modulus = this.copy();\n  var divisor = x.copy();\n  var quotient = new MlInt64(0,0,0);\n  while (modulus.ucompare(divisor) > 0) {\n    offset++;\n    divisor.lsl1();\n  }\n  while (offset >= 0) {\n    offset --;\n    quotient.lsl1();\n    if (modulus.ucompare(divisor) >= 0) {\n      quotient.lo ++;\n      modulus = modulus.sub(divisor);\n    }\n    divisor.lsr1();\n  }\n  return { quotient : quotient, modulus : modulus };\n}\nMlInt64.prototype.div = function (y)\n{\n  var x = this;\n  if (y.isZero()) caml_raise_zero_divide ();\n  var sign = x.hi ^ y.hi;\n  if (x.hi & 0x8000) x = x.neg();\n  if (y.hi & 0x8000) y = y.neg();\n  var q = x.udivmod(y).quotient;\n  if (sign & 0x8000) q = q.neg();\n  return q;\n}\nMlInt64.prototype.mod = function (y)\n{\n  var x = this;\n  if (y.isZero()) caml_raise_zero_divide ();\n  var sign = x.hi;\n  if (x.hi & 0x8000) x = x.neg();\n  if (y.hi & 0x8000) y = y.neg();\n  var r = x.udivmod(y).modulus;\n  if (sign & 0x8000) r = r.neg();\n  return r;\n}\nMlInt64.prototype.toInt = function () {\n  return this.lo | (this.mi << 24);\n}\nMlInt64.prototype.toFloat = function () {\n  return ((this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)) + this.lo;\n}\nMlInt64.prototype.toArray = function () {\n  return [this.hi >> 8,\n          this.hi & 0xff,\n          this.mi >> 16,\n          (this.mi >> 8) & 0xff,\n          this.mi & 0xff,\n          this.lo >> 16,\n          (this.lo >> 8) & 0xff,\n          this.lo & 0xff];\n}\nMlInt64.prototype.lo32 = function () {\n  return this.lo | ((this.mi & 0xff) << 24);\n}\nMlInt64.prototype.hi32 = function () {\n  return ((this.mi >>> 8) & 0xffff) | (this.hi << 16);\n}\n\n//Provides: caml_int64_ult const\nfunction caml_int64_ult(x,y) { return x.ucompare(y) < 0; }\n\n//Provides: caml_int64_compare const\nfunction caml_int64_compare(x,y, total) { return x.compare(y) }\n\n//Provides: caml_int64_neg const\nfunction caml_int64_neg (x) { return x.neg() }\n\n//Provides: caml_int64_add const\nfunction caml_int64_add (x, y) { return x.add(y) }\n\n//Provides: caml_int64_sub const\nfunction caml_int64_sub (x, y) { return x.sub(y) }\n\n//Provides: caml_int64_mul const\n//Requires: caml_int64_offset\nfunction caml_int64_mul(x,y) { return x.mul(y) }\n\n//Provides: caml_int64_is_zero const\nfunction caml_int64_is_zero(x) { return +x.isZero(); }\n\n//Provides: caml_int64_is_negative const\nfunction caml_int64_is_negative(x) { return +x.isNeg(); }\n\n//Provides: caml_int64_and const\nfunction caml_int64_and (x, y) { return x.and(y); }\n\n//Provides: caml_int64_or const\nfunction caml_int64_or (x, y) { return x.or(y); }\n\n//Provides: caml_int64_xor const\nfunction caml_int64_xor (x, y) { return x.xor(y) }\n\n//Provides: caml_int64_shift_left const\nfunction caml_int64_shift_left (x, s) { return x.shift_left(s) }\n\n//Provides: caml_int64_shift_right_unsigned const\nfunction caml_int64_shift_right_unsigned (x, s) { return x.shift_right_unsigned(s) }\n\n//Provides: caml_int64_shift_right const\nfunction caml_int64_shift_right (x, s) { return x.shift_right(s) }\n\n//Provides: caml_int64_div const\nfunction caml_int64_div (x, y) { return x.div(y) }\n\n//Provides: caml_int64_mod const\nfunction caml_int64_mod (x, y) { return x.mod(y) }\n\n//Provides: caml_int64_of_int32 const\n//Requires: MlInt64\nfunction caml_int64_of_int32 (x) {\n  return new MlInt64(x & 0xffffff, (x >> 24) & 0xffffff, (x >> 31) & 0xffff)\n}\n\n//Provides: caml_int64_to_int32 const\nfunction caml_int64_to_int32 (x) { return x.toInt() }\n\n//Provides: caml_int64_to_float const\nfunction caml_int64_to_float (x) { return x.toFloat () }\n\n//Provides: caml_int64_of_float const\n//Requires: caml_int64_offset, MlInt64\nfunction caml_int64_of_float (x) {\n  if (x < 0) x = Math.ceil(x);\n  return new MlInt64(\n    x & 0xffffff,\n    Math.floor(x * caml_int64_offset) & 0xffffff,\n    Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);\n}\n\n//Provides: caml_int64_format const\n//Requires: caml_parse_format, caml_finish_formatting\n//Requires: caml_int64_is_negative, caml_int64_neg\n//Requires: caml_int64_of_int32, caml_int64_to_int32\n//Requires: caml_int64_is_zero, caml_str_repeat\nfunction caml_int64_format (fmt, x) {\n  var f = caml_parse_format(fmt);\n  if (f.signedconv && caml_int64_is_negative(x)) {\n    f.sign = -1; x = caml_int64_neg(x);\n  }\n  var buffer = \"\";\n  var wbase = caml_int64_of_int32(f.base);\n  var cvtbl = \"0123456789abcdef\";\n  do {\n    var p = x.udivmod(wbase);\n    x = p.quotient;\n    buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;\n  } while (! caml_int64_is_zero(x));\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - buffer.length;\n    if (n > 0) buffer = caml_str_repeat (n, '0') + buffer;\n  }\n  return caml_finish_formatting(f, buffer);\n}\n\n//Provides: caml_int64_of_string\n//Requires: caml_parse_sign_and_base, caml_failwith, caml_parse_digit\n//Requires: caml_int64_of_int32, caml_int64_ult\n//Requires: caml_int64_add, caml_int64_mul, caml_int64_neg\n//Requires: caml_ml_string_length,caml_string_unsafe_get, MlInt64\nfunction caml_int64_of_string(s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var base64 = caml_int64_of_int32(base);\n  var threshold =\n      new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient;\n  var c = caml_string_unsafe_get(s, i);\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = caml_int64_of_int32(d);\n  for (;;) {\n    i++;\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    /* Detect overflow in multiplication base * res */\n    if (caml_int64_ult(threshold, res)) caml_failwith(\"int_of_string\");\n    d = caml_int64_of_int32(d);\n    res = caml_int64_add(caml_int64_mul(base64, res), d);\n    /* Detect overflow in addition (base * res) + d */\n    if (caml_int64_ult(res, d)) caml_failwith(\"int_of_string\");\n  }\n  if (i != caml_ml_string_length(s)) caml_failwith(\"int_of_string\");\n  if (base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))\n    caml_failwith(\"int_of_string\");\n  if (sign < 0) res = caml_int64_neg(res);\n  return res;\n}\n\n//Provides: caml_int64_create_lo_mi_hi const\n//Requires: MlInt64\nfunction caml_int64_create_lo_mi_hi(lo, mi, hi){\n  return new MlInt64(lo, mi, hi)\n}\n//Provides: caml_int64_create_lo_hi const\n//Requires: MlInt64\nfunction caml_int64_create_lo_hi(lo, hi){\n  return new MlInt64 (\n    lo & 0xffffff,\n    ((lo >>> 24) & 0xff) | ((hi & 0xffff) << 8),\n    (hi >>> 16) & 0xffff);\n}\n//Provides: caml_int64_lo32 const\nfunction caml_int64_lo32(v){ return v.lo32() }\n\n//Provides: caml_int64_hi32 const\nfunction caml_int64_hi32(v){ return v.hi32() }\n\n//Provides: caml_int64_of_bytes const\n//Requires: MlInt64\nfunction caml_int64_of_bytes(a) {\n  return new MlInt64(a[7] << 0 | (a[6] << 8) | (a[5] << 16),\n                     a[4] << 0 | (a[3] << 8) | (a[2] << 16),\n                     a[1] << 0 | (a[0] << 8));\n}\n//Provides: caml_int64_to_bytes const\nfunction caml_int64_to_bytes(x) { return x.toArray() }\n\n//Provides: caml_int64_hash const\nfunction caml_int64_hash(v){\n  return (v.lo32()) ^ (v.hi32())\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard, Andy Ray\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n//\n// Bigarray.\n//\n// - all bigarray types including Int64 and Complex.\n// - fortran + c layouts\n// - sub/slice/reshape\n// - retain fast path for 1d array access\n\n//Provides: caml_ba_init const\nfunction caml_ba_init() {\n  return 0;\n}\n\n//Provides: caml_ba_get_size\n//Requires: caml_invalid_argument\nfunction caml_ba_get_size(dims) {\n  var n_dims = dims.length;\n  var size = 1;\n  for (var i = 0; i < n_dims; i++) {\n    if (dims[i] < 0)\n      caml_invalid_argument(\"Bigarray.create: negative dimension\");\n    size = size * dims[i];\n  }\n  return size;\n}\n\n//Provides: caml_ba_get_size_per_element\nfunction caml_ba_get_size_per_element(kind){\n  switch(kind){\n  case 7: case 10: case 11: return 2;\n  default: return 1;\n  }\n}\n\n//Provides: caml_ba_create_buffer\n//Requires: caml_ba_get_size_per_element\n//Requires: caml_invalid_argument\nfunction caml_ba_create_buffer(kind, size){\n  var view;\n  switch(kind){\n  case 0:  view = Float32Array; break;\n  case 1:  view = Float64Array; break;\n  case 2:  view = Int8Array; break;\n  case 3:  view = Uint8Array; break;\n  case 4:  view = Int16Array; break;\n  case 5:  view = Uint16Array; break;\n  case 6:  view = Int32Array; break;\n  case 7:  view = Int32Array; break;\n  case 8:  view = Int32Array; break;\n  case 9:  view = Int32Array; break;\n  case 10: view = Float32Array; break;\n  case 11: view = Float64Array; break;\n  case 12: view = Uint8Array; break;\n  }\n  if (!view) caml_invalid_argument(\"Bigarray.create: unsupported kind\");\n  var data = new view(size * caml_ba_get_size_per_element(kind));\n  return data;\n}\n\n//Provides: caml_ba_custom_name\n//Version: < 4.11\nvar caml_ba_custom_name = \"_bigarray\"\n\n//Provides: caml_ba_custom_name\n//Version: >= 4.11\nvar caml_ba_custom_name = \"_bigarr02\"\n\n//Provides: Ml_Bigarray\n//Requires: caml_array_bound_error, caml_invalid_argument, caml_ba_custom_name\n//Requires: caml_int64_create_lo_hi, caml_int64_hi32, caml_int64_lo32\nfunction Ml_Bigarray (kind, layout, dims, buffer) {\n\n  this.kind   = kind ;\n  this.layout = layout;\n  this.dims   = dims;\n  this.data = buffer;\n}\n\nMl_Bigarray.prototype.caml_custom = caml_ba_custom_name;\n\nMl_Bigarray.prototype.offset = function (arg) {\n  var ofs = 0;\n  if(typeof arg === \"number\") arg = [arg];\n  if (! (arg instanceof Array)) caml_invalid_argument(\"bigarray.js: invalid offset\");\n  if (this.dims.length != arg.length)\n    caml_invalid_argument(\"Bigarray.get/set: bad number of dimensions\");\n  if(this.layout == 0 /* c_layout */) {\n    for (var i = 0; i < this.dims.length; i++) {\n      if (arg[i] < 0 || arg[i] >= this.dims[i])\n        caml_array_bound_error();\n      ofs = (ofs * this.dims[i]) + arg[i];\n    }\n  } else {\n    for (var i = this.dims.length - 1; i >= 0; i--) {\n      if (arg[i] < 1 || arg[i] > this.dims[i]){\n        caml_array_bound_error();\n      }\n      ofs = (ofs * this.dims[i]) + (arg[i] - 1);\n    }\n  }\n  return ofs;\n}\n\nMl_Bigarray.prototype.get = function (ofs) {\n  switch(this.kind){\n  case 7:\n    // Int64\n    var l = this.data[ofs * 2 + 0];\n    var h = this.data[ofs * 2 + 1];\n    return caml_int64_create_lo_hi(l,h);\n  case 10: case 11:\n    // Complex32, Complex64\n    var r = this.data[ofs * 2 + 0];\n    var i = this.data[ofs * 2 + 1];\n    return [254, r, i];\n  default:\n    return this.data[ofs]\n  }\n}\n\nMl_Bigarray.prototype.set = function (ofs,v) {\n  switch(this.kind){\n  case 7:\n    // Int64\n    this.data[ofs * 2 + 0] = caml_int64_lo32(v);\n    this.data[ofs * 2 + 1] = caml_int64_hi32(v);\n    break;\n  case 10: case 11:\n    // Complex32, Complex64\n    this.data[ofs * 2 + 0] = v[1];\n    this.data[ofs * 2 + 1] = v[2];\n    break;\n  default:\n    this.data[ofs] = v;\n    break;\n  }\n  return 0\n}\n\n\nMl_Bigarray.prototype.fill = function (v) {\n  switch(this.kind){\n  case 7:\n    // Int64\n    var a = caml_int64_lo32(v);\n    var b = caml_int64_hi32(v);\n    if(a == b){\n      this.data.fill(a);\n    }\n    else {\n      for(var i = 0; i<this.data.length; i++){\n        this.data[i] = (i%2 == 0) ? a : b;\n      }\n    }\n    break;\n  case 10: case 11:\n    // Complex32, Complex64\n    var im = v[1];\n    var re = v[2];\n    if(im == re){\n      this.data.fill(im);\n    }\n    else {\n      for(var i = 0; i<this.data.length; i++){\n        this.data[i] = (i%2 == 0) ? im : re;\n      }\n    }\n    break;\n  default:\n    this.data.fill(v);\n    break;\n  }\n}\n\n\nMl_Bigarray.prototype.compare = function (b, total) {\n  if (this.layout != b.layout || this.kind != b.kind) {\n    var k1 = this.kind | (this.layout << 8);\n    var k2 =    b.kind | (b.layout << 8);\n    return k2 - k1;\n  }\n  if (this.dims.length != b.dims.length) {\n    return b.dims.length - this.dims.length;\n  }\n  for (var i = 0; i < this.dims.length; i++)\n    if (this.dims[i] != b.dims[i])\n      return (this.dims[i] < b.dims[i]) ? -1 : 1;\n  switch (this.kind) {\n  case 0:\n  case 1:\n  case 10:\n  case 11:\n    // Floats\n    var x, y;\n    for (var i = 0; i < this.data.length; i++) {\n      x = this.data[i];\n      y = b.data[i];\n      if (x < y)\n        return -1;\n      if (x > y)\n        return 1;\n      if (x != y) {\n        if (!total) return NaN;\n        if (x == x) return 1;\n        if (y == y) return -1;\n      }\n    }\n    break;\n  case 7:\n    // Int64\n    for (var i = 0; i < this.data.length; i+=2) {\n      // Check highest bits first\n      if (this.data[i+1] < b.data[i+1])\n        return -1;\n      if (this.data[i+1] > b.data[i+1])\n        return 1;\n      if ((this.data[i] >>> 0) < (b.data[i] >>> 0))\n        return -1;\n      if ((this.data[i] >>> 0) > (b.data[i] >>> 0))\n        return 1;\n    }\n    break;\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n  case 6:\n  case 8:\n  case 9:\n  case 12:\n    for (var i = 0; i < this.data.length; i++) {\n      if (this.data[i] < b.data[i])\n        return -1;\n      if (this.data[i] > b.data[i])\n        return 1;\n    }\n    break;\n  }\n  return 0;\n}\n\n//Provides: Ml_Bigarray_c_1_1\n//Requires: Ml_Bigarray, caml_array_bound_error, caml_invalid_argument\nfunction Ml_Bigarray_c_1_1(kind, layout, dims, buffer) {\n  this.kind   = kind ;\n  this.layout = layout;\n  this.dims   = dims;\n  this.data   = buffer;\n}\n\nMl_Bigarray_c_1_1.prototype = new Ml_Bigarray()\nMl_Bigarray_c_1_1.prototype.offset = function (arg) {\n  if(typeof arg !== \"number\"){\n    if((arg instanceof Array) && arg.length == 1)\n      arg = arg[0];\n    else caml_invalid_argument(\"Ml_Bigarray_c_1_1.offset\");\n  }\n  if (arg < 0 || arg >= this.dims[0])\n    caml_array_bound_error();\n  return arg;\n}\n\nMl_Bigarray_c_1_1.prototype.get = function (ofs) {\n  return this.data[ofs];\n}\n\nMl_Bigarray_c_1_1.prototype.set = function (ofs,v) {\n  this.data[ofs] = v;\n  return 0\n}\n\nMl_Bigarray_c_1_1.prototype.fill = function (v) {\n  this.data.fill(v);\n  return 0\n}\n\n//Provides: caml_ba_compare\nfunction caml_ba_compare(a,b,total){\n  return a.compare(b,total)\n}\n\n//Provides: caml_ba_create_unsafe\n//Requires: Ml_Bigarray, Ml_Bigarray_c_1_1, caml_ba_get_size, caml_ba_get_size_per_element\n//Requires: caml_invalid_argument\nfunction caml_ba_create_unsafe(kind, layout, dims, data){\n  var size_per_element = caml_ba_get_size_per_element(kind);\n  if(caml_ba_get_size(dims) * size_per_element != data.length) {\n    caml_invalid_argument(\"length doesn't match dims\");\n  }\n  if(layout == 0 && // c_layout\n     dims.length == 1 && // Array1\n     size_per_element == 1) // 1-to-1 mapping\n    return new Ml_Bigarray_c_1_1(kind, layout, dims, data);\n  return new Ml_Bigarray(kind, layout, dims, data);\n\n}\n\n\n//Provides: caml_ba_create\n//Requires: caml_js_from_array\n//Requires: caml_ba_get_size, caml_ba_create_unsafe\n//Requires: caml_ba_create_buffer\nfunction caml_ba_create(kind, layout, dims_ml) {\n  var dims = caml_js_from_array(dims_ml);\n  var data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));\n  return caml_ba_create_unsafe(kind, layout, dims, data);\n}\n\n//Provides: caml_ba_change_layout\n//Requires: caml_ba_create_unsafe\nfunction caml_ba_change_layout(ba, layout) {\n  if(ba.layout == layout) return ba;\n  var new_dims = []\n  for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[ba.dims.length - i - 1];\n  return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);\n}\n\n//Provides: caml_ba_kind\nfunction caml_ba_kind(ba) {\n  return ba.kind;\n}\n\n//Provides: caml_ba_layout\nfunction caml_ba_layout(ba) {\n  return ba.layout;\n}\n\n//Provides: caml_ba_num_dims\nfunction caml_ba_num_dims(ba) {\n  return ba.dims.length;\n}\n\n//Provides: caml_ba_dim\n//Requires: caml_invalid_argument\nfunction caml_ba_dim(ba, i) {\n  if (i < 0 || i >= ba.dims.length)\n    caml_invalid_argument(\"Bigarray.dim\");\n  return ba.dims[i];\n}\n\n//Provides: caml_ba_dim_1\n//Requires: caml_ba_dim\nfunction caml_ba_dim_1(ba) {\n  return caml_ba_dim(ba, 0);\n}\n\n//Provides: caml_ba_dim_2\n//Requires: caml_ba_dim\nfunction caml_ba_dim_2(ba) {\n  return caml_ba_dim(ba, 1);\n}\n\n//Provides: caml_ba_dim_3\n//Requires: caml_ba_dim\nfunction caml_ba_dim_3(ba) {\n  return caml_ba_dim(ba, 2);\n}\n\n//Provides: caml_ba_get_generic\n//Requires: caml_js_from_array\nfunction caml_ba_get_generic(ba, i) {\n  var ofs = ba.offset(caml_js_from_array(i));\n  return ba.get(ofs);\n}\n\n//Provides: caml_ba_uint8_get16\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_get16(ba, i0) {\n  var ofs = ba.offset(i0);\n  if(ofs + 1 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs);\n  var b2 = ba.get(ofs + 1);\n  return (b1 | (b2 << 8));\n}\n\n//Provides: caml_ba_uint8_get32\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_get32(ba, i0) {\n  var ofs = ba.offset(i0);\n  if(ofs + 3 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs+0);\n  var b2 = ba.get(ofs+1);\n  var b3 = ba.get(ofs+2);\n  var b4 = ba.get(ofs+3);\n  return ( (b1 << 0)  |\n           (b2 << 8)  |\n           (b3 << 16) |\n           (b4 << 24) );\n}\n\n//Provides: caml_ba_uint8_get64\n//Requires: caml_array_bound_error, caml_int64_of_bytes\nfunction caml_ba_uint8_get64(ba, i0) {\n  var ofs = ba.offset(i0);\n  if(ofs + 7 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs+0);\n  var b2 = ba.get(ofs+1);\n  var b3 = ba.get(ofs+2);\n  var b4 = ba.get(ofs+3);\n  var b5 = ba.get(ofs+4);\n  var b6 = ba.get(ofs+5);\n  var b7 = ba.get(ofs+6);\n  var b8 = ba.get(ofs+7);\n  return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1]);\n}\n\n//Provides: caml_ba_get_1\nfunction caml_ba_get_1(ba, i0) {\n  return ba.get(ba.offset(i0));\n}\n\n//Provides: caml_ba_get_2\nfunction caml_ba_get_2(ba, i0, i1) {\n  return ba.get(ba.offset([i0,i1]));\n}\n\n//Provides: caml_ba_get_3\nfunction caml_ba_get_3(ba, i0, i1, i2) {\n  return ba.get(ba.offset([i0,i1,i2]));\n}\n\n//Provides: caml_ba_set_generic\n//Requires: caml_js_from_array\nfunction caml_ba_set_generic(ba, i, v) {\n  ba.set(ba.offset(caml_js_from_array(i)), v);\n  return 0\n}\n\n//Provides: caml_ba_uint8_set16\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_set16(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if(ofs + 1 >= ba.data.length) caml_array_bound_error();\n  ba.set(ofs+0,  v        & 0xff);\n  ba.set(ofs+1, (v >>> 8) & 0xff);\n  return 0;\n}\n\n//Provides: caml_ba_uint8_set32\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_set32(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if(ofs + 3 >= ba.data.length) caml_array_bound_error();\n  ba.set(ofs+0,  v         & 0xff);\n  ba.set(ofs+1, (v >>> 8)  & 0xff);\n  ba.set(ofs+2, (v >>> 16) & 0xff);\n  ba.set(ofs+3, (v >>> 24) & 0xff);\n  return 0;\n}\n\n//Provides: caml_ba_uint8_set64\n//Requires: caml_array_bound_error, caml_int64_to_bytes\nfunction caml_ba_uint8_set64(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if(ofs + 7 >= ba.data.length) caml_array_bound_error();\n  var v = caml_int64_to_bytes(v);\n  for(var i = 0; i < 8; i++) ba.set(ofs+i, v[7-i])\n  return 0;\n}\n\n//Provides: caml_ba_set_1\nfunction caml_ba_set_1(ba, i0, v) {\n  ba.set(ba.offset(i0), v);\n  return 0\n}\n\n//Provides: caml_ba_set_2\nfunction caml_ba_set_2(ba, i0, i1, v) {\n  ba.set(ba.offset([i0,i1]), v);\n  return 0;\n}\n\n//Provides: caml_ba_set_3\nfunction caml_ba_set_3(ba, i0, i1, i2, v) {\n  ba.set(ba.offset([i0,i1,i2]), v);\n  return 0;\n}\n\n//Provides: caml_ba_fill\nfunction caml_ba_fill(ba, v) {\n  ba.fill(v);\n  return 0;\n}\n\n//Provides: caml_ba_blit\n//Requires: caml_invalid_argument\nfunction caml_ba_blit(src, dst) {\n  if (dst.dims.length != src.dims.length)\n    caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n  for (var i = 0; i < dst.dims.length; i++)\n    if (dst.dims[i] != src.dims[i])\n      caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n  dst.data.set(src.data);\n  return 0;\n}\n\n//Provides: caml_ba_sub\n//Requires: caml_invalid_argument, caml_ba_create_unsafe, caml_ba_get_size\n//Requires: caml_ba_get_size_per_element\nfunction caml_ba_sub(ba, ofs, len) {\n  var changed_dim;\n  var mul = 1;\n  if (ba.layout == 0) {\n    for (var i = 1; i < ba.dims.length; i++)\n      mul = mul * ba.dims[i];\n    changed_dim = 0;\n  } else {\n    for (var i = 0; i < (ba.dims.length - 1); i++)\n      mul = mul * ba.dims[i];\n    changed_dim = ba.dims.length - 1;\n    ofs = ofs - 1;\n  }\n  if (ofs < 0 || len < 0 || (ofs + len) > ba.dims[changed_dim]){\n    caml_invalid_argument(\"Bigarray.sub: bad sub-array\");\n  }\n  var new_dims = [];\n  for (var i = 0; i < ba.dims.length; i++)\n    new_dims[i] = ba.dims[i];\n  new_dims[changed_dim] = len;\n  mul *= caml_ba_get_size_per_element(ba.kind);\n  var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);\n  return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);\n}\n\n//Provides: caml_ba_slice\n//Requires: caml_js_from_array, caml_ba_create_unsafe, caml_invalid_argument, caml_ba_get_size\n//Requires: caml_ba_get_size_per_element\nfunction caml_ba_slice(ba, vind) {\n  vind = caml_js_from_array(vind);\n  var num_inds = vind.length;\n  var index = [];\n  var sub_dims = [];\n  var ofs;\n\n  if (num_inds > ba.dims.length)\n    caml_invalid_argument(\"Bigarray.slice: too many indices\");\n\n  // Compute offset and check bounds\n  if (ba.layout == 0) {\n    for (var i = 0; i < num_inds; i++)\n      index[i] = vind[i];\n    for (; i < ba.dims.length; i++)\n      index[i] = 0;\n    sub_dims = ba.dims.slice(num_inds);\n  } else {\n    for (var i = 0; i < num_inds; i++)\n      index[ba.dims.length - num_inds + i] = vind[i];\n    for (var i = 0; i < ba.dims.length - num_inds; i++)\n      index[i] = 1;\n    sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);\n  }\n  ofs = ba.offset(index);\n  var size = caml_ba_get_size(sub_dims);\n  var size_per_element = caml_ba_get_size_per_element(ba.kind);\n  var new_data = ba.data.subarray(ofs * size_per_element, (ofs + size) * size_per_element);\n  return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);\n}\n\n//Provides: caml_ba_reshape\n//Requires: caml_js_from_array, caml_invalid_argument, caml_ba_create_unsafe, caml_ba_get_size\nfunction caml_ba_reshape(ba, vind) {\n  vind = caml_js_from_array(vind);\n  var new_dim = [];\n  var num_dims = vind.length;\n\n  if (num_dims < 0 || num_dims > 16){\n    caml_invalid_argument(\"Bigarray.reshape: bad number of dimensions\");\n  }\n  var num_elts = 1;\n  for (var i = 0; i < num_dims; i++) {\n    new_dim[i] = vind[i];\n    if (new_dim[i] < 0)\n      caml_invalid_argument(\"Bigarray.reshape: negative dimension\");\n    num_elts = num_elts * new_dim[i];\n  }\n\n  var size = caml_ba_get_size(ba.dims);\n  // Check that sizes agree\n  if (num_elts != size)\n    caml_invalid_argument(\"Bigarray.reshape: size mismatch\");\n  return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);\n}\n\n//Provides: caml_ba_serialize\n//Requires: caml_int64_bits_of_float, caml_int64_to_bytes\n//Requires: caml_int32_bits_of_float\nfunction caml_ba_serialize(writer, ba, sz) {\n  writer.write(32, ba.dims.length);\n  writer.write(32, (ba.kind | (ba.layout << 8)));\n  if(ba.caml_custom == \"_bigarr02\")\n    for(var i = 0; i < ba.dims.length; i++) {\n      if(ba.dims[i] < 0xffff)\n        writer.write(16, ba.dims[i]);\n      else {\n        writer.write(16, 0xffff);\n        writer.write(32, 0);\n        writer.write(32, ba.dims[i]);\n      }\n    }\n  else\n    for(var i = 0; i < ba.dims.length; i++) writer.write(32,ba.dims[i])\n  switch(ba.kind){\n  case 2:  //Int8Array\n  case 3:  //Uint8Array\n  case 12: //Uint8Array\n    for(var i = 0; i < ba.data.length; i++){\n      writer.write(8, ba.data[i]);\n    }\n    break;\n  case 4:  // Int16Array\n  case 5:  // Uint16Array\n    for(var i = 0; i < ba.data.length; i++){\n      writer.write(16, ba.data[i]);\n    }\n    break;\n  case 6:  // Int32Array (int32)\n    for(var i = 0; i < ba.data.length; i++){\n      writer.write(32, ba.data[i]);\n    }\n    break;\n  case 8:  // Int32Array (int)\n  case 9:  // Int32Array (nativeint)\n    writer.write(8,0);\n    for(var i = 0; i < ba.data.length; i++){\n      writer.write(32, ba.data[i]);\n    }\n    break;\n  case 7:  // Int32Array (int64)\n    for(var i = 0; i < ba.data.length / 2; i++){\n      var b = caml_int64_to_bytes(ba.get(i));\n      for (var j = 0; j < 8; j++) writer.write (8, b[j]);\n    }\n    break;\n  case 1:  // Float64Array\n    for(var i = 0; i < ba.data.length; i++){\n      var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));\n      for (var j = 0; j < 8; j++) writer.write (8, b[j]);\n    }\n    break;\n  case 0:  // Float32Array\n    for(var i = 0; i < ba.data.length; i++){\n      var b = caml_int32_bits_of_float(ba.get(i));\n      writer.write(32, b);\n    }\n    break;\n  case 10: // Float32Array (complex32)\n    for(var i = 0; i < ba.data.length / 2; i++){\n      var j = ba.get(i);\n      writer.write(32, caml_int32_bits_of_float(j[1]));\n      writer.write(32, caml_int32_bits_of_float(j[2]));\n    }\n    break;\n  case 11: // Float64Array (complex64)\n    for(var i = 0; i < ba.data.length / 2; i++){\n      var complex = ba.get(i);\n      var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));\n      for (var j = 0; j < 8; j++) writer.write (8, b[j]);\n      var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));\n      for (var j = 0; j < 8; j++) writer.write (8, b[j]);\n    }\n    break;\n  }\n  sz[0] = (4 + ba.dims.length) * 4;\n  sz[1] = (4 + ba.dims.length) * 8;\n}\n\n//Provides: caml_ba_deserialize\n//Requires: caml_ba_create_unsafe, caml_failwith\n//Requires: caml_ba_get_size\n//Requires: caml_int64_of_bytes, caml_int64_float_of_bits\n//Requires: caml_int32_float_of_bits\n//Requires: caml_ba_create_buffer\nfunction caml_ba_deserialize(reader, sz, name){\n  var num_dims = reader.read32s();\n  if (num_dims < 0 || num_dims > 16)\n    caml_failwith(\"input_value: wrong number of bigarray dimensions\");\n  var tag = reader.read32s();\n  var kind = tag & 0xff\n  var layout = (tag >> 8) & 1;\n  var dims = []\n  if(name == \"_bigarr02\")\n    for (var i = 0; i < num_dims; i++) {\n      var size_dim = reader.read16u();\n      if(size_dim == 0xffff){\n        var size_dim_hi = reader.read32u();\n        var size_dim_lo = reader.read32u();\n        if(size_dim_hi != 0)\n          caml_failwith(\"input_value: bigarray dimension overflow in 32bit\");\n        size_dim = size_dim_lo;\n      }\n      dims.push(size_dim);\n    }\n  else\n    for (var i = 0; i < num_dims; i++) dims.push(reader.read32u());\n  var size = caml_ba_get_size(dims);\n  var data = caml_ba_create_buffer(kind, size);\n  var ba = caml_ba_create_unsafe(kind, layout, dims, data);\n  switch(kind){\n  case 2:  //Int8Array\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read8s();\n    }\n    break;\n  case 3:  //Uint8Array\n  case 12: //Uint8Array\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read8u();\n    }\n    break;\n  case 4:  // Int16Array\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read16s();\n    }\n    break;\n  case 5:  // Uint16Array\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read16u();\n    }\n    break;\n  case 6:  // Int32Array (int32)\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read32s();\n    }\n    break;\n  case 8:  // Int32Array (int)\n  case 9:  // Int32Array (nativeint)\n    var sixty = reader.read8u();\n    if(sixty) caml_failwith(\"input_value: cannot read bigarray with 64-bit OCaml ints\");\n    for(var i = 0; i < size; i++){\n      data[i] = reader.read32s();\n    }\n    break;\n  case 7: // (int64)\n    var t = new Array(8);;\n    for(var i = 0; i < size; i++){\n      for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n      var int64 = caml_int64_of_bytes(t);\n      ba.set(i,int64);\n    }\n    break;\n  case 1:  // Float64Array\n    var t = new Array(8);;\n    for(var i = 0; i < size; i++){\n      for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n      var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n      ba.set(i,f);\n    }\n    break;\n  case 0:  // Float32Array\n    for(var i = 0; i < size; i++){\n      var f = caml_int32_float_of_bits(reader.read32s());\n      ba.set(i,f);\n    }\n    break;\n  case 10: // Float32Array (complex32)\n    for(var i = 0; i < size; i++){\n      var re = caml_int32_float_of_bits(reader.read32s());\n      var im = caml_int32_float_of_bits(reader.read32s());\n      ba.set(i,[254,re,im]);\n    }\n    break;\n  case 11: // Float64Array (complex64)\n    var t = new Array(8);;\n    for(var i = 0; i < size; i++){\n      for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n      var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n      for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n      var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n      ba.set(i,[254,re,im]);\n    }\n    break\n  }\n  sz[0] = (4 + num_dims) * 4;\n  return caml_ba_create_unsafe(kind, layout, dims, data);\n}\n\n//Deprecated\n//Provides: caml_ba_create_from\n//Requires: caml_ba_create_unsafe, caml_invalid_argument, caml_ba_get_size_per_element\nfunction caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){\n  if(data2 || caml_ba_get_size_per_element(kind) == 2){\n    caml_invalid_argument(\"caml_ba_create_from: use return caml_ba_create_unsafe\");\n  }\n  return caml_ba_create_unsafe(kind, layout, dims, data1);\n}\n\n//Provides: caml_ba_hash const\n//Requires: caml_ba_get_size, caml_hash_mix_int, caml_hash_mix_float\nfunction caml_ba_hash(ba){\n  var num_elts = caml_ba_get_size(ba.dims);\n  var h = 0;\n  switch(ba.kind){\n  case 2:  //Int8Array\n  case 3:  //Uint8Array\n  case 12: //Uint8Array\n    if(num_elts > 256) num_elts = 256;\n    var w = 0, i =0;\n    for(i = 0; i + 4 <= ba.data.length; i+=4){\n      w = ba.data[i+0] | (ba.data[i+1] << 8) | (ba.data[i+2] << 16) | (ba.data[i+3] << 24);\n      h = caml_hash_mix_int(h,w);\n    }\n    w = 0;\n    switch (num_elts & 3) {\n    case 3: w  = ba.data[i+2] << 16;    /* fallthrough */\n    case 2: w |= ba.data[i+1] << 8;     /* fallthrough */\n    case 1: w |= ba.data[i+0];\n      h = caml_hash_mix_int(h, w);\n    }\n    break;\n  case 4:  // Int16Array\n  case 5:  // Uint16Array\n    if(num_elts > 128) num_elts = 128;\n    var w = 0, i =0;\n    for(i = 0; i + 2 <= ba.data.length; i+=2){\n      w = ba.data[i+0] | (ba.data[i+1] << 16);\n      h = caml_hash_mix_int(h,w);\n    }\n    if ((num_elts & 1) != 0)\n      h = caml_hash_mix_int(h, ba.data[i]);\n    break;\n  case 6:  // Int32Array (int32)\n    if (num_elts > 64) num_elts = 64;\n    for (var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);\n    break;\n  case 8:  // Int32Array (int)\n  case 9:  // Int32Array (nativeint)\n    if (num_elts > 64) num_elts = 64;\n    for (var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);\n    break;\n  case 7:  // Int32Array (int64)\n    if (num_elts > 32) num_elts = 32;\n    num_elts *= 2\n    for (var i = 0; i < num_elts; i++) {\n      h = caml_hash_mix_int(h, ba.data[i]);\n    }\n    break;\n  case 10: // Float32Array (complex32)\n    num_elts *=2; /* fallthrough */\n  case 0:  // Float32Array\n    if (num_elts > 64) num_elts = 64;\n    for (var i = 0; i < num_elts; i++) h = caml_hash_mix_float(h, ba.data[i]);\n    break;\n  case 11: // Float64Array (complex64)\n    num_elts *=2; /* fallthrough */\n  case 1:  // Float64Array\n    if (num_elts > 32) num_elts = 32;\n    for (var i = 0; i < num_elts; i++) h = caml_hash_mix_float(h, ba.data[i]);\n    break;\n  }\n  return h;\n}\n\n//Provides: caml_ba_to_typed_array mutable\nfunction caml_ba_to_typed_array(ba){\n  return ba.data;\n}\n\n//Provides: caml_ba_kind_of_typed_array mutable\n//Requires: caml_invalid_argument\nfunction caml_ba_kind_of_typed_array(ta){\n  var kind;\n  if      (ta instanceof Float32Array) kind = 0;\n  else if (ta instanceof Float64Array) kind = 1;\n  else if (ta instanceof Int8Array) kind = 2;\n  else if (ta instanceof Uint8Array) kind = 3;\n  else if (ta instanceof Uint8ClampedArray) kind = 3;\n  else if (ta instanceof Int16Array) kind = 4;\n  else if (ta instanceof Uint16Array) kind = 5;\n  else if (ta instanceof Int32Array) kind = 6;\n  else if (ta instanceof Uint32Array) kind = 6;\n  else caml_invalid_argument(\"caml_ba_kind_of_typed_array: unsupported kind\");\n  return kind;\n}\n\n//Provides: caml_ba_from_typed_array mutable\n//Requires: caml_ba_kind_of_typed_array\n//Requires: caml_ba_create_unsafe\nfunction caml_ba_from_typed_array(ta){\n  var kind = caml_ba_kind_of_typed_array(ta);\n  var ta =\n      /* Needed to avoid unsigned setters overflowing\n         the range of OCaml [int32] values. */\n      ta instanceof Uint32Array ?\n      new Int32Array(ta.buffer ,ta.byteOffset, ta.length) : ta;\n  return caml_ba_create_unsafe(kind, 0, [ta.length], ta);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_format_int const (const, const)\n//Requires: caml_parse_format, caml_finish_formatting, caml_str_repeat\n//Requires: caml_string_of_jsbytes, caml_jsbytes_of_string\nfunction caml_format_int(fmt, i) {\n  if (caml_jsbytes_of_string(fmt) == \"%d\") return caml_string_of_jsbytes(\"\"+i);\n  var f = caml_parse_format(fmt);\n  if (i < 0) { if (f.signedconv) { f.sign = -1; i = -i; } else i >>>= 0; }\n  var s = i.toString(f.base);\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - s.length;\n    if (n > 0) s = caml_str_repeat (n, '0') + s;\n  }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_parse_sign_and_base\n//Requires: caml_string_unsafe_get, caml_ml_string_length\nfunction caml_parse_sign_and_base (s) {\n  var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;\n  if (len > 0) {\n    switch (caml_string_unsafe_get(s,i)) {\n    case 45: i++; sign = -1; break;\n    case 43: i++; sign = 1; break;\n    }\n  }\n  if (i + 1 < len && caml_string_unsafe_get(s, i) == 48)\n    switch (caml_string_unsafe_get(s, i + 1)) {\n    case 120: case 88: base = 16; i += 2; break;\n    case 111: case 79: base =  8; i += 2; break;\n    case  98: case 66: base =  2; i += 2; break;\n    case 117: case 85: i += 2; break;\n    }\n  return [i, sign, base];\n}\n\n//Provides: caml_parse_digit\nfunction caml_parse_digit(c) {\n  if (c >= 48 && c <= 57)  return c - 48;\n  if (c >= 65 && c <= 90)  return c - 55;\n  if (c >= 97 && c <= 122) return c - 87;\n  return -1;\n}\n\n//Provides: caml_int_of_string (const)\n//Requires: caml_ml_string_length, caml_string_unsafe_get\n//Requires: caml_parse_sign_and_base, caml_parse_digit, caml_failwith\nfunction caml_int_of_string (s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var len = caml_ml_string_length(s);\n  var threshold = -1 >>> 0;\n  var c = (i < len)?caml_string_unsafe_get(s, i):0;\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = d;\n  for (i++;i<len;i++) {\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    res = base * res + d;\n    if (res > threshold) caml_failwith(\"int_of_string\");\n  }\n  if (i != len) caml_failwith(\"int_of_string\");\n  // For base different from 10, we expect an unsigned representation,\n  // hence any value of 'res' (less than 'threshold') is acceptable.\n  // But we have to convert the result back to a signed integer.\n  res = sign * res;\n  if ((base == 10) && ((res | 0) != res))\n    /* Signed representation expected, allow -2^(nbits-1) to 2^(nbits-1) - 1 */\n    caml_failwith(\"int_of_string\");\n  return res | 0;\n}\n\n//Provides: caml_mul const\nfunction caml_mul(a,b){\n  return Math.imul(a,b);\n}\n\n//Provides: caml_div\n//Requires: caml_raise_zero_divide\nfunction caml_div(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return (x/y)|0;\n}\n\n//Provides: caml_mod\n//Requires: caml_raise_zero_divide\nfunction caml_mod(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return x%y;\n}\n\n//Provides: caml_bswap16\nfunction caml_bswap16(x) {\n  return ((((x & 0x00FF) << 8) |\n           ((x & 0xFF00) >> 8)));\n}\n//Provides: caml_int32_bswap\nfunction caml_int32_bswap(x) {\n  return (((x & 0x000000FF) << 24) |\n          ((x & 0x0000FF00) << 8) |\n          ((x & 0x00FF0000) >>> 8) |\n          ((x & 0xFF000000) >>> 24));\n}\n//Provides: caml_int64_bswap\n//Requires: caml_int64_to_bytes, caml_int64_of_bytes\nfunction caml_int64_bswap(x) {\n  var y = caml_int64_to_bytes(x);\n  return caml_int64_of_bytes([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Hashtbl\n\n\n//Provides: caml_hash_univ_param mutable\n//Requires: caml_is_ml_string, caml_is_ml_bytes\n//Requires: caml_ml_bytes_content\n//Requires: caml_int64_to_bytes, caml_int64_bits_of_float, caml_custom_ops\n//Requires: caml_ml_bytes_length, caml_jsbytes_of_string\n//Version: < 4.12\nfunction caml_hash_univ_param (count, limit, obj) {\n  var hash_accu = 0;\n  function hash_aux (obj) {\n    limit --;\n    if (count < 0 || limit < 0) return;\n    if (obj instanceof Array && obj[0] === (obj[0]|0)) {\n      switch (obj[0]) {\n      case 248:\n        // Object\n        count --;\n        hash_accu = (hash_accu * 65599 + obj[2]) | 0;\n        break;\n      case 250:\n        // Forward\n        limit++; hash_aux(obj); break;\n      default:\n        count --;\n        hash_accu = (hash_accu * 19 + obj[0]) | 0;\n        for (var i = obj.length - 1; i > 0; i--) hash_aux (obj[i]);\n      }\n    } else if (caml_is_ml_bytes(obj)) {\n      count --;\n      var content = caml_ml_bytes_content(obj);\n      if(typeof content === \"string\") {\n        for (var b = content, l = b.length, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + b.charCodeAt(i)) | 0;\n      } else { /* ARRAY */\n        for (var a = content, l = a.length, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + a[i]) | 0;\n      }\n    } else if (caml_is_ml_string(obj)) {\n      var jsbytes = caml_jsbytes_of_string(obj);\n      for (var b = jsbytes, l = jsbytes.length, i = 0; i < l; i++)\n        hash_accu = (hash_accu * 19 + b.charCodeAt(i)) | 0;\n    } else if (typeof obj === \"string\") {\n      for (var b = obj, l = obj.length, i = 0; i < l; i++)\n        hash_accu = (hash_accu * 19 + b.charCodeAt(i)) | 0;\n    } else if (obj === (obj|0)) {\n      // Integer\n      count --;\n      hash_accu = (hash_accu * 65599 + obj) | 0;\n    } else if (obj === +obj) {\n      // Float\n      count--;\n      var p = caml_int64_to_bytes (caml_int64_bits_of_float (obj));\n      for (var i = 7; i >= 0; i--) hash_accu = (hash_accu * 19 + p[i]) | 0;\n    } else if(obj && obj.caml_custom) {\n      if(caml_custom_ops[obj.caml_custom] && caml_custom_ops[obj.caml_custom].hash) {\n        var h = caml_custom_ops[obj.caml_custom].hash(obj) | 0;\n        hash_accu = (hash_accu * 65599 + h) | 0;\n      }\n    }\n  }\n  hash_aux (obj);\n  return hash_accu & 0x3FFFFFFF;\n}\n\n//function ROTL32(x,n) { return ((x << n) | (x >>> (32-n))); }\n//Provides: caml_hash_mix_int\n//Requires: caml_mul\nfunction caml_hash_mix_int(h,d) {\n  d = caml_mul(d, 0xcc9e2d51|0);\n  d = ((d << 15) | (d >>> (32-15))); // ROTL32(d, 15);\n  d = caml_mul(d, 0x1b873593);\n  h ^= d;\n  h = ((h << 13) | (h >>> (32-13)));   //ROTL32(h, 13);\n  return (((h + (h << 2))|0) + (0xe6546b64|0))|0;\n}\n\n//Provides: caml_hash_mix_final\n//Requires: caml_mul\nfunction caml_hash_mix_final(h) {\n  h ^= h >>> 16;\n  h = caml_mul (h, 0x85ebca6b|0);\n  h ^= h >>> 13;\n  h = caml_mul (h, 0xc2b2ae35|0);\n  h ^= h >>> 16;\n  return h;\n}\n\n//Provides: caml_hash_mix_float\n//Requires: caml_int64_bits_of_float, caml_hash_mix_int64\nfunction caml_hash_mix_float (h, v0) {\n  return caml_hash_mix_int64(h, caml_int64_bits_of_float (v0));\n}\n//Provides: caml_hash_mix_int64\n//Requires: caml_hash_mix_int\n//Requires: caml_int64_lo32, caml_int64_hi32\nfunction caml_hash_mix_int64 (h, v) {\n  h = caml_hash_mix_int(h, caml_int64_lo32(v));\n  h = caml_hash_mix_int(h, caml_int64_hi32(v));\n  return h;\n}\n\n//Provides: caml_hash_mix_jsbytes\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_jsbytes(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s.charCodeAt(i)\n      | (s.charCodeAt(i+1) << 8)\n      | (s.charCodeAt(i+2) << 16)\n      | (s.charCodeAt(i+3) << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s.charCodeAt(i+2) << 16;\n  case 2: w |= s.charCodeAt(i+1) << 8;\n  case 1:\n    w |= s.charCodeAt(i);\n    h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_bytes_arr\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_bytes_arr(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s[i]\n      | (s[i+1] << 8)\n      | (s[i+2] << 16)\n      | (s[i+3] << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s[i+2] << 16;\n  case 2: w |= s[i+1] << 8;\n  case 1: w |= s[i];\n    h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_bytes\n//Requires: caml_ml_bytes_content\n//Requires: caml_hash_mix_jsbytes\n//Requires: caml_hash_mix_bytes_arr\nfunction caml_hash_mix_bytes(h, v) {\n  var content = caml_ml_bytes_content(v);\n  if(typeof content === \"string\")\n    return caml_hash_mix_jsbytes(h, content)\n  else /* ARRAY */\n    return caml_hash_mix_bytes_arr(h, content);\n}\n\n//Provides: caml_hash_mix_string\n//Requires: caml_hash_mix_jsbytes, caml_jsbytes_of_string\nfunction caml_hash_mix_string(h, v) {\n  return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));\n}\n\n\n//Provides: caml_hash mutable\n//Requires: caml_is_ml_string, caml_is_ml_bytes\n//Requires: caml_hash_mix_int, caml_hash_mix_final\n//Requires: caml_hash_mix_float, caml_hash_mix_string, caml_hash_mix_bytes, caml_custom_ops\n//Requires: caml_hash_mix_jsbytes\n//Requires: caml_is_continuation_tag\nfunction caml_hash (count, limit, seed, obj) {\n  var queue, rd, wr, sz, num, h, v, i, len;\n  sz = limit;\n  if (sz < 0 || sz > 256) sz = 256;\n  num = count;\n  h = seed;\n  queue = [obj]; rd = 0; wr = 1;\n  while (rd < wr && num > 0) {\n    v = queue[rd++];\n    if (v && v.caml_custom){\n      if(caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash) {\n        var hh = caml_custom_ops[v.caml_custom].hash(v);\n        h = caml_hash_mix_int (h, hh);\n        num --;\n      }\n    }\n    else if (v instanceof Array && v[0] === (v[0]|0)) {\n      switch (v[0]) {\n      case 248:\n        // Object\n        h = caml_hash_mix_int(h, v[2]);\n        num--;\n        break;\n      case 250:\n        // Forward\n        queue[--rd] = v[1];\n        break;\n      default:\n        if(caml_is_continuation_tag(v[0])) {\n          /* All continuations hash to the same value,\n             since we have no idea how to distinguish them. */\n          break;\n        }\n        var tag = ((v.length - 1) << 10) | v[0];\n        h = caml_hash_mix_int(h, tag);\n        for (i = 1, len = v.length; i < len; i++) {\n          if (wr >= sz) break;\n          queue[wr++] = v[i];\n        }\n        break;\n      }\n    } else if (caml_is_ml_bytes(v)) {\n      h = caml_hash_mix_bytes(h,v)\n      num--;\n    } else if (caml_is_ml_string(v)) {\n      h = caml_hash_mix_string(h,v)\n      num--;\n    } else if (typeof v === \"string\") {\n      h = caml_hash_mix_jsbytes(h,v)\n      num--;\n    } else if (v === (v|0)) {\n      // Integer\n      h = caml_hash_mix_int(h, v+v+1);\n      num--;\n    } else if (typeof v === \"number\") {\n      // Float\n      h = caml_hash_mix_float(h,v);\n      num--;\n    }\n  }\n  h = caml_hash_mix_final(h);\n  return h & 0x3FFFFFFF;\n}\n\n//Provides: caml_string_hash\n//Requires: caml_hash_mix_final, caml_hash_mix_string\nfunction caml_string_hash(h, v){\n  var h = caml_hash_mix_string(h,v);\n  var h = caml_hash_mix_final(h);\n  return h & 0x3FFFFFFF;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_marshal_constants\nvar caml_marshal_constants = {\n  PREFIX_SMALL_BLOCK:         0x80,\n  PREFIX_SMALL_INT:           0x40,\n  PREFIX_SMALL_STRING:        0x20,\n  CODE_INT8:                  0x00,\n  CODE_INT16:                 0x01,\n  CODE_INT32:                 0x02,\n  CODE_INT64:                 0x03,\n  CODE_SHARED8:               0x04,\n  CODE_SHARED16:              0x05,\n  CODE_SHARED32:              0x06,\n  CODE_BLOCK32:               0x08,\n  CODE_BLOCK64:               0x13,\n  CODE_STRING8:               0x09,\n  CODE_STRING32:              0x0A,\n  CODE_DOUBLE_BIG:            0x0B,\n  CODE_DOUBLE_LITTLE:         0x0C,\n  CODE_DOUBLE_ARRAY8_BIG:     0x0D,\n  CODE_DOUBLE_ARRAY8_LITTLE:  0x0E,\n  CODE_DOUBLE_ARRAY32_BIG:    0x0F,\n  CODE_DOUBLE_ARRAY32_LITTLE: 0x07,\n  CODE_CODEPOINTER:           0x10,\n  CODE_INFIXPOINTER:          0x11,\n  CODE_CUSTOM:                0x12,\n  CODE_CUSTOM_LEN:            0x18,\n  CODE_CUSTOM_FIXED:          0x19\n}\n\n\n//Provides: UInt8ArrayReader\n//Requires: caml_string_of_array, caml_jsbytes_of_string\nfunction UInt8ArrayReader (s, i) { this.s = s; this.i = i; }\nUInt8ArrayReader.prototype = {\n  read8u:function () { return this.s[this.i++]; },\n  read8s:function () { return this.s[this.i++] << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s[i] << 8) | s[i + 1]\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s[i] << 24 >> 16) | s[i + 1];\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return ((s[i] << 24) | (s[i+1] << 16) |\n            (s[i+2] << 8) | s[i+3]) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (s[i] << 24) | (s[i+1] << 16) |\n      (s[i+2] << 8) | s[i+3];\n  },\n  readstr:function (len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_string_of_array(this.s.subarray(i, i + len));\n  },\n  readuint8array:function (len) {\n    var i = this.i;\n    this.i = i + len;\n    return this.s.subarray(i, i + len);\n  }\n}\n\n\n//Provides: MlStringReader\n//Requires: caml_string_of_jsbytes, caml_jsbytes_of_string\nfunction MlStringReader (s, i) { this.s = caml_jsbytes_of_string(s); this.i = i; }\nMlStringReader.prototype = {\n  read8u:function () { return this.s.charCodeAt(this.i++); },\n  read8s:function () { return this.s.charCodeAt(this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 8) | s.charCodeAt(i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 24 >> 16) | s.charCodeAt(i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return ((s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n            (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3)) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n      (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_string_of_jsbytes(this.s.substring(i, i + len));\n  },\n  readuint8array:function (len) {\n    var b = new Uint8Array(len);\n    var s = this.s;\n    var i = this.i;\n    for(var j = 0; j < len; j++) {\n      b[j] = s.charCodeAt(i + j);\n    }\n    this.i = i + len;\n    return b;\n  }\n}\n\n//Provides: BigStringReader\n//Requires: caml_string_of_array, caml_ba_get_1\nfunction BigStringReader (bs, i) { this.s = bs; this.i = i; }\nBigStringReader.prototype = {\n  read8u:function () { return caml_ba_get_1(this.s,this.i++); },\n  read8s:function () { return caml_ba_get_1(this.s,this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 8) | caml_ba_get_1(s,i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 24 >> 16) | caml_ba_get_1(s,i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return ((caml_ba_get_1(s,i)   << 24) | (caml_ba_get_1(s,i+1) << 16) |\n            (caml_ba_get_1(s,i+2) << 8)  | caml_ba_get_1(s,i+3)         ) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (caml_ba_get_1(s,i)   << 24) | (caml_ba_get_1(s,i+1) << 16) |\n      (caml_ba_get_1(s,i+2) << 8)  | caml_ba_get_1(s,i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    var arr = new Array(len)\n    for(var j = 0; j < len; j++){\n      arr[j] = caml_ba_get_1(this.s, i+j);\n    }\n    this.i = i + len;\n    return caml_string_of_array(arr);\n  },\n  readuint8array:function (len) {\n    var i = this.i;\n    var offset = this.offset(i);\n    this.i = i + len;\n    return this.s.data.subarray(offset, offset + len);\n  }\n}\n\n\n\n//Provides: caml_float_of_bytes\n//Requires: caml_int64_float_of_bits, caml_int64_of_bytes\nfunction caml_float_of_bytes (a) {\n  return caml_int64_float_of_bits (caml_int64_of_bytes (a));\n}\n\n//Provides: caml_input_value_from_string mutable\n//Requires: MlStringReader, caml_input_value_from_reader\nfunction caml_input_value_from_string(s,ofs) {\n  var reader = new MlStringReader (s, typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n//Provides: caml_input_value_from_bytes mutable\n//Requires: MlStringReader, caml_input_value_from_reader, caml_string_of_bytes\nfunction caml_input_value_from_bytes(s,ofs) {\n  var reader = new MlStringReader (caml_string_of_bytes(s), typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n//Provides: caml_int64_unmarshal\n//Requires: caml_int64_of_bytes\nfunction caml_int64_unmarshal(reader, size){\n  var t = new Array(8);;\n  for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n  size[0] = 8;\n  return caml_int64_of_bytes (t);\n}\n\n//Provides: caml_int64_marshal\n//Requires: caml_int64_to_bytes\nfunction caml_int64_marshal(writer, v, sizes) {\n  var b = caml_int64_to_bytes (v);\n  for (var i = 0; i < 8; i++) writer.write (8, b[i]);\n  sizes[0] = 8; sizes[1] = 8;\n}\n\n//Provides: caml_int32_unmarshal\nfunction caml_int32_unmarshal(reader, size){\n  size[0] = 4;\n  return reader.read32s ();\n}\n\n//Provides: caml_nativeint_unmarshal\n//Requires: caml_failwith\nfunction caml_nativeint_unmarshal(reader, size){\n  switch (reader.read8u ()) {\n  case 1:\n    size[0] = 4;\n    return reader.read32s ();\n  case 2:\n    caml_failwith(\"input_value: native integer value too large\");\n  default: caml_failwith(\"input_value: ill-formed native integer\");\n  }\n}\n\n//Provides: caml_custom_ops\n//Requires: caml_int64_unmarshal, caml_int64_marshal, caml_int64_compare, caml_int64_hash\n//Requires: caml_int32_unmarshal, caml_nativeint_unmarshal\n//Requires: caml_ba_serialize, caml_ba_deserialize, caml_ba_compare, caml_ba_hash\nvar caml_custom_ops =\n    {\"_j\": {\n      deserialize : caml_int64_unmarshal,\n      serialize  : caml_int64_marshal,\n      fixed_length : 8,\n      compare : caml_int64_compare,\n      hash : caml_int64_hash\n    },\n     \"_i\": {\n       deserialize : caml_int32_unmarshal,\n       fixed_length : 4,\n     },\n     \"_n\": {\n       deserialize : caml_nativeint_unmarshal,\n       fixed_length : 4,\n     },\n     \"_bigarray\":{\n       deserialize : (function (reader, sz) {return caml_ba_deserialize (reader,sz,\"_bigarray\")}),\n       serialize : caml_ba_serialize,\n       compare : caml_ba_compare,\n       hash: caml_ba_hash,\n     },\n     \"_bigarr02\":{\n       deserialize : (function (reader, sz) {return caml_ba_deserialize (reader,sz,\"_bigarr02\")}),\n       serialize : caml_ba_serialize,\n       compare : caml_ba_compare,\n       hash: caml_ba_hash,\n     }\n    }\n\n//Provides: caml_input_value_from_reader mutable\n//Requires: caml_failwith\n//Requires: caml_float_of_bytes, caml_custom_ops\n//Requires: UInt8ArrayReader\n//Requires: caml_decompress_input\nfunction caml_input_value_from_reader(reader, ofs) {\n  function readvlq(overflow) {\n    var c = reader.read8u();\n    var n = c & 0x7F;\n    while ((c & 0x80) != 0) {\n      c = reader.read8u();\n      var n7 = n << 7;\n      if (n != n7 >> 7) overflow[0] = true;\n      n = n7 | (c & 0x7F);\n    }\n    return n;\n  }\n  var magic = reader.read32u ()\n  switch(magic){\n  case 0x8495A6BE: /* Intext_magic_number_small */\n    var header_len = 20;\n    var compressed = 0;\n    var data_len = reader.read32u ();\n    var uncompressed_data_len = data_len;\n    var num_objects = reader.read32u ();\n    var _size_32 = reader.read32u ();\n    var _size_64 = reader.read32u ();\n    break\n  case 0x8495A6BD: /* Intext_magic_number_compressed */\n    var header_len = reader.read8u() & 0x3F;\n    var compressed = 1;\n    var overflow = [false];\n    var data_len = readvlq(overflow);\n    var uncompressed_data_len = readvlq(overflow);\n    var num_objects = readvlq(overflow);\n    var _size_32 = readvlq (overflow);\n    var _size_64 = readvlq (overflow);\n    if(overflow[0]){\n        caml_failwith(\"caml_input_value_from_reader: object too large to be read back on this platform\");\n    }\n    break\n  case 0x8495A6BF: /* Intext_magic_number_big */\n    caml_failwith(\"caml_input_value_from_reader: object too large to be read back on a 32-bit platform\");\n    break\n  default:\n    caml_failwith(\"caml_input_value_from_reader: bad object\");\n    break;\n  }\n  var stack = [];\n  var intern_obj_table = (num_objects > 0)?[]:null;\n  var obj_counter = 0;\n  function intern_rec (reader) {\n    var code = reader.read8u ();\n    if (code >= 0x40 /*cst.PREFIX_SMALL_INT*/) {\n      if (code >= 0x80 /*cst.PREFIX_SMALL_BLOCK*/) {\n        var tag = code & 0xF;\n        var size = (code >> 4) & 0x7;\n        var v = [tag];\n        if (size == 0) return v;\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        stack.push(v, size);\n        return v;\n      } else\n        return (code & 0x3F);\n    } else {\n      if (code >= 0x20/*cst.PREFIX_SMALL_STRING */) {\n        var len = code & 0x1F;\n        var v = reader.readstr (len);\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        return v;\n      } else {\n        switch(code) {\n        case 0x00: //cst.CODE_INT8:\n          return reader.read8s ();\n        case 0x01: //cst.CODE_INT16:\n          return reader.read16s ();\n        case 0x02: //cst.CODE_INT32:\n          return reader.read32s ();\n        case 0x03: //cst.CODE_INT64:\n          caml_failwith(\"input_value: integer too large\");\n          break;\n        case 0x04: //cst.CODE_SHARED8:\n          var offset = reader.read8u ();\n          if(compressed == 0) offset = obj_counter - offset;\n          return intern_obj_table[offset];\n        case 0x05: //cst.CODE_SHARED16:\n          var offset = reader.read16u ();\n          if(compressed == 0) offset = obj_counter - offset;\n          return intern_obj_table[offset];\n        case 0x06: //cst.CODE_SHARED32:\n          var offset = reader.read32u ();\n          if(compressed == 0) offset = obj_counter - offset;\n          return intern_obj_table[offset];\n        case 0x08: //cst.CODE_BLOCK32:\n          var header = reader.read32u ();\n          var tag = header & 0xFF;\n          var size = header >> 10;\n          var v = [tag];\n          if (size == 0) return v;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          stack.push(v, size);\n          return v;\n        case 0x13: //cst.CODE_BLOCK64:\n          caml_failwith (\"input_value: data block too large\");\n          break;\n        case 0x09: //cst.CODE_STRING8:\n          var len = reader.read8u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0A: //cst.CODE_STRING32:\n          var len = reader.read32u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0C: //cst.CODE_DOUBLE_LITTLE:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[7 - i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0B: //cst.CODE_DOUBLE_BIG:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0E: //cst.CODE_DOUBLE_ARRAY8_LITTLE:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0D: //cst.CODE_DOUBLE_ARRAY8_BIG:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x07: //cst.CODE_DOUBLE_ARRAY32_LITTLE:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0F: //cst.CODE_DOUBLE_ARRAY32_BIG:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x10: //cst.CODE_CODEPOINTER:\n        case 0x11: //cst.CODE_INFIXPOINTER:\n          caml_failwith (\"input_value: code pointer\");\n          break;\n        case 0x12: //cst.CODE_CUSTOM:\n        case 0x18: //cst.CODE_CUSTOM_LEN:\n        case 0x19: //cst.CODE_CUSTOM_FIXED:\n          var c, s = \"\";\n          while ((c = reader.read8u ()) != 0) s += String.fromCharCode (c);\n          var ops = caml_custom_ops[s];\n          var expected_size;\n          if(!ops)\n            caml_failwith(\"input_value: unknown custom block identifier\");\n          switch(code){\n          case 0x12: // cst.CODE_CUSTOM (deprecated)\n            break;\n          case 0x19: // cst.CODE_CUSTOM_FIXED\n            if(!ops.fixed_length)\n              caml_failwith(\"input_value: expected a fixed-size custom block\");\n            expected_size = ops.fixed_length;\n            break;\n          case 0x18: // cst.CODE_CUSTOM_LEN\n            expected_size = reader.read32u ();\n            // Skip size64\n            reader.read32s(); reader.read32s();\n            break;\n          }\n          var old_pos = reader.i;\n          var size = [0];\n          var v = ops.deserialize(reader, size);\n          if(expected_size != undefined){\n            if(expected_size != size[0])\n              caml_failwith(\"input_value: incorrect length of serialized custom block\");\n          }\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        default:\n          caml_failwith (\"input_value: ill-formed message\");\n        }\n      }\n    }\n  }\n  if(compressed) {\n    if(caml_decompress_input) {\n      var data = reader.readuint8array(data_len);\n      var res = new Uint8Array(uncompressed_data_len);\n      var res = caml_decompress_input(data, res);\n      var reader = new UInt8ArrayReader(res, 0);\n    } else {\n      caml_failwith(\"input_value: compressed object, cannot decompress\");\n    }\n  }\n  var res = intern_rec (reader);\n  while (stack.length > 0) {\n    var size = stack.pop();\n    var v = stack.pop();\n    var d = v.length;\n    if (d < size) stack.push(v, size);\n    v[d] = intern_rec (reader);\n  }\n  if (typeof ofs!=\"number\") ofs[0] = reader.i;\n  return res;\n}\n\n//Provides: caml_marshal_header_size\n//Version: < 5.1.0\nvar caml_marshal_header_size = 20\n\n//Provides: caml_marshal_header_size\n//Version: >= 5.1.0\nvar caml_marshal_header_size = 16\n\n\n\n//Provides: caml_marshal_data_size mutable\n//Requires: caml_failwith, caml_bytes_unsafe_get\n//Requires: caml_uint8_array_of_bytes\n//Requires: UInt8ArrayReader\n//Requires: caml_marshal_header_size\nfunction caml_marshal_data_size (s, ofs) {\n  var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);\n  function readvlq(overflow) {\n    var c = r.read8u();\n    var n = c & 0x7F;\n    while ((c & 0x80) != 0) {\n      c = r.read8u();\n      var n7 = n << 7;\n      if (n != n7 >> 7) overflow[0] = true;\n      n = n7 | (c & 0x7F);\n    }\n    return n;\n  }\n\n  switch(r.read32u()){\n  case 0x8495A6BE: /* Intext_magic_number_small */\n    var header_len = 20;\n    var data_len = r.read32u();\n    break;\n  case 0x8495A6BD: /* Intext_magic_number_compressed */\n    var header_len = r.read8u() & 0x3F;\n    var overflow = [false];\n    var data_len = readvlq(overflow);\n    if(overflow[0]){\n      caml_failwith(\"Marshal.data_size: object too large to be read back on this platform\");\n    }\n    break\n  case 0x8495A6BF: /* Intext_magic_number_big */\n  default:\n    caml_failwith(\"Marshal.data_size: bad object\");\n    break\n  }\n  return header_len - caml_marshal_header_size + data_len;\n}\n\n//Provides: MlObjectTable\nvar MlObjectTable;\nif (typeof globalThis.Map === 'undefined') {\n  MlObjectTable = function() {\n    /* polyfill (using linear search) */\n    function NaiveLookup(objs) { this.objs = objs; }\n    NaiveLookup.prototype.get = function(v) {\n      for (var i = 0; i < this.objs.length; i++) {\n        if (this.objs[i] === v) return i;\n      }\n    };\n    NaiveLookup.prototype.set = function() {\n      // Do nothing here. [MlObjectTable.store] will push to [this.objs] directly.\n    };\n\n    return function MlObjectTable() {\n      this.objs = []; this.lookup = new NaiveLookup(this.objs);\n    };\n  }();\n}\nelse {\n  MlObjectTable = function MlObjectTable() {\n    this.objs = []; this.lookup = new globalThis.Map();\n  };\n}\n\nMlObjectTable.prototype.store = function(v) {\n  this.lookup.set(v, this.objs.length);\n  this.objs.push(v);\n}\n\nMlObjectTable.prototype.recall = function(v) {\n  var i = this.lookup.get(v);\n  return (i === undefined)\n    ? undefined : this.objs.length - i;   /* index is relative */\n}\n\n//Provides: caml_output_val\n//Requires: caml_int64_to_bytes, caml_failwith\n//Requires: caml_int64_bits_of_float\n//Requires: caml_is_ml_bytes, caml_ml_bytes_length, caml_bytes_unsafe_get\n//Requires: caml_is_ml_string, caml_ml_string_length, caml_string_unsafe_get\n//Requires: MlObjectTable, caml_list_to_js_array, caml_custom_ops\n//Requires: caml_invalid_argument,caml_string_of_jsbytes, caml_is_continuation_tag\nvar caml_output_val = function (){\n  function Writer () { this.chunk = []; }\n  Writer.prototype = {\n    chunk_idx:20, block_len:0, obj_counter:0, size_32:0, size_64:0,\n    write:function (size, value) {\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    write_at:function (pos, size, value) {\n      var pos = pos;\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[pos++] = (value >> i) & 0xFF;\n    },\n    write_code:function (size, code, value) {\n      this.chunk[this.chunk_idx++] = code;\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    write_shared:function (offset) {\n      if (offset < (1 << 8)) this.write_code(8, 0x04 /*cst.CODE_SHARED8*/, offset);\n      else if (offset < (1 << 16)) this.write_code(16, 0x05 /*cst.CODE_SHARED16*/, offset);\n      else this.write_code(32, 0x06 /*cst.CODE_SHARED32*/, offset);\n    },\n    pos:function () { return this.chunk_idx },\n    finalize:function () {\n      this.block_len = this.chunk_idx - 20;\n      this.chunk_idx = 0;\n      this.write (32, 0x8495A6BE);\n      this.write (32, this.block_len);\n      this.write (32, this.obj_counter);\n      this.write (32, this.size_32);\n      this.write (32, this.size_64);\n      return this.chunk;\n    }\n  }\n  return function (v, flags) {\n    flags = caml_list_to_js_array(flags);\n\n    var no_sharing = (flags.indexOf(0 /*Marshal.No_sharing*/) !== -1),\n        closures =  (flags.indexOf(1 /*Marshal.Closures*/) !== -1);\n    /* Marshal.Compat_32 is redundant since integers are 32-bit anyway */\n\n    if (closures)\n      console.warn(\"in caml_output_val: flag Marshal.Closures is not supported.\");\n\n    var writer = new Writer ();\n    var stack = [];\n    var intern_obj_table = no_sharing ? null : new MlObjectTable();\n\n    function memo(v) {\n      if (no_sharing) return false;\n      var existing_offset = intern_obj_table.recall(v);\n      if (existing_offset) { writer.write_shared(existing_offset); return true; }\n      else { intern_obj_table.store(v); return false; }\n    }\n\n    function extern_rec (v) {\n      if (v.caml_custom) {\n        if (memo(v)) return;\n        var name = v.caml_custom;\n        var ops = caml_custom_ops[name];\n        var sz_32_64 = [0,0];\n        if(!ops.serialize)\n          caml_invalid_argument(\"output_value: abstract value (Custom)\");\n        if(ops.fixed_length == undefined){\n          writer.write (8, 0x18 /*cst.CODE_CUSTOM_LEN*/);\n          for (var i = 0; i < name.length; i++)\n            writer.write (8, name.charCodeAt(i));\n          writer.write(8, 0);\n          var header_pos = writer.pos ();\n          for(var i = 0; i < 12; i++) {\n            writer.write(8, 0);\n          }\n          ops.serialize(writer, v, sz_32_64);\n          writer.write_at(header_pos, 32, sz_32_64[0]);\n          writer.write_at(header_pos + 4, 32, 0); // zero\n          writer.write_at(header_pos + 8, 32, sz_32_64[1]);\n        } else {\n          writer.write (8, 0x19 /*cst.CODE_CUSTOM_FIXED*/);\n          for (var i = 0; i < name.length; i++)\n            writer.write (8, name.charCodeAt(i));\n          writer.write(8, 0);\n          var old_pos = writer.pos();\n          ops.serialize(writer, v, sz_32_64);\n          if (ops.fixed_length != writer.pos() - old_pos)\n            caml_failwith(\"output_value: incorrect fixed sizes specified by \" + name);\n        }\n        writer.size_32 += 2 + ((sz_32_64[0] + 3) >> 2);\n        writer.size_64 += 2 + ((sz_32_64[1] + 7) >> 3);\n      }\n      else if (v instanceof Array && v[0] === (v[0]|0)) {\n        if (v[0] == 251) {\n          caml_failwith(\"output_value: abstract value (Abstract)\");\n        }\n        if (caml_is_continuation_tag(v[0]))\n          caml_invalid_argument(\"output_value: continuation value\");\n        if (v.length > 1 && memo(v)) return;\n        if (v[0] < 16 && v.length - 1 < 8)\n          writer.write (8, 0x80 /*cst.PREFIX_SMALL_BLOCK*/ + v[0] + ((v.length - 1)<<4));\n        else\n          writer.write_code(32, 0x08 /*cst.CODE_BLOCK32*/, ((v.length-1) << 10) | v[0]);\n        writer.size_32 += v.length;\n        writer.size_64 += v.length;\n        if (v.length > 1) stack.push (v, 1);\n      } else if (caml_is_ml_bytes(v)) {\n        if(!(caml_is_ml_bytes(caml_string_of_jsbytes(\"\")))) {\n          caml_failwith(\"output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]\");\n        }\n        if (memo(v)) return;\n        var len = caml_ml_bytes_length(v);\n        if (len < 0x20)\n          writer.write (8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code (8, 0x09/*cst.CODE_STRING8*/, len);\n        else\n          writer.write_code (32, 0x0A /*cst.CODE_STRING32*/, len);\n        for (var i = 0;i < len;i++)\n          writer.write (8, caml_bytes_unsafe_get(v,i));\n        writer.size_32 += 1 + (((len + 4) / 4)|0);\n        writer.size_64 += 1 + (((len + 8) / 8)|0);\n      } else if (caml_is_ml_string(v)) {\n        if (memo(v)) return;\n        var len = caml_ml_string_length(v);\n        if (len < 0x20)\n          writer.write (8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code (8, 0x09/*cst.CODE_STRING8*/, len);\n        else\n          writer.write_code (32, 0x0A /*cst.CODE_STRING32*/, len);\n        for (var i = 0;i < len;i++)\n          writer.write (8, caml_string_unsafe_get(v,i));\n        writer.size_32 += 1 + (((len + 4) / 4)|0);\n        writer.size_64 += 1 + (((len + 8) / 8)|0);\n      } else {\n        if (v != (v|0)){\n          var type_of_v = typeof v;\n          //\n          // If a float happens to be an integer it is serialized as an integer\n          // (Js_of_ocaml cannot tell whether the type of an integer number is\n          // float or integer.) This can result in unexpected crashes when\n          // unmarshalling using the standard runtime. It seems better to\n          // systematically fail on marshalling.\n          //\n          //          if(type_of_v != \"number\")\n          caml_failwith(\"output_value: abstract value (\"+type_of_v+\")\");\n          //          var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));\n          //          writer.write (8, 0x0B /*cst.CODE_DOUBLE_BIG*/);\n          //          for(var i = 0; i<8; i++){writer.write(8,t[i])}\n        }\n        else if (v >= 0 && v < 0x40) {\n          writer.write (8, 0X40 /*cst.PREFIX_SMALL_INT*/ + v);\n        } else {\n          if (v >= -(1 << 7) && v < (1 << 7))\n            writer.write_code(8, 0x00 /*cst.CODE_INT8*/, v);\n          else if (v >= -(1 << 15) && v < (1 << 15))\n            writer.write_code(16, 0x01 /*cst.CODE_INT16*/, v);\n          else\n            writer.write_code(32, 0x02 /*cst.CODE_INT32*/, v);\n        }\n      }\n    }\n    extern_rec (v);\n    while (stack.length > 0) {\n      var i = stack.pop ();\n      var v = stack.pop ();\n      if (i + 1 < v.length) stack.push (v, i + 1);\n      extern_rec (v[i]);\n    }\n    if (intern_obj_table) writer.obj_counter = intern_obj_table.objs.length;\n    writer.finalize();\n    return writer.chunk;\n  }\n} ();\n\n//Provides: caml_output_value_to_string mutable\n//Requires: caml_output_val, caml_string_of_array\nfunction caml_output_value_to_string (v, flags) {\n  return caml_string_of_array (caml_output_val (v, flags));\n}\n\n//Provides: caml_output_value_to_bytes mutable\n//Requires: caml_output_val, caml_bytes_of_array\nfunction caml_output_value_to_bytes (v, flags) {\n  return caml_bytes_of_array (caml_output_val (v, flags));\n}\n\n//Provides: caml_output_value_to_buffer\n//Requires: caml_output_val, caml_failwith, caml_blit_bytes\nfunction caml_output_value_to_buffer (s, ofs, len, v, flags) {\n  var t = caml_output_val (v, flags);\n  if (t.length > len) caml_failwith (\"Marshal.to_buffer: buffer overflow\");\n  caml_blit_bytes(t, 0, s, ofs, t.length);\n  return 0;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_compare_val_tag\n//Requires: caml_is_ml_string, caml_is_ml_bytes\nfunction caml_compare_val_tag(a){\n  if (typeof a === \"number\") return 1000; // int_tag (we use it for all numbers)\n  else if (caml_is_ml_bytes(a)) return 252; // string_tag\n  else if (caml_is_ml_string(a)) return 1252; // ocaml string (if different from bytes)\n  else if (a instanceof Array && a[0] === (a[0]>>>0) && a[0] <= 255) {\n    // Look like an ocaml block\n    var tag = a[0] | 0;\n    // ignore double_array_tag because we cannot accurately set\n    // this tag when we create an array of float.\n    return (tag == 254)?0:tag\n  }\n  else if (a instanceof String) return 12520; // javascript string, like string_tag (252)\n  else if (typeof a == \"string\") return 12520; // javascript string, like string_tag (252)\n  else if (a instanceof Number) return 1000; // int_tag (we use it for all numbers)\n  else if (a && a.caml_custom) return 1255; // like custom_tag (255)\n  else if (a && a.compare) return 1256; // like custom_tag (255)\n  else if (typeof a == \"function\") return 1247; // like closure_tag (247)\n  else if (typeof a == \"symbol\") return 1251;\n  return 1001; //out_of_heap_tag\n}\n\n//Provides: caml_compare_val_get_custom\n//Requires: caml_custom_ops\nfunction caml_compare_val_get_custom(a){\n  return caml_custom_ops[a.caml_custom] && caml_custom_ops[a.caml_custom].compare;\n}\n\n//Provides: caml_compare_val_number_custom\n//Requires: caml_compare_val_get_custom\nfunction caml_compare_val_number_custom(num, custom, swap, total) {\n  var comp = caml_compare_val_get_custom(custom);\n  if(comp) {\n    var x = (swap > 0)?comp(custom,num,total):comp(num,custom,total);\n    if(total && x != x) return swap; // total && nan\n    if(+x != +x) return +x; // nan\n    if((x | 0) != 0) return (x | 0); // !nan\n  }\n  return swap\n}\n\n//Provides: caml_compare_val (const, const, const)\n//Requires: caml_int_compare, caml_string_compare, caml_bytes_compare\n//Requires: caml_invalid_argument, caml_compare_val_get_custom, caml_compare_val_tag\n//Requires: caml_compare_val_number_custom\n//Requires: caml_jsbytes_of_string\n//Requires: caml_is_continuation_tag\nfunction caml_compare_val (a, b, total) {\n  var stack = [];\n  for(;;) {\n    if (!(total && a === b)) {\n      var tag_a = caml_compare_val_tag(a);\n      // forward_tag ?\n      if(tag_a == 250) { a = a[1]; continue }\n\n      var tag_b = caml_compare_val_tag(b);\n      // forward_tag ?\n      if(tag_b == 250) { b = b[1]; continue }\n\n      // tags are different\n      if(tag_a !== tag_b) {\n        if(tag_a == 1000) {\n          if(tag_b == 1255) { //immediate can compare against custom\n            return caml_compare_val_number_custom(a, b, -1, total);\n          }\n          return -1\n        }\n        if(tag_b == 1000) {\n          if(tag_a == 1255) { //immediate can compare against custom\n            return caml_compare_val_number_custom(b, a, 1, total);\n          }\n          return 1\n        }\n        return (tag_a < tag_b)?-1:1;\n      }\n      switch(tag_a){\n        // 246: Lazy_tag handled bellow\n      case 247: // Closure_tag\n        // Cannot happen\n        caml_invalid_argument(\"compare: functional value\");\n        break\n      case 248: // Object\n        var x = caml_int_compare(a[2], b[2]);\n        if (x != 0) return (x | 0);\n        break;\n      case 249: // Infix\n        // Cannot happen\n        caml_invalid_argument(\"compare: functional value\");\n        break\n      case 250: // Forward tag\n        // Cannot happen, handled above\n        caml_invalid_argument(\"equal: got Forward_tag, should not happen\");\n        break;\n      case 251: //Abstract\n        caml_invalid_argument(\"equal: abstract value\");\n        break;\n      case 252: // OCaml bytes\n        if (a !== b) {\n          var x = caml_bytes_compare(a, b);\n          if (x != 0) return (x | 0);\n        };\n        break;\n      case 253: // Double_tag\n        // Cannot happen\n        caml_invalid_argument(\"equal: got Double_tag, should not happen\");\n        break;\n      case 254: // Double_array_tag\n        // Cannot happen, handled above\n        caml_invalid_argument(\"equal: got Double_array_tag, should not happen\");\n        break\n      case 255: // Custom_tag\n        caml_invalid_argument(\"equal: got Custom_tag, should not happen\");\n        break;\n      case 1247: // Function\n        caml_invalid_argument(\"compare: functional value\");\n        break;\n      case 1255: // Custom\n        var comp = caml_compare_val_get_custom(a);\n        if(comp != caml_compare_val_get_custom(b)){\n          return (a.caml_custom<b.caml_custom)?-1:1;\n        }\n        if(!comp)\n          caml_invalid_argument(\"compare: abstract value\");\n        var x = comp(a,b,total);\n        if(x != x){ // Protect against invalid UNORDERED\n          return total?-1:x;\n        }\n        if(x !== (x|0)){ // Protect against invalid return value\n          return -1\n        }\n        if (x != 0) return (x | 0);\n        break;\n      case 1256: // compare function\n        var x = a.compare(b,total);\n        if(x != x) { // Protect against invalid UNORDERED\n          return total?-1:x;\n        }\n        if(x !== (x|0)){ // Protect against invalid return value\n          return -1\n        }\n        if (x != 0) return (x | 0);\n        break;\n      case 1000: // Number\n        a = +a;\n        b = +b;\n        if (a < b) return -1;\n        if (a > b) return 1;\n        if (a != b) {\n          if (!total) return NaN;\n          if (a == a) return 1;\n          if (b == b) return -1;\n        }\n        break;\n      case 1001: // The rest\n        // Here we can be in the following cases:\n        // 1. JavaScript primitive types\n        // 2. JavaScript object that can be coerced to primitive types\n        // 3. JavaScript object than cannot be coerced to primitive types\n        //\n        // (3) will raise a [TypeError]\n        // (2) will coerce to primitive types using [valueOf] or [toString]\n        // (2) and (3), after eventual coercion\n        // - if a and b are strings, apply lexicographic comparison\n        // - if a or b are not strings, convert a and b to number\n        //   and apply standard comparison\n        //\n        // Exception: `!=` will not coerce/convert if both a and b are objects\n        if (a < b) return -1;\n        if (a > b) return 1;\n        if (a != b) {\n          if (!total) return NaN;\n          if (a == a) return 1;\n          if (b == b) return -1;\n        }\n        break;\n      case 1251: // JavaScript Symbol, no ordering.\n        if(a !== b) {\n          if (!total) return NaN;\n          return 1;\n        }\n        break;\n      case 1252: // ocaml strings\n        var a = caml_jsbytes_of_string(a);\n        var b = caml_jsbytes_of_string(b);\n        if(a !== b) {\n          if(a < b) return -1;\n          if(a > b) return 1;\n        }\n        break;\n      case 12520: // javascript strings\n        var a = a.toString();\n        var b = b.toString();\n        if(a !== b) {\n          if(a < b) return -1;\n          if(a > b) return 1;\n        }\n        break;\n      case 246: // Lazy_tag\n      case 254: // Double_array\n      default: // Block with other tag\n        if(caml_is_continuation_tag(tag_a)) {\n          caml_invalid_argument(\"compare: continuation value\");\n          break;\n        }\n        if (a.length != b.length) return (a.length < b.length)?-1:1;\n        if (a.length > 1) stack.push(a, b, 1);\n        break;\n      }\n    }\n    if (stack.length == 0) return 0;\n    var i = stack.pop();\n    b = stack.pop();\n    a = stack.pop();\n    if (i + 1 < a.length) stack.push(a, b, i + 1);\n    a = a[i];\n    b = b[i];\n  }\n}\n//Provides: caml_compare (const, const)\n//Requires: caml_compare_val\nfunction caml_compare (a, b) { return caml_compare_val (a, b, true); }\n//Provides: caml_int_compare mutable (const, const)\nfunction caml_int_compare (a, b) {\n  if (a < b) return (-1); if (a == b) return 0; return 1;\n}\n//Provides: caml_equal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_equal (x, y) { return +(caml_compare_val(x,y,false) == 0); }\n//Provides: caml_notequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_notequal (x, y) { return +(caml_compare_val(x,y,false) != 0); }\n//Provides: caml_greaterequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterequal (x, y) { return +(caml_compare_val(x,y,false) >= 0); }\n//Provides: caml_greaterthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterthan (x, y) { return +(caml_compare_val(x,y,false) > 0); }\n//Provides: caml_lessequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessequal (x, y) { return +(caml_compare_val(x,y,false) <= 0); }\n//Provides: caml_lessthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessthan (x, y) { return +(caml_compare_val(x,y,false) < 0); }\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// Weak API\n\n//Provides: caml_ephe_key_offset\nvar caml_ephe_key_offset = 3\n\n//Provides: caml_ephe_data_offset\nvar caml_ephe_data_offset = 2\n\n//Provides: caml_ephe_set_key\n//Requires: caml_invalid_argument, caml_ephe_key_offset\nfunction caml_ephe_set_key(x, i, v) {\n  if(i < 0 || caml_ephe_key_offset + i >= x.length)\n    caml_invalid_argument (\"Weak.set\");\n  if (v instanceof Object && globalThis.WeakRef) {\n    if(x[1].register) x[1].register(v, undefined, v);\n    x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);\n  }\n  else x[caml_ephe_key_offset + i] = v;\n  return 0\n}\n\n//Provides: caml_ephe_unset_key\n//Requires: caml_invalid_argument, caml_ephe_key_offset\nfunction caml_ephe_unset_key(x, i) {\n  if(i < 0 || caml_ephe_key_offset + i >= x.length)\n    caml_invalid_argument (\"Weak.set\");\n  if(globalThis.WeakRef && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef && x[1].unregister) {\n    var old = x[caml_ephe_key_offset + i].deref();\n    if(old !== undefined) {\n      var count = 0\n      for(var j = caml_ephe_key_offset; j < x.length; j++){\n        var key = x[j];\n        if(key instanceof globalThis.WeakRef){\n          key = key.deref()\n          if(key === old) count++;\n        }\n      }\n      if(count == 1) x[1].unregister(old);\n    }\n  }\n  x[caml_ephe_key_offset + i] = undefined;\n  return 0\n}\n\n\n//Provides: caml_ephe_create\n//Requires: caml_weak_create, caml_ephe_data_offset\nfunction caml_ephe_create (n) {\n  var x = caml_weak_create(n);\n  return x;\n}\n\n//Provides: caml_weak_create\n//Requires: caml_ephe_key_offset, caml_invalid_argument,caml_ephe_data_offset\nfunction caml_weak_create (n) {\n  if (n < 0) caml_invalid_argument (\"Weak.create\");\n  var x = [251,\"caml_ephe_list_head\"];\n  x.length = caml_ephe_key_offset + n;\n  return x;\n}\n\n//Provides: caml_weak_set\n//Requires: caml_invalid_argument\n//Requires: caml_ephe_set_key, caml_ephe_unset_key\nfunction caml_weak_set(x, i, v) {\n  if(v == 0) caml_ephe_unset_key(x,i)\n  else caml_ephe_set_key(x,i,v[1])\n  return 0;\n}\n//Provides: caml_ephe_get_key\n//Requires: caml_ephe_key_offset, caml_invalid_argument\n//Alias: caml_weak_get\nfunction caml_ephe_get_key(x, i) {\n  if(i < 0 || caml_ephe_key_offset + i >= x.length)\n    caml_invalid_argument (\"Weak.get_key\");\n  var weak = x[caml_ephe_key_offset + i ];\n  if(globalThis.WeakRef && weak instanceof globalThis.WeakRef) weak = weak.deref();\n  return (weak===undefined)?0:[0, weak];\n}\n//Provides: caml_ephe_get_key_copy\n//Requires: caml_ephe_get_key,caml_ephe_key_offset\n//Requires: caml_obj_dup, caml_invalid_argument\n//Alias: caml_weak_get_copy\nfunction caml_ephe_get_key_copy(x, i) {\n  if(i < 0 || caml_ephe_key_offset + i >= x.length)\n    caml_invalid_argument (\"Weak.get_copy\");\n  var y = caml_ephe_get_key(x, i);\n  if (y === 0) return y;\n  var z = y[1];\n  if (z instanceof Array) return [0, caml_obj_dup(z)];\n  return y;\n}\n\n//Provides: caml_ephe_check_key mutable\n//Requires: caml_ephe_key_offset\n//Alias: caml_weak_check\nfunction caml_ephe_check_key(x, i) {\n  var weak = x[caml_ephe_key_offset + i];\n  if(globalThis.WeakRef && weak instanceof globalThis.WeakRef) weak = weak.deref();\n  if(weak===undefined)\n    return 0;\n  else\n    return 1;\n}\n\n//Provides: caml_ephe_blit_key\n//Requires: caml_array_blit\n//Requires: caml_ephe_key_offset\n//Alias: caml_weak_blit\nfunction caml_ephe_blit_key(a1, i1, a2, i2, len) {\n  // minus one because caml_array_blit works on ocaml array\n  caml_array_blit(a1, caml_ephe_key_offset + i1 - 1,\n                  a2, caml_ephe_key_offset + i2 - 1,\n                  len);\n  return 0;\n}\n\n//Provides: caml_ephe_blit_data\n//Requires: caml_ephe_data_offset, caml_ephe_set_data, caml_ephe_unset_data\nfunction caml_ephe_blit_data(src, dst){\n  var n = src[caml_ephe_data_offset];\n  if(n === undefined) caml_ephe_unset_data(dst);\n  else caml_ephe_set_data(dst, n);\n  return 0;\n}\n\n//Provides: caml_ephe_get_data\n//Requires: caml_ephe_data_offset\nfunction caml_ephe_get_data(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return [0, x[caml_ephe_data_offset]];\n}\n\n//Provides: caml_ephe_get_data_copy\n//Requires: caml_ephe_data_offset\n//Requires: caml_obj_dup\nfunction caml_ephe_get_data_copy(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return [0, caml_obj_dup(x[caml_ephe_data_offset])];\n}\n\n//Provides: caml_ephe_set_data\n//Requires: caml_ephe_data_offset, caml_ephe_key_offset, caml_ephe_unset_data\nfunction caml_ephe_set_data(x, data){\n  if(globalThis.FinalizationRegistry && globalThis.WeakRef) {\n    if(! (x[1] instanceof globalThis.FinalizationRegistry)) {\n      x[1] = new globalThis.FinalizationRegistry(function () { caml_ephe_unset_data(x) });\n      //register all keys\n      for(var j = caml_ephe_key_offset; j < x.length; j++){\n        var key = x[j];\n        if(key instanceof globalThis.WeakRef) {\n          key = key.deref();\n          if(key) x[1].register(key, undefined, key);\n        }\n      }\n    }\n  }\n  x[caml_ephe_data_offset] = data;\n  return 0;\n}\n\n//Provides: caml_ephe_unset_data\n//Requires: caml_ephe_data_offset, caml_ephe_key_offset\nfunction caml_ephe_unset_data(x){\n  if(globalThis.FinalizationRegistry && globalThis.WeakRef) {\n    if(x[1] instanceof globalThis.FinalizationRegistry){\n      //unregister all keys\n      for(var j = caml_ephe_key_offset; j < x.length; j++){\n        var key = x[j];\n        if(key instanceof globalThis.WeakRef) {\n          key = key.deref();\n          if(key) x[1].unregister(key);\n        }\n      }\n    }\n  }\n  x[caml_ephe_data_offset] = undefined;\n  return 0;\n}\n\n//Provides: caml_ephe_check_data\n//Requires: caml_ephe_data_offset\nfunction caml_ephe_check_data(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return 1;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Format\n\n//Provides: caml_parse_format\n//Requires: caml_jsbytes_of_string, caml_invalid_argument\nfunction caml_parse_format (fmt) {\n  fmt = caml_jsbytes_of_string(fmt);\n  var len = fmt.length;\n  if (len > 31) caml_invalid_argument(\"format_int: format too long\");\n  var f =\n      { justify:'+', signstyle:'-', filler:' ', alternate:false,\n        base:0, signedconv:false, width:0, uppercase:false,\n        sign:1, prec:-1, conv:'f' };\n  for (var i = 0; i < len; i++) {\n    var c = fmt.charAt(i);\n    switch (c) {\n    case '-':\n      f.justify = '-'; break;\n    case '+': case ' ':\n      f.signstyle = c; break;\n    case '0':\n      f.filler = '0'; break;\n    case '#':\n      f.alternate = true; break;\n    case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      f.width = 0;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.width = f.width * 10 + c; i++\n      }\n      i--;\n      break;\n    case '.':\n      f.prec = 0;\n      i++;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.prec = f.prec * 10 + c; i++\n      }\n      i--;\n    case 'd': case 'i':\n      f.signedconv = true; /* fallthrough */\n    case 'u':\n      f.base = 10; break;\n    case 'x':\n      f.base = 16; break;\n    case 'X':\n      f.base = 16; f.uppercase = true; break;\n    case 'o':\n      f.base = 8; break;\n    case 'e': case 'f': case 'g':\n      f.signedconv = true; f.conv = c; break;\n    case 'E': case 'F': case 'G':\n      f.signedconv = true; f.uppercase = true;\n      f.conv = c.toLowerCase (); break;\n    }\n  }\n  return f;\n}\n\n//Provides: caml_finish_formatting\n//Requires: caml_string_of_jsbytes\nfunction caml_finish_formatting(f, rawbuffer) {\n  if (f.uppercase) rawbuffer = rawbuffer.toUpperCase();\n  var len = rawbuffer.length;\n  /* Adjust len to reflect additional chars (sign, etc) */\n  if (f.signedconv && (f.sign < 0 || f.signstyle != '-')) len++;\n  if (f.alternate) {\n    if (f.base == 8) len += 1;\n    if (f.base == 16) len += 2;\n  }\n  /* Do the formatting */\n  var buffer = \"\";\n  if (f.justify == '+' && f.filler == ' ')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  if (f.signedconv) {\n    if (f.sign < 0) buffer += '-';\n    else if (f.signstyle != '-') buffer += f.signstyle;\n  }\n  if (f.alternate && f.base == 8) buffer += '0';\n  if (f.alternate && f.base == 16) buffer += f.uppercase?\"0X\":\"0x\";\n  if (f.justify == '+' && f.filler == '0')\n    for (var i = len; i < f.width; i++) buffer += '0';\n  buffer += rawbuffer;\n  if (f.justify == '-')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  return caml_string_of_jsbytes(buffer);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: fs_node_supported\nfunction fs_node_supported () {\n  return (\n    typeof globalThis.process !== 'undefined'\n      && typeof globalThis.process.versions !== 'undefined'\n      && typeof globalThis.process.versions.node !== 'undefined')\n}\n//Provides: fs_node_supported\n//If: browser\nfunction fs_node_supported () {\n  return false\n}\n\n\n//Provides: MlNodeDevice\n//Requires: MlNodeFd, caml_raise_sys_error, caml_raise_with_args\n//Requires: make_unix_err_args, caml_named_value, caml_string_of_jsstring\nfunction MlNodeDevice(root) {\n  this.fs = require('fs');\n  this.root = root;\n}\nMlNodeDevice.prototype.nm = function(name) {\n  return (this.root + name);\n}\nMlNodeDevice.prototype.exists = function(name) {\n  try {\n    return this.fs.existsSync(this.nm(name))?1:0;\n  } catch (err) {\n    return 0;\n  }\n}\nMlNodeDevice.prototype.isFile = function(name) {\n  try {\n    return this.fs.statSync(this.nm(name)).isFile()?1:0;\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeDevice.prototype.mkdir = function(name, mode, raise_unix) {\n  try {\n    this.fs.mkdirSync(this.nm(name),{mode:mode});\n    return 0\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.rmdir = function(name, raise_unix) {\n  try {\n    this.fs.rmdirSync(this.nm(name));\n    return 0\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.readdir = function(name, raise_unix) {\n  try {\n    return this.fs.readdirSync(this.nm(name));\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.is_dir = function(name) {\n  try {\n    return this.fs.statSync(this.nm(name)).isDirectory()?1:0;\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeDevice.prototype.unlink = function(name, raise_unix) {\n  try {\n    var b = this.fs.existsSync(this.nm(name))?1:0;\n    this.fs.unlinkSync(this.nm(name));\n    return b;\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.open = function(name, f, raise_unix) {\n  var consts = require('constants');\n  var res = 0;\n  for(var key in f){\n    switch(key){\n    case \"rdonly\"  : res |= consts.O_RDONLY; break;\n    case \"wronly\"  : res |= consts.O_WRONLY; break;\n    case \"append\"  :\n      res |= consts.O_WRONLY | consts.O_APPEND;\n      break;\n    case \"create\"   : res |= consts.O_CREAT;    break;\n    case \"truncate\" : res |= consts.O_TRUNC;    break;\n    case \"excl\"     : res |= consts.O_EXCL;     break;\n    case \"binary\"   : res |= consts.O_BINARY;   break;\n    case \"text\"     : res |= consts.O_TEXT;     break;\n    case \"nonblock\" : res |= consts.O_NONBLOCK; break;\n    }\n  }\n  try {\n    var fd = this.fs.openSync(this.nm(name), res);\n    var isCharacterDevice = this.fs.lstatSync(this.nm(name)).isCharacterDevice();\n    f.isCharacterDevice = isCharacterDevice;\n    return new MlNodeFd(fd, f);\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\n\nMlNodeDevice.prototype.rename = function(o, n, raise_unix) {\n  try {\n    this.fs.renameSync(this.nm(o), this.nm(n));\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.stat = function(name, raise_unix) {\n  try {\n    var js_stats = this.fs.statSync(this.nm(name));\n    return this.stats_from_js(js_stats);\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.lstat = function(name, raise_unix) {\n  try {\n    var js_stats = this.fs.lstatSync(this.nm(name));\n    return this.stats_from_js(js_stats);\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.symlink = function(to_dir, target, path, raise_unix) {\n  try {\n    this.fs.symlinkSync(this.nm(target), this.nm(path), to_dir ? 'dir' : 'file');\n    return 0;\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.readlink = function(name, raise_unix) {\n  try {\n    var link = this.fs.readlinkSync(this.nm(name), 'utf8');\n    return caml_string_of_jsstring(link);\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.opendir = function(name, raise_unix) {\n  try {\n    return this.fs.opendirSync(this.nm(name));\n  } catch (err) {\n    this.raise_nodejs_error(err, raise_unix);\n  }\n}\nMlNodeDevice.prototype.raise_nodejs_error = function(err, raise_unix) {\n  var unix_error = caml_named_value(\"Unix.Unix_error\");\n  if (raise_unix && unix_error) {\n    var args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);\n    caml_raise_with_args(unix_error, args);\n  } else {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeDevice.prototype.stats_from_js = function(js_stats) {\n  /* ===Unix.file_kind===\n   * type file_kind =\n   *     S_REG                       (** Regular file *)\n   *   | S_DIR                       (** Directory *)\n   *   | S_CHR                       (** Character device *)\n   *   | S_BLK                       (** Block device *)\n   *   | S_LNK                       (** Symbolic link *)\n   *   | S_FIFO                      (** Named pipe *)\n   *   | S_SOCK                      (** Socket *)\n   */\n  var file_kind;\n  if (js_stats.isFile()) {\n    file_kind = 0;\n  } else if (js_stats.isDirectory()) {\n    file_kind = 1;\n  } else if (js_stats.isCharacterDevice()) {\n    file_kind = 2;\n  } else if (js_stats.isBlockDevice()) {\n    file_kind = 3;\n  } else if (js_stats.isSymbolicLink()) {\n    file_kind = 4;\n  } else if (js_stats.isFIFO()) {\n    file_kind = 5;\n  } else if (js_stats.isSocket()) {\n    file_kind = 6;\n  }\n  /* ===Unix.stats===\n   * type stats =\n   *  { st_dev : int;               (** Device number *)\n   *    st_ino : int;               (** Inode number *)\n   *    st_kind : file_kind;        (** Kind of the file *)\n   *    st_perm : file_perm;        (** Access rights *)\n   *    st_nlink : int;             (** Number of links *)\n   *    st_uid : int;               (** User id of the owner *)\n   *    st_gid : int;               (** Group ID of the file's group *)\n   *    st_rdev : int;              (** Device ID (if special file) *)\n   *    st_size : int;              (** Size in bytes *)\n   *    st_atime : float;           (** Last access time *)\n   *    st_mtime : float;           (** Last modification time *)\n   *    st_ctime : float;           (** Last status change time *)\n   *  }\n   */\n  return BLOCK(\n    0,\n    js_stats.dev,\n    js_stats.ino,\n    file_kind,\n    js_stats.mode,\n    js_stats.nlink,\n    js_stats.uid,\n    js_stats.gid,\n    js_stats.rdev,\n    js_stats.size,\n    js_stats.atimeMs,\n    js_stats.mtimeMs,\n    js_stats.ctimeMs\n  );\n}\n\nMlNodeDevice.prototype.constructor = MlNodeDevice\n\n//Provides: MlNodeDevice\n//If: browser\nfunction MlNodeDevice() {\n}\n\n//Provides: MlNodeFd\n//Requires: MlFile, caml_uint8_array_of_string, caml_uint8_array_of_bytes, caml_bytes_set, caml_raise_sys_error\nfunction MlNodeFd(fd, flags){\n  this.fs = require('fs');\n  this.fd = fd;\n  this.flags = flags;\n}\nMlNodeFd.prototype = new MlFile ();\nMlNodeFd.prototype.constructor = MlNodeFd;\n\nMlNodeFd.prototype.truncate = function(len){\n  try {\n    this.fs.ftruncateSync(this.fd,len|0);\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeFd.prototype.length = function () {\n  try {\n    return this.fs.fstatSync(this.fd).size;\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeFd.prototype.write = function(offset,buf,buf_offset,len){\n  try {\n    if(this.flags.isCharacterDevice)\n      this.fs.writeSync(this.fd, buf, buf_offset, len);\n    else\n      this.fs.writeSync(this.fd, buf, buf_offset, len, offset);\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n  return 0;\n}\nMlNodeFd.prototype.read = function(offset,a,buf_offset,len){\n  try {\n    if(this.flags.isCharacterDevice)\n      var read = this.fs.readSync(this.fd, a, buf_offset, len);\n    else\n      var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);\n    return read;\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\nMlNodeFd.prototype.close = function(){\n  try {\n    this.fs.closeSync(this.fd);\n    return 0\n  } catch (err) {\n    caml_raise_sys_error(err.toString());\n  }\n}\n\n\n//Provides: MlNodeFd\n//If: browser\nfunction MlNodeFd(){\n}\n\n\n//Provides: caml_sys_open_for_node\n//Requires: MlNodeFd\nfunction caml_sys_open_for_node(fd, flags){\n  if(flags.name) {\n    try {\n      var fs = require(\"fs\");\n      var fd2 = fs.openSync(flags.name, \"rs\");\n      return new MlNodeFd(fd2, flags);\n    } catch(e) {  }\n  }\n  return new MlNodeFd(fd, flags);\n}\n\n//Provides: caml_sys_open_for_node\n//If: browser\nfunction caml_sys_open_for_node(fd, flags){\n  return null;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Dummy filesystem\n\n//Provides: caml_trailing_slash\nfunction caml_trailing_slash(name){\n  return (name.slice(-1) !== \"/\") ? (name + \"/\") : name;\n}\n\n//Provides: caml_current_dir\n//Requires: caml_trailing_slash, fs_node_supported\nif(fs_node_supported () && globalThis.process && globalThis.process.cwd)\n  var caml_current_dir = globalThis.process.cwd().replace(/\\\\/g,'/');\nelse\n  var caml_current_dir =  \"/static\";\ncaml_current_dir = caml_trailing_slash(caml_current_dir);\n\n//Provides: caml_get_root\n//Requires: path_is_absolute\nfunction caml_get_root(path){\n  var x = path_is_absolute(path);\n  if (!x) return;\n  return x[0] + \"/\"}\n\n//Provides: caml_root\n//Requires: caml_get_root, caml_current_dir, caml_failwith\nvar caml_root = caml_get_root(caml_current_dir) || caml_failwith(\"unable to compute caml_root\");\n\n\n//Provides: MlFile\nfunction MlFile(){  }\n\n//Provides: path_is_absolute\n//Requires: fs_node_supported\nfunction make_path_is_absolute() {\n  function posix(path) {\n    if (path.charAt(0) === '/') return [\"\", path.substring(1)];\n    return;\n  }\n\n  function win32(path) {\n    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n    var splitDeviceRe = /^([a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/]+[^\\\\/]+)?([\\\\/])?([\\s\\S]*?)$/;\n    var result = splitDeviceRe.exec(path);\n    var device = result[1] || '';\n    var isUnc = Boolean(device && device.charAt(1) !== ':');\n\n    // UNC paths are always absolute\n    if (Boolean(result[2] || isUnc)) {\n      var root = (result[1] || '');\n      var sep = (result[2] || '');\n      return [root, path.substring(root.length + sep.length)]\n    }\n    return;\n  }\n  if(fs_node_supported () && globalThis.process && globalThis.process.platform) {\n    return globalThis.process.platform === 'win32' ? win32 : posix;\n  }\n  else return posix\n}\nvar path_is_absolute = make_path_is_absolute();\n\n//Provides: caml_make_path\n//Requires: caml_current_dir\n//Requires: caml_jsstring_of_string, path_is_absolute\nfunction caml_make_path (name) {\n  name=caml_jsstring_of_string(name);\n  if( !path_is_absolute(name) )\n    name = caml_current_dir + name;\n  var comp0 = path_is_absolute(name);\n  var comp = comp0[1].split(\"/\");\n  var ncomp = []\n  for(var i = 0; i<comp.length; i++){\n    switch(comp[i]){\n    case \"..\": if(ncomp.length>1) ncomp.pop(); break;\n    case \".\": break;\n    case \"\": break;\n    default: ncomp.push(comp[i]);break\n    }\n  }\n  ncomp.unshift(comp0[0]);\n  ncomp.orig = name;\n  return ncomp;\n}\n\n//Provides:jsoo_mount_point\n//Requires: MlFakeDevice, MlNodeDevice, caml_root, fs_node_supported\nvar jsoo_mount_point = []\nif (fs_node_supported()) {\n  jsoo_mount_point.push({path:caml_root,device:new MlNodeDevice(caml_root)});\n} else {\n  jsoo_mount_point.push({path:caml_root,device:new MlFakeDevice(caml_root)});\n}\njsoo_mount_point.push({path:\"/static/\", device:new MlFakeDevice(\"/static/\")});\n\n//Provides:caml_list_mount_point\n//Requires: jsoo_mount_point, caml_string_of_jsbytes\nfunction caml_list_mount_point(){\n  var prev = 0\n  for(var i = 0; i < jsoo_mount_point.length; i++){\n    var old = prev;\n    prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old]\n  }\n  return prev;\n}\n\n//Provides: resolve_fs_device\n//Requires: caml_make_path, jsoo_mount_point, caml_raise_sys_error, caml_get_root, MlNodeDevice, caml_trailing_slash, fs_node_supported\nfunction resolve_fs_device(name){\n  var path = caml_make_path(name);\n  var name = path.join(\"/\");\n  var name_slash = caml_trailing_slash(name);\n  var res;\n  for(var i = 0; i < jsoo_mount_point.length; i++) {\n    var m = jsoo_mount_point[i];\n    if(name_slash.search(m.path) == 0\n       && (!res || res.path.length < m.path.length))\n      res = {path:m.path,device:m.device,rest:name.substring(m.path.length,name.length)};\n  }\n  if( !res && fs_node_supported()) {\n    var root = caml_get_root(name);\n    if (root && root.match(/^[a-zA-Z]:\\/$/)){\n      var m = {path:root,device:new MlNodeDevice(root)};\n      jsoo_mount_point.push(m);\n      res = {path:m.path,device:m.device,rest:name.substring(m.path.length,name.length)};\n    }\n  }\n  if( res ) return res;\n  caml_raise_sys_error(\"no device found for \" + name_slash);\n}\n\n//Provides: caml_mount_autoload\n//Requires: MlFakeDevice, caml_make_path, jsoo_mount_point, caml_trailing_slash\nfunction caml_mount_autoload(name,f){\n  var path = caml_make_path(name);\n  var name = caml_trailing_slash(path.join(\"/\"));\n  jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)})\n  return 0;\n}\n\n//Provides: caml_unmount\n//Requires: jsoo_mount_point, caml_make_path, caml_trailing_slash\nfunction caml_unmount(name){\n  var path = caml_make_path(name);\n  var name = caml_trailing_slash(path.join(\"/\"));\n  var idx = -1;\n  for(var i = 0; i < jsoo_mount_point.length; i++)\n    if(jsoo_mount_point[i].path == name) idx = i;\n  if(idx > -1) jsoo_mount_point.splice(idx,1);\n  return 0\n}\n\n//Provides: caml_sys_getcwd\n//Requires: caml_current_dir, caml_string_of_jsbytes\nfunction caml_sys_getcwd() {\n  return caml_string_of_jsbytes(caml_current_dir);\n}\n\n//Provides: caml_sys_chdir\n//Requires: caml_current_dir, caml_raise_no_such_file, resolve_fs_device, caml_trailing_slash, caml_jsbytes_of_string\nfunction caml_sys_chdir(dir) {\n  var root = resolve_fs_device(dir);\n  if(root.device.exists(root.rest)) {\n    if(root.rest) caml_current_dir = caml_trailing_slash(root.path + root.rest);\n    else caml_current_dir = root.path;\n    return 0;\n  }\n  else {\n    caml_raise_no_such_file(caml_jsbytes_of_string(dir));\n  }\n}\n\n//Provides: caml_raise_no_such_file\n//Requires: caml_raise_sys_error\nfunction caml_raise_no_such_file(name){\n  caml_raise_sys_error (name + \": No such file or directory\");\n}\n\n//Provides: caml_raise_not_a_dir\n//Requires: caml_raise_sys_error\nfunction caml_raise_not_a_dir(name){\n  caml_raise_sys_error (name + \": Not a directory\");\n}\n\n//Provides: caml_sys_file_exists\n//Requires: resolve_fs_device\nfunction caml_sys_file_exists (name) {\n  var root = resolve_fs_device(name);\n  return root.device.exists(root.rest);\n}\n\n//Provides: caml_sys_read_directory\n//Requires: caml_string_of_jsbytes\n//Requires: caml_raise_not_a_dir, resolve_fs_device\nfunction caml_sys_read_directory(name){\n  var root = resolve_fs_device(name);\n  var a = root.device.readdir(root.rest);\n  var l = new Array(a.length + 1);\n  l[0] = 0;\n  for(var i=0;i<a.length;i++)\n    l[i+1] = caml_string_of_jsbytes(a[i]);\n  return l;\n}\n\n//Provides: caml_sys_remove\n//Requires: caml_raise_no_such_file, resolve_fs_device, caml_jsbytes_of_string\nfunction caml_sys_remove(name){\n  var root = resolve_fs_device(name);\n  var ok = root.device.unlink(root.rest);\n  if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));\n  return 0;\n}\n\n//Provides: caml_sys_is_directory\n//Requires: resolve_fs_device\nfunction caml_sys_is_directory(name){\n  var root = resolve_fs_device(name);\n  var a = root.device.is_dir(root.rest);\n  return a?1:0;\n}\n\n//Provides: caml_sys_rename\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_sys_rename(o,n){\n  var o_root = resolve_fs_device(o);\n  var n_root = resolve_fs_device(n);\n  if(o_root.device != n_root.device)\n    caml_failwith(\"caml_sys_rename: cannot move file between two filesystem\");\n  if(!o_root.device.rename)\n    caml_failwith(\"caml_sys_rename: no implemented\");\n  o_root.device.rename(o_root.rest, n_root.rest);\n}\n\n//Provides: caml_sys_mkdir\n//Requires: resolve_fs_device, caml_raise_sys_error\nfunction caml_sys_mkdir(name, perm){\n  var root = resolve_fs_device(name);\n  root.device.mkdir(root.rest,perm);\n  return 0;\n}\n\n//Provides: caml_sys_rmdir\n//Requires: resolve_fs_device, caml_raise_sys_error, caml_raise_not_a_dir\nfunction caml_sys_rmdir(name){\n  var root = resolve_fs_device(name);\n  root.device.rmdir(root.rest);\n  return 0;\n}\n\n//Provides: caml_ba_map_file\n//Requires: caml_failwith\nfunction caml_ba_map_file(vfd, kind, layout, shared, dims, pos) {\n  // var data = caml_sys_fds[vfd];\n  caml_failwith(\"caml_ba_map_file not implemented\");\n}\n\n//Provides: caml_ba_map_file_bytecode\n//Requires: caml_ba_map_file\nfunction caml_ba_map_file_bytecode(argv,argn){\n  return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5]);\n}\n\n//Provides: jsoo_create_file_extern\nfunction jsoo_create_file_extern(name,content){\n  if(globalThis.jsoo_create_file)\n    globalThis.jsoo_create_file(name,content);\n  else {\n    if(!globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];\n    globalThis.caml_fs_tmp.push({name:name,content:content});\n  }\n  return 0;\n}\n\n//Provides: caml_fs_init\n//Requires: jsoo_create_file\nfunction caml_fs_init (){\n  var tmp=globalThis.caml_fs_tmp\n  if(tmp){\n    for(var i = 0; i < tmp.length; i++){\n      jsoo_create_file(tmp[i].name,tmp[i].content);\n    }\n  }\n  globalThis.jsoo_create_file = jsoo_create_file;\n  globalThis.caml_fs_tmp = [];\n  return 0;\n}\n\n//Provides: caml_create_file\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_create_file(name,content) {\n  var root = resolve_fs_device(name);\n  if(! root.device.register) caml_failwith(\"cannot register file\");\n  root.device.register(root.rest,content);\n  return 0;\n}\n\n\n//Provides: jsoo_create_file\n//Requires: caml_create_file, caml_string_of_jsbytes\nfunction jsoo_create_file(name,content) {\n  var name = caml_string_of_jsbytes(name);\n  var content = caml_string_of_jsbytes(content);\n  return caml_create_file(name, content);\n}\n\n\n//Provides: caml_read_file_content\n//Requires: resolve_fs_device, caml_raise_no_such_file, caml_string_of_array\n//Requires: caml_string_of_jsbytes, caml_jsbytes_of_string\nfunction caml_read_file_content (name) {\n  var name = (typeof name == \"string\")?caml_string_of_jsbytes(name):name;\n  var root = resolve_fs_device(name);\n  if(root.device.exists(root.rest)) {\n    var file = root.device.open(root.rest,{rdonly:1});\n    var len  = file.length();\n    var buf = new Uint8Array(len);\n    file.read(0,buf,0,len);\n    return caml_string_of_array(buf)\n  }\n  caml_raise_no_such_file(caml_jsbytes_of_string(name));\n}\n","//Provides: caml_unix_gettimeofday\n//Alias: unix_gettimeofday\nfunction caml_unix_gettimeofday () {\n  return (new Date()).getTime() / 1000;\n}\n\n//Provides: caml_unix_time\n//Requires: caml_unix_gettimeofday\n//Alias: unix_time\nfunction caml_unix_time () {\n  return Math.floor(caml_unix_gettimeofday ());\n}\n\n//Provides: caml_unix_gmtime\n//Alias: unix_gmtime\nfunction caml_unix_gmtime (t) {\n  var d = new Date (t * 1000);\n  var d_num = d.getTime();\n  var januaryfirst = (new Date(Date.UTC(d.getUTCFullYear(), 0, 1))).getTime();\n  var doy = Math.floor((d_num - januaryfirst) / 86400000);\n  return BLOCK(0, d.getUTCSeconds(), d.getUTCMinutes(), d.getUTCHours(),\n               d.getUTCDate(), d.getUTCMonth(), d.getUTCFullYear() - 1900,\n               d.getUTCDay(), doy,\n               false | 0 /* for UTC daylight savings time is false */)\n}\n\n//Provides: caml_unix_localtime\n//Alias: unix_localtime\nfunction caml_unix_localtime (t) {\n  var d = new Date (t * 1000);\n  var d_num = d.getTime();\n  var januaryfirst = (new Date(d.getFullYear(), 0, 1)).getTime();\n  var doy = Math.floor((d_num - januaryfirst) / 86400000);\n  var jan = new Date(d.getFullYear(), 0, 1);\n  var jul = new Date(d.getFullYear(), 6, 1);\n  var stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n  return BLOCK(0, d.getSeconds(), d.getMinutes(), d.getHours(),\n               d.getDate(), d.getMonth(), d.getFullYear() - 1900,\n               d.getDay(), doy,\n               (d.getTimezoneOffset() < stdTimezoneOffset) | 0 /* daylight savings time  field. */)\n}\n\n//Provides: caml_unix_mktime\n//Requires: caml_unix_localtime\n//Alias: unix_mktime\nfunction caml_unix_mktime(tm){\n  var d = (new Date(tm[6]+1900,tm[5],tm[4],tm[3],tm[2],tm[1])).getTime();\n  var t = Math.floor(d / 1000);\n  var tm2 = caml_unix_localtime(t);\n  return BLOCK(0,t,tm2);\n}\n//Provides: caml_unix_startup const\n//Alias: win_startup\nfunction caml_unix_startup() {}\n\n//Provides: caml_unix_cleanup const\n//Alias: win_cleanup\nfunction caml_unix_cleanup() {}\n\n//Provides: caml_unix_filedescr_of_fd const\n//Alias: win_handle_fd\nfunction caml_unix_filedescr_of_fd(x) {return x;}\n\n//Provides: caml_unix_isatty\n//Requires: fs_node_supported\n//Alias: unix_isatty\nfunction caml_unix_isatty(fileDescriptor) {\n  if(fs_node_supported()) {\n    var tty = require('tty');\n    return tty.isatty(fileDescriptor)?1:0;\n  } else {\n    return 0;\n  }\n}\n\n\n//Provides: caml_unix_isatty\n//Alias: unix_isatty\n//If: browser\nfunction caml_unix_isatty(fileDescriptor) {\n  return 0;\n}\n\n//Provides: make_unix_err_args\n//Requires: caml_string_of_jsstring\nvar unix_error = [\n  /* ===Unix.error===\n   *\n   * This array is in order of the variant in OCaml\n   */\n  \"E2BIG\", \"EACCES\", \"EAGAIN\", \"EBADF\", \"EBUSY\", \"ECHILD\", \"EDEADLK\", \"EDOM\",\n  \"EEXIST\", \"EFAULT\", \"EFBIG\", \"EINTR\", \"EINVAL\", \"EIO\", \"EISDIR\", \"EMFILE\",\n  \"EMLINK\", \"ENAMETOOLONG\", \"ENFILE\", \"ENODEV\", \"ENOENT\", \"ENOEXEC\", \"ENOLCK\",\n  \"ENOMEM\", \"ENOSPC\", \"ENOSYS\", \"ENOTDIR\", \"ENOTEMPTY\", \"ENOTTY\", \"ENXIO\",\n  \"EPERM\", \"EPIPE\", \"ERANGE\", \"EROFS\", \"ESPIPE\", \"ESRCH\", \"EXDEV\", \"EWOULDBLOCK\",\n  \"EINPROGRESS\", \"EALREADY\", \"ENOTSOCK\", \"EDESTADDRREQ\", \"EMSGSIZE\",\n  \"EPROTOTYPE\", \"ENOPROTOOPT\", \"EPROTONOSUPPORT\", \"ESOCKTNOSUPPORT\",\n  \"EOPNOTSUPP\", \"EPFNOSUPPORT\", \"EAFNOSUPPORT\", \"EADDRINUSE\", \"EADDRNOTAVAIL\",\n  \"ENETDOWN\", \"ENETUNREACH\", \"ENETRESET\", \"ECONNABORTED\", \"ECONNRESET\", \"ENOBUFS\",\n  \"EISCONN\", \"ENOTCONN\", \"ESHUTDOWN\", \"ETOOMANYREFS\", \"ETIMEDOUT\", \"ECONNREFUSED\",\n  \"EHOSTDOWN\", \"EHOSTUNREACH\", \"ELOOP\", \"EOVERFLOW\"\n];\nfunction make_unix_err_args(code, syscall, path, errno) {\n  var variant = unix_error.indexOf(code);\n  if (variant < 0) {\n    // Default if undefined\n    if (errno == null) {\n      errno = -9999\n    }\n    // If none of the above variants, fallback to EUNKNOWNERR(int)\n    variant = BLOCK(0, errno);\n  }\n  var args = [\n    variant,\n    caml_string_of_jsstring(syscall || \"\"),\n    caml_string_of_jsstring(path || \"\")\n  ];\n  return args;\n}\n\n//Provides: caml_unix_stat\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_stat\nfunction caml_unix_stat(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.stat) {\n    caml_failwith(\"caml_unix_stat: not implemented\");\n  }\n  return root.device.stat(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_stat_64\n//Requires: caml_unix_stat, caml_int64_of_int32\n//Alias: unix_stat_64\nfunction caml_unix_stat_64(name) {\n  var r = caml_unix_stat(name);\n  r[9] = caml_int64_of_int32(r[9]);\n  return r;\n}\n\n//Provides: caml_unix_lstat\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_lstat\nfunction caml_unix_lstat(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.lstat) {\n    caml_failwith(\"caml_unix_lstat: not implemented\");\n  }\n  return root.device.lstat(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_lstat_64\n//Requires: caml_unix_lstat, caml_int64_of_int32\n//Alias: unix_lstat_64\nfunction caml_unix_lstat_64(name) {\n  var r = caml_unix_lstat(name);\n  r[9] = caml_int64_of_int32(r[9]);\n  return r;\n}\n\n//Provides: caml_unix_mkdir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_mkdir\nfunction caml_unix_mkdir(name, perm) {\n  var root = resolve_fs_device(name);\n  if (!root.device.mkdir) {\n    caml_failwith(\"caml_unix_mkdir: not implemented\");\n  }\n  return root.device.mkdir(root.rest, perm, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_rmdir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_rmdir\nfunction caml_unix_rmdir(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.rmdir) {\n    caml_failwith(\"caml_unix_rmdir: not implemented\");\n  }\n  return root.device.rmdir(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_symlink\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_symlink\nfunction caml_unix_symlink(to_dir, src, dst) {\n  var src_root = resolve_fs_device(src);\n  var dst_root = resolve_fs_device(dst);\n  if(src_root.device != dst_root.device)\n    caml_failwith(\"caml_unix_symlink: cannot symlink between two filesystems\");\n  if (!src_root.device.symlink) {\n    caml_failwith(\"caml_unix_symlink: not implemented\");\n  }\n  return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_readlink\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_readlink\nfunction caml_unix_readlink(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.readlink) {\n    caml_failwith(\"caml_unix_readlink: not implemented\");\n  }\n  return root.device.readlink(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_unlink\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_unlink\nfunction caml_unix_unlink(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.unlink) {\n    caml_failwith(\"caml_unix_unlink: not implemented\");\n  }\n  return root.device.unlink(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_getuid\n//Requires: caml_raise_not_found\n//Alias: unix_getuid\nfunction caml_unix_getuid(unit) {\n  if(globalThis.process && globalThis.process.getuid){\n    return globalThis.process.getuid();\n  }\n  caml_raise_not_found();\n}\n\n//Provides: caml_unix_getpwuid\n//Requires: caml_raise_not_found\n//Alias: unix_getpwuid\nfunction caml_unix_getpwuid(unit) {\n  caml_raise_not_found();\n}\n\n//Provides: caml_unix_has_symlink\n//Requires: fs_node_supported\n//Alias: unix_has_symlink\nfunction caml_unix_has_symlink(unit) {\n  return fs_node_supported()?1:0\n}\n\n//Provides: caml_unix_opendir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_opendir\nfunction caml_unix_opendir(path) {\n  var root = resolve_fs_device(path);\n  if (!root.device.opendir) {\n    caml_failwith(\"caml_unix_opendir: not implemented\");\n  }\n  var dir_handle = root.device.opendir(root.rest, /* raise Unix_error */ true);\n  return { pointer : dir_handle, path: path }\n}\n\n//Provides: caml_unix_readdir\n//Requires: caml_raise_end_of_file\n//Requires: caml_string_of_jsstring\n//Requires: make_unix_err_args, caml_raise_with_args, caml_named_value\n//Alias: unix_readdir\nfunction caml_unix_readdir(dir_handle) {\n  var entry;\n  try {\n      entry = dir_handle.pointer.readSync();\n  } catch (e) {\n      var unix_error = caml_named_value('Unix.Unix_error');\n      caml_raise_with_args(unix_error, make_unix_err_args(\"EBADF\", \"readdir\", dir_handle.path));\n  }\n  if (entry === null) {\n      caml_raise_end_of_file();\n  } else {\n      return caml_string_of_jsstring(entry.name);\n  }\n}\n\n//Provides: caml_unix_closedir\n//Requires: make_unix_err_args, caml_raise_with_args, caml_named_value\n//Alias: unix_closedir\nfunction caml_unix_closedir(dir_handle) {\n  try {\n      dir_handle.pointer.closeSync();\n  } catch (e) {\n      var unix_error = caml_named_value('Unix.Unix_error');\n      caml_raise_with_args(unix_error, make_unix_err_args(\"EBADF\", \"closedir\", dir_handle.path));\n  }\n}\n\n//Provides: caml_unix_rewinddir\n//Requires: caml_unix_closedir, caml_unix_opendir\n//Alias: unix_rewinddir\nfunction caml_unix_rewinddir(dir_handle) {\n  caml_unix_closedir(dir_handle);\n  var new_dir_handle = caml_unix_opendir(dir_handle.path);\n  dir_handle.pointer = new_dir_handle.pointer;\n  return 0;\n}\n\n//Provides: caml_unix_findfirst\n//Requires: caml_jsstring_of_string, caml_string_of_jsstring\n//Requires: caml_unix_opendir, caml_unix_readdir\n//Alias: win_findfirst\nfunction caml_unix_findfirst(path) {\n  // The Windows code adds this glob to the path, so we need to remove it\n  var path_js = caml_jsstring_of_string(path);\n  path_js = path_js.replace(/(^|[\\\\\\/])\\*\\.\\*$/, \"\");\n  path = caml_string_of_jsstring(path_js);\n  // *.* is now stripped\n  var dir_handle = caml_unix_opendir(path);\n  var first_entry = caml_unix_readdir(dir_handle);\n  // The Windows bindings type dir_handle as an `int` but it's not in JS\n  return [0, first_entry, dir_handle];\n}\n\n//Provides: caml_unix_findnext\n//Requires: caml_unix_readdir\n//Alias: win_findnext\nfunction caml_unix_findnext(dir_handle) {\n  return caml_unix_readdir(dir_handle);\n}\n\n//Provides: caml_unix_findclose\n//Requires: caml_unix_closedir\n//Alias: win_findclose\nfunction caml_unix_findclose(dir_handle) {\n  return caml_unix_closedir(dir_handle);\n}\n\n\n//Provides: caml_unix_inet_addr_of_string const\n//Alias: unix_inet_addr_of_string\nfunction caml_unix_inet_addr_of_string () {return 0;}\n\n\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: MlFakeDevice\n//Requires: MlFakeFile, MlFakeFd, caml_create_bytes\n//Requires: caml_raise_sys_error, caml_raise_no_such_file\n//Requires: caml_string_of_jsbytes, caml_string_of_jsstring\n//Requires: caml_bytes_of_array, caml_bytes_of_string, caml_bytes_of_jsbytes\n//Requires: caml_is_ml_bytes, caml_is_ml_string\n//Requires: caml_named_value, caml_raise_with_args, caml_named_values\n//Requires: make_unix_err_args\nfunction MlFakeDevice (root, f) {\n  this.content={};\n  this.root = root;\n  this.lookupFun = f;\n}\nMlFakeDevice.prototype.nm = function(name) {\n  return (this.root + name);\n}\nMlFakeDevice.prototype.create_dir_if_needed = function(name) {\n  var comp = name.split(\"/\");\n  var res = \"\";\n  for(var i = 0; i < comp.length - 1; i++){\n    res += comp[i] + \"/\";\n    if(this.content[res]) continue;\n    this.content[res] = Symbol(\"directory\");\n  }\n}\nMlFakeDevice.prototype.slash = function(name){\n  return /\\/$/.test(name)?name:(name + \"/\");\n}\nMlFakeDevice.prototype.lookup = function(name) {\n  if(!this.content[name] && this.lookupFun) {\n    var res = this.lookupFun(caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));\n    if(res !== 0) {\n      this.create_dir_if_needed(name);\n      this.content[name]=new MlFakeFile(caml_bytes_of_string(res[1]));\n    }\n  }\n}\nMlFakeDevice.prototype.exists = function(name) {\n  // The root of the device exists\n  if(name == \"\") return 1;\n  // Check if a directory exists\n  var name_slash = this.slash(name);\n  if(this.content[name_slash]) return 1;\n  // Check if a file exists\n  this.lookup(name);\n  return this.content[name]?1:0;\n}\nMlFakeDevice.prototype.isFile = function(name) {\n  if(this.exists(name) && !this.is_dir(name)) {\n    return 1\n  }\n  else {\n    return 0\n  }\n}\nMlFakeDevice.prototype.mkdir = function(name,mode, raise_unix) {\n  var unix_error = raise_unix && caml_named_value('Unix.Unix_error');\n  if(this.exists(name)) {\n    if (unix_error) {\n      caml_raise_with_args(unix_error, make_unix_err_args(\"EEXIST\", \"mkdir\", this.nm(name)));\n    }\n    else {\n      caml_raise_sys_error(name + \": File exists\");\n    }\n  }\n  var parent = /^(.*)\\/[^/]+/.exec(name);\n  parent = (parent && parent[1]) || '';\n  if(!this.exists(parent)){\n    if (unix_error) {\n      caml_raise_with_args(unix_error, make_unix_err_args(\"ENOENT\", \"mkdir\", this.nm(parent)));\n    }\n    else {\n      caml_raise_sys_error(parent + \": No such file or directory\");\n    }\n  }\n  if(!this.is_dir(parent)){\n    if (unix_error) {\n      caml_raise_with_args(unix_error, make_unix_err_args(\"ENOTDIR\", \"mkdir\", this.nm(parent)));\n    }\n    else {\n      caml_raise_sys_error(parent + \": Not a directory\");\n    }\n  }\n  this.create_dir_if_needed(this.slash(name));\n}\nMlFakeDevice.prototype.rmdir = function(name, raise_unix) {\n  var unix_error = raise_unix && caml_named_value('Unix.Unix_error');\n  var name_slash = (name == \"\")?\"\":(this.slash(name));\n  var r = new RegExp(\"^\" + name_slash + \"([^/]+)\");\n  if(!this.exists(name)) {\n    if (unix_error) {\n      caml_raise_with_args(unix_error, make_unix_err_args(\"ENOENT\", \"rmdir\", this.nm(name)));\n    }\n    else {\n      caml_raise_sys_error(name + \": No such file or directory\");\n    }\n  }\n  if(!this.is_dir(name)) {\n    if (unix_error) {\n      caml_raise_with_args(unix_error, make_unix_err_args(\"ENOTDIR\", \"rmdir\", this.nm(name)));\n    }\n    else {\n      caml_raise_sys_error(name + \": Not a directory\");\n    }\n  }\n  for(var n in this.content) {\n    if(n.match(r)) {\n      if (unix_error) {\n        caml_raise_with_args(unix_error, make_unix_err_args(\"ENOTEMPTY\", \"rmdir\", this.nm(name)));\n      } else {\n        caml_raise_sys_error(this.nm(name) + \": Directory not empty\");\n      }\n    }\n  }\n  delete this.content[name_slash];\n}\nMlFakeDevice.prototype.readdir = function(name) {\n  var name_slash = (name == \"\")?\"\":(this.slash(name));\n  if(!this.exists(name)) {\n    caml_raise_sys_error(name + \": No such file or directory\");\n  }\n  if(!this.is_dir(name)) {\n    caml_raise_sys_error(name + \": Not a directory\");\n  }\n  var r = new RegExp(\"^\" + name_slash + \"([^/]+)\");\n  var seen = {}\n  var a = [];\n  for(var n in this.content) {\n    var m = n.match(r);\n    if(m && !seen[m[1]]) {seen[m[1]] = true; a.push(m[1])}\n  }\n  return a;\n}\nMlFakeDevice.prototype.opendir = function(name, raise_unix) {\n  var unix_error = raise_unix && caml_named_value('Unix.Unix_error');\n\n  var a = this.readdir(name);\n  var c = false;\n  var i = 0;\n  return { readSync : (function () {\n    if (c) {\n      if (unix_error) {\n        caml_raise_with_args(unix_error, make_unix_err_args(\"EBADF\", \"closedir\", this.nm(name)));\n      }\n      else {\n        caml_raise_sys_error(name + \": closedir failed\");\n      }\n    }\n    if(i == a.length) return null;\n    var entry = a[i];\n    i++;\n    return { name: entry }\n  })\n    , closeSync: (function () {\n      if (c) {\n        if (unix_error) {\n          caml_raise_with_args(unix_error, make_unix_err_args(\"EBADF\", \"closedir\", this.nm(name)));\n        }\n        else {\n          caml_raise_sys_error(name + \": closedir failed\");\n        }\n      }\n      c = true;\n      a = [];\n    })\n  }\n}\nMlFakeDevice.prototype.is_dir = function(name) {\n  if(name == \"\")  return true;\n  var name_slash = this.slash(name);\n  return this.content[name_slash]?1:0;\n}\nMlFakeDevice.prototype.unlink = function(name) {\n  var ok = this.content[name]?true:false;\n  delete this.content[name];\n  return ok;\n}\nMlFakeDevice.prototype.open = function(name, f) {\n  var file;\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_text and Open_binary are not compatible\");\n  this.lookup(name);\n  if (this.content[name]) {\n    if (this.is_dir(name)) caml_raise_sys_error(this.nm(name) + \" : is a directory\");\n    if (f.create && f.excl) caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n    file = this.content[name];\n    if(f.truncate) file.truncate();\n  } else if (f.create) {\n    this.create_dir_if_needed(name);\n    this.content[name] = new MlFakeFile(caml_create_bytes(0));\n    file = this.content[name];\n  } else {\n    caml_raise_no_such_file (this.nm(name));\n  }\n  return new MlFakeFd(this.nm(name), file, f);\n}\n\nMlFakeDevice.prototype.open = function(name, f) {\n  var file;\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_text and Open_binary are not compatible\");\n  this.lookup(name);\n  if (this.content[name]) {\n    if (this.is_dir(name)) caml_raise_sys_error(this.nm(name) + \" : is a directory\");\n    if (f.create && f.excl) caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n    file = this.content[name];\n    if(f.truncate) file.truncate();\n  } else if (f.create) {\n    this.create_dir_if_needed(name);\n    this.content[name] = new MlFakeFile(caml_create_bytes(0));\n    file = this.content[name];\n  } else {\n    caml_raise_no_such_file (this.nm(name));\n  }\n  return new MlFakeFd(this.nm(name), file, f);\n}\n\nMlFakeDevice.prototype.register= function (name,content){\n  var file;\n  if(this.content[name]) caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n  if(caml_is_ml_bytes(content))\n    file = new MlFakeFile(content);\n  if(caml_is_ml_string(content))\n    file = new MlFakeFile(caml_bytes_of_string(content));\n  else if(content instanceof Array)\n    file = new MlFakeFile(caml_bytes_of_array(content));\n  else if(typeof content === \"string\")\n    file = new MlFakeFile(caml_bytes_of_jsbytes(content));\n  else if(content.toString) {\n    var bytes = caml_bytes_of_string(caml_string_of_jsstring(content.toString()));\n    file = new MlFakeFile(bytes);\n  }\n  if(file){\n    this.create_dir_if_needed(name);\n    this.content[name] = file;\n  }\n  else caml_raise_sys_error(this.nm(name) + \" : registering file with invalid content type\");\n}\n\nMlFakeDevice.prototype.constructor = MlFakeDevice\n\n//Provides: MlFakeFile\n//Requires: MlFile\n//Requires: caml_create_bytes, caml_ml_bytes_length, caml_blit_bytes\n//Requires: caml_uint8_array_of_bytes, caml_bytes_of_array\nfunction MlFakeFile(content){\n  this.data = content;\n}\nMlFakeFile.prototype = new MlFile ();\nMlFakeFile.prototype.constructor = MlFakeFile\nMlFakeFile.prototype.truncate = function(len){\n  var old = this.data;\n  this.data = caml_create_bytes(len|0);\n  caml_blit_bytes(old, 0, this.data, 0, len);\n}\nMlFakeFile.prototype.length = function () {\n  return caml_ml_bytes_length(this.data);\n}\nMlFakeFile.prototype.write = function(offset,buf,pos,len){\n  var clen = this.length();\n  if(offset + len >= clen) {\n    var new_str = caml_create_bytes(offset + len);\n    var old_data = this.data;\n    this.data = new_str;\n    caml_blit_bytes(old_data, 0, this.data, 0, clen);\n  }\n  caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);\n  return 0\n}\nMlFakeFile.prototype.read = function(offset,buf,pos,len){\n  var clen = this.length();\n  if(offset + len >= clen) {\n    len = clen - offset;\n  }\n  if(len) {\n    var data = caml_create_bytes(len|0);\n    caml_blit_bytes(this.data, offset, data, 0, len);\n    buf.set(caml_uint8_array_of_bytes(data), pos);\n  }\n  return len\n}\n\n\n//Provides: MlFakeFd_out\n//Requires: MlFakeFile, caml_create_bytes, caml_blit_bytes, caml_bytes_of_array\n//Requires: caml_raise_sys_error\nfunction MlFakeFd_out(fd,flags) {\n  MlFakeFile.call(this, caml_create_bytes(0));\n  this.log = (function (s) { return 0 });\n  if(fd == 1 && typeof console.log == \"function\")\n    this.log = console.log;\n  else if(fd == 2 && typeof console.error == \"function\")\n    this.log = console.error;\n  else if(typeof console.log == \"function\")\n    this.log = console.log\n  this.flags = flags;\n}\nMlFakeFd_out.prototype.length = function() { return 0 }\nMlFakeFd_out.prototype.write = function (offset,buf,pos,len) {\n  if(this.log) {\n    if(len > 0\n       && pos >= 0\n       && pos+len <= buf.length\n       && buf[pos+len-1] == 10)\n      len --;\n    // Do not output the last \\n if present\n    // as console logging display a newline at the end\n    var src = caml_create_bytes(len);\n    caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);\n    this.log(src.toUtf16());\n    return 0;\n  }\n  caml_raise_sys_error(this.fd  + \": file descriptor already closed\");\n}\nMlFakeFd_out.prototype.read = function (offset, buf, pos, len) {\n  caml_raise_sys_error(this.fd  + \": file descriptor is write only\");\n}\nMlFakeFd_out.prototype.close = function () {\n  this.log = undefined;\n}\n\n\n//Provides: MlFakeFd\n//Requires: MlFakeFile\n//Requires: caml_raise_sys_error\nfunction MlFakeFd(name, file,flags) {\n  this.file = file;\n  this.name = name;\n  this.flags = flags;\n}\n\nMlFakeFd.prototype.err_closed = function () {\n  caml_raise_sys_error(this.name  + \": file descriptor already closed\");\n}\nMlFakeFd.prototype.length = function() {\n  if(this.file) return this.file.length ()\n  this.err_closed();\n}\nMlFakeFd.prototype.write = function (offset,buf,pos,len) {\n  if(this.file) return this.file.write(offset,buf,pos,len)\n  this.err_closed();\n}\nMlFakeFd.prototype.read = function (offset, buf, pos, len) {\n  if(this.file) return this.file.read(offset, buf, pos, len)\n  this.err_closed();\n}\nMlFakeFd.prototype.close = function () {\n  this.file = undefined;\n}\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib: code specific to Js_of_ocaml\n\n//Provides: caml_js_on_ie const\nfunction caml_js_on_ie () {\n  var ua =\n      (globalThis.navigator&&globalThis.navigator.userAgent)\n      ?globalThis.navigator.userAgent:\"\";\n  return ua.indexOf(\"MSIE\") != -1 && ua.indexOf(\"Opera\") != 0;\n}\n\n//Provides: caml_js_html_escape const (const)\nvar caml_js_regexps = { amp:/&/g, lt:/</g, quot:/\\\"/g, all:/[&<\\\"]/ };\nfunction caml_js_html_escape (s) {\n  if (!caml_js_regexps.all.test(s)) return s;\n  return s.replace(caml_js_regexps.amp, \"&amp;\")\n    .replace(caml_js_regexps.lt, \"&lt;\")\n    .replace(caml_js_regexps.quot, \"&quot;\");\n}\n\n//Provides: caml_js_html_entities\n//Requires: caml_failwith\nfunction caml_js_html_entities(s) {\n  var entity = /^&#?[0-9a-zA-Z]+;$/\n  if(s.match(entity))\n  {\n    var str, temp = document.createElement('p');\n    temp.innerHTML= s;\n    str= temp.textContent || temp.innerText;\n    temp=null;\n    return str;\n  }\n  else {\n    caml_failwith(\"Invalid entity \" + s);\n  }\n}\n\n//Provides: caml_js_get_console const\nfunction caml_js_get_console () {\n  var c = console;\n  var m = [\"log\", \"debug\", \"info\", \"warn\", \"error\", \"assert\", \"dir\", \"dirxml\",\n           \"trace\", \"group\", \"groupCollapsed\", \"groupEnd\", \"time\", \"timeEnd\"];\n  function f () {}\n  for (var i = 0; i < m.length; i++) if (!c[m[i]]) c[m[i]]=f;\n  return c;\n}\n\n//Provides: caml_xmlhttprequest_create\n//Requires: caml_failwith\n//Weakdef\nfunction caml_xmlhttprequest_create(unit){\n  if(typeof globalThis.XMLHttpRequest !== 'undefined') {\n    try { return new globalThis.XMLHttpRequest } catch (e) { };\n  }\n  if(typeof globalThis.activeXObject !== 'undefined') {\n    try { return new globalThis.activeXObject(\"Msxml2.XMLHTTP\") } catch(e){ };\n    try { return new globalThis.activeXObject(\"Msxml3.XMLHTTP\") } catch(e){ };\n    try { return new globalThis.activeXObject(\"Microsoft.XMLHTTP\") } catch(e){ };\n  }\n  caml_failwith(\"Cannot create a XMLHttpRequest\");\n}\n\n//Provides: caml_js_error_of_exception\nfunction caml_js_error_of_exception(exn) {\n  if(exn.js_error) { return exn.js_error; }\n  return null;\n}\n","/***********************************************************************/\n/*                                                                     */\n/*                           Objective Caml                            */\n/*                                                                     */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */\n/*                                                                     */\n/*  Copyright 1996 Institut National de Recherche en Informatique et   */\n/*  en Automatique.  All rights reserved.  This file is distributed    */\n/*  under the terms of the GNU Lesser General Public License, with     */\n/*  the special exception on linking described in file ../LICENSE.     */\n/*                                                                     */\n/***********************************************************************/\n\n/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */\n\n/* The table-driven automaton for lexers generated by camllex. */\n\n//Provides: caml_lex_array\n//Requires: caml_jsbytes_of_string\nfunction caml_lex_array(s) {\n  s = caml_jsbytes_of_string(s);\n  var l = s.length / 2;\n  var a = new Array(l);\n  for (var i = 0; i < l; i++)\n    a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;\n  return a;\n}\n\n//Provides: caml_lex_engine\n//Requires: caml_failwith, caml_lex_array, caml_uint8_array_of_bytes\nfunction caml_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n\n  var c, state = start_state;\n\n  var buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) return -base-1;\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n      */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n\n/***********************************************/\n/* New lexer engine, with memory of positions  */\n/***********************************************/\n\n//Provides: caml_new_lex_engine\n//Requires: caml_failwith, caml_lex_array\n//Requires: caml_jsbytes_of_string, caml_uint8_array_of_bytes\nfunction caml_lex_run_mem(s, i, mem, curr_pos) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = curr_pos;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_lex_run_tag(s, i, mem) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return ;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = -1;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_new_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_mem = 10;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n  var lex_base_code = 6;\n  var lex_backtrk_code = 7;\n  var lex_default_code = 8;\n  var lex_trans_code = 9;\n  var lex_check_code = 10;\n  var lex_code = 11;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n  if (!tbl.lex_default_code) {\n    tbl.lex_base_code =    caml_lex_array (tbl[lex_base_code]);\n    tbl.lex_backtrk_code = caml_lex_array (tbl[lex_backtrk_code]);\n    tbl.lex_check_code =   caml_lex_array (tbl[lex_check_code]);\n    tbl.lex_trans_code =   caml_lex_array (tbl[lex_trans_code]);\n    tbl.lex_default_code = caml_lex_array (tbl[lex_default_code]);\n  }\n  if (tbl.lex_code == null) tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);\n\n  var c, state = start_state;\n\n  var buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) {\n      var pc_off = tbl.lex_base_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      return -base-1;\n    }\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      var pc_off = tbl.lex_backtrk_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    var pstate = state ;\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* If some transition, get and perform memory moves */\n      var base_code = tbl.lex_base_code[pstate], pc_off;\n      if (tbl.lex_check_code[base_code + c] == pstate)\n        pc_off = tbl.lex_trans_code[base_code + c];\n      else\n        pc_off = tbl.lex_default_code[pstate];\n      if (pc_off > 0)\n        caml_lex_run_mem\n      (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n      */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_md5_chan\n//Requires: caml_string_of_array\n//Requires: caml_raise_end_of_file, caml_ml_input_block\n//Requires: caml_MD5Init, caml_MD5Update, caml_MD5Final\nfunction caml_md5_chan(chanid,toread){\n  var ctx = caml_MD5Init();\n  var buffer = new Uint8Array(4096);\n  if(toread < 0){\n    while(true){\n      var read = caml_ml_input_block(chanid,buffer,0,buffer.length);\n      if(read == 0) break;\n      caml_MD5Update(ctx,buffer.subarray(0, read), read);\n    }\n  } else {\n    while(toread > 0) {\n      var read = caml_ml_input_block(chanid,buffer,0, (toread > buffer.length ? buffer.length : toread));\n      if(read == 0) caml_raise_end_of_file();\n      caml_MD5Update(ctx,buffer.subarray(0, read), read);\n      toread -= read\n    }\n  }\n  return caml_string_of_array(caml_MD5Final(ctx));\n}\n\n//Provides: caml_md5_string\n//Requires: caml_bytes_of_string, caml_md5_bytes\nfunction caml_md5_string(s, ofs, len) {\n  return caml_md5_bytes(caml_bytes_of_string(s),ofs,len);\n}\n\n//Provides: caml_MD5Transform\nvar caml_MD5Transform = (function () {\n  function add (x, y) { return (x + y) | 0; }\n  function xx(q,a,b,x,s,t) {\n    a = add(add(a, q), add(x, t));\n    return add((a << s) | (a >>> (32 - s)), b);\n  }\n  function ff(a,b,c,d,x,s,t) {\n    return xx((b & c) | ((~b) & d), a, b, x, s, t);\n  }\n  function gg(a,b,c,d,x,s,t) {\n    return xx((b & d) | (c & (~d)), a, b, x, s, t);\n  }\n  function hh(a,b,c,d,x,s,t) { return xx(b ^ c ^ d, a, b, x, s, t); }\n  function ii(a,b,c,d,x,s,t) { return xx(c ^ (b | (~d)), a, b, x, s, t); }\n\n  return function (w, buffer) {\n    var a = w[0], b = w[1], c = w[2], d = w[3];\n\n    a = ff(a, b, c, d, buffer[ 0], 7, 0xD76AA478);\n    d = ff(d, a, b, c, buffer[ 1], 12, 0xE8C7B756);\n    c = ff(c, d, a, b, buffer[ 2], 17, 0x242070DB);\n    b = ff(b, c, d, a, buffer[ 3], 22, 0xC1BDCEEE);\n    a = ff(a, b, c, d, buffer[ 4], 7, 0xF57C0FAF);\n    d = ff(d, a, b, c, buffer[ 5], 12, 0x4787C62A);\n    c = ff(c, d, a, b, buffer[ 6], 17, 0xA8304613);\n    b = ff(b, c, d, a, buffer[ 7], 22, 0xFD469501);\n    a = ff(a, b, c, d, buffer[ 8], 7, 0x698098D8);\n    d = ff(d, a, b, c, buffer[ 9], 12, 0x8B44F7AF);\n    c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);\n    b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);\n    a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);\n    d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);\n    c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);\n    b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);\n\n    a = gg(a, b, c, d, buffer[ 1], 5, 0xF61E2562);\n    d = gg(d, a, b, c, buffer[ 6], 9, 0xC040B340);\n    c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);\n    b = gg(b, c, d, a, buffer[ 0], 20, 0xE9B6C7AA);\n    a = gg(a, b, c, d, buffer[ 5], 5, 0xD62F105D);\n    d = gg(d, a, b, c, buffer[10], 9, 0x02441453);\n    c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);\n    b = gg(b, c, d, a, buffer[ 4], 20, 0xE7D3FBC8);\n    a = gg(a, b, c, d, buffer[ 9], 5, 0x21E1CDE6);\n    d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);\n    c = gg(c, d, a, b, buffer[ 3], 14, 0xF4D50D87);\n    b = gg(b, c, d, a, buffer[ 8], 20, 0x455A14ED);\n    a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);\n    d = gg(d, a, b, c, buffer[ 2], 9, 0xFCEFA3F8);\n    c = gg(c, d, a, b, buffer[ 7], 14, 0x676F02D9);\n    b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);\n\n    a = hh(a, b, c, d, buffer[ 5], 4, 0xFFFA3942);\n    d = hh(d, a, b, c, buffer[ 8], 11, 0x8771F681);\n    c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);\n    b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);\n    a = hh(a, b, c, d, buffer[ 1], 4, 0xA4BEEA44);\n    d = hh(d, a, b, c, buffer[ 4], 11, 0x4BDECFA9);\n    c = hh(c, d, a, b, buffer[ 7], 16, 0xF6BB4B60);\n    b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);\n    a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);\n    d = hh(d, a, b, c, buffer[ 0], 11, 0xEAA127FA);\n    c = hh(c, d, a, b, buffer[ 3], 16, 0xD4EF3085);\n    b = hh(b, c, d, a, buffer[ 6], 23, 0x04881D05);\n    a = hh(a, b, c, d, buffer[ 9], 4, 0xD9D4D039);\n    d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);\n    c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);\n    b = hh(b, c, d, a, buffer[ 2], 23, 0xC4AC5665);\n\n    a = ii(a, b, c, d, buffer[ 0], 6, 0xF4292244);\n    d = ii(d, a, b, c, buffer[ 7], 10, 0x432AFF97);\n    c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);\n    b = ii(b, c, d, a, buffer[ 5], 21, 0xFC93A039);\n    a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);\n    d = ii(d, a, b, c, buffer[ 3], 10, 0x8F0CCC92);\n    c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);\n    b = ii(b, c, d, a, buffer[ 1], 21, 0x85845DD1);\n    a = ii(a, b, c, d, buffer[ 8], 6, 0x6FA87E4F);\n    d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);\n    c = ii(c, d, a, b, buffer[ 6], 15, 0xA3014314);\n    b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);\n    a = ii(a, b, c, d, buffer[ 4], 6, 0xF7537E82);\n    d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);\n    c = ii(c, d, a, b, buffer[ 2], 15, 0x2AD7D2BB);\n    b = ii(b, c, d, a, buffer[ 9], 21, 0xEB86D391);\n\n    w[0] = add(a, w[0]);\n    w[1] = add(b, w[1]);\n    w[2] = add(c, w[2]);\n    w[3] = add(d, w[3]);\n  }})()\n\n//Provides: caml_MD5Init\nfunction caml_MD5Init() {\n  var buffer = new ArrayBuffer(64);\n  var b32 = new Uint32Array(buffer);\n  var b8 = new Uint8Array(buffer);\n  return {len:0,\n          w:new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),\n          b32:b32,\n          b8:b8}\n}\n\n//Provides: caml_MD5Update\n//Requires: caml_MD5Transform\nfunction caml_MD5Update(ctx, input, input_len){\n  var in_buf = ctx.len & 0x3f;\n  var input_pos = 0;\n  ctx.len += input_len;\n  if(in_buf){\n    var missing = 64 - in_buf;\n    if(input_len < missing) {\n      ctx.b8.set(input.subarray(0,input_len),in_buf);\n      return\n    }\n    ctx.b8.set(input.subarray(0,missing),in_buf);\n    caml_MD5Transform(ctx.w, ctx.b32);\n    input_len -= missing;\n    input_pos += missing;\n  }\n  while(input_len >= 64){\n    ctx.b8.set(input.subarray(input_pos,input_pos + 64), 0);\n    caml_MD5Transform(ctx.w, ctx.b32);\n    input_len -= 64;\n    input_pos += 64;\n  }\n  if(input_len)\n    ctx.b8.set(input.subarray(input_pos,input_pos + input_len), 0);\n}\n\n//Provides: caml_MD5Final\n//Requires: caml_MD5Transform\nfunction caml_MD5Final(ctx){\n  var in_buf = ctx.len & 0x3f;\n  ctx.b8[in_buf] = 0x80;\n  in_buf ++;\n  if(in_buf > 56) {\n    for(var j = in_buf; j < 64; j++){\n      ctx.b8[j] = 0;\n    }\n    caml_MD5Transform(ctx.w, ctx.b32);\n    for(var j = 0; j < 56; j++){\n      ctx.b8[j] = 0;\n    }\n  } else {\n    for(var j = in_buf; j < 56; j++){\n      ctx.b8[j] = 0;\n    }\n  }\n  ctx.b32[14] = ctx.len << 3;\n  ctx.b32[15] = (ctx.len >> 29) & 0x1FFFFFFF;\n  caml_MD5Transform(ctx.w, ctx.b32);\n  var t = new Uint8Array(16);\n  for (var i = 0; i < 4; i++)\n    for (var j = 0; j < 4; j++)\n      t[i * 4 + j] = (ctx.w[i] >> (8 * j)) & 0xFF;\n  return t;\n}\n\n\n//Provides: caml_md5_bytes\n//Requires: caml_uint8_array_of_bytes, caml_string_of_array\n//Requires: caml_MD5Init, caml_MD5Update, caml_MD5Final\nfunction caml_md5_bytes(s, ofs, len) {\n  var ctx = caml_MD5Init();\n  var a = caml_uint8_array_of_bytes(s);\n  caml_MD5Update(ctx,a.subarray(ofs, ofs + len), len);\n  return caml_string_of_array(caml_MD5Final(ctx));\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Io\n\n//Provides: caml_sys_fds\nvar caml_sys_fds = new Array(3);\n\n//Provides: caml_sys_close\n//Requires: caml_sys_fds\nfunction caml_sys_close(fd) {\n  var file = caml_sys_fds[fd];\n  if(file) file.close();\n  delete caml_sys_fds[fd];\n  return 0;\n}\n\n\n//Provides: caml_sys_open\n//Requires: caml_raise_sys_error\n//Requires: MlFakeFd_out\n//Requires: resolve_fs_device\n//Requires: caml_jsbytes_of_string\n//Requires: fs_node_supported\n//Requires: caml_sys_fds\n//Requires: caml_sys_open_for_node\nfunction caml_sys_open_internal(file,idx) {\n  if(idx == undefined){\n    idx = caml_sys_fds.length;\n  }\n  caml_sys_fds[idx] = file;\n  return idx | 0;\n}\nfunction caml_sys_open (name, flags, _perms) {\n  var f = {};\n  while(flags){\n    switch(flags[1]){\n    case 0: f.rdonly = 1;break;\n    case 1: f.wronly = 1;break;\n    case 2: f.append = 1;break;\n    case 3: f.create = 1;break;\n    case 4: f.truncate = 1;break;\n    case 5: f.excl = 1; break;\n    case 6: f.binary = 1;break;\n    case 7: f.text = 1;break;\n    case 8: f.nonblock = 1;break;\n    }\n    flags=flags[2];\n  }\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(caml_jsbytes_of_string(name) + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(caml_jsbytes_of_string(name) + \" : flags Open_text and Open_binary are not compatible\");\n  var root = resolve_fs_device(name);\n  var file = root.device.open(root.rest,f);\n  return caml_sys_open_internal (file, undefined);\n}\n(function () {\n  function file(fd, flags) {\n    if(fs_node_supported()) {\n      return caml_sys_open_for_node(fd, flags);\n    }\n    else\n      return new MlFakeFd_out(fd, flags)\n  }\n  caml_sys_open_internal(file(0,{rdonly:1,altname:\"/dev/stdin\",isCharacterDevice:true}), 0);\n  caml_sys_open_internal(file(1,{buffered:2,wronly:1,isCharacterDevice:true}), 1);\n  caml_sys_open_internal(file(2,{buffered:2,wronly:1,isCharacterDevice:true}), 2);\n})()\n\n\n// ocaml Channels\n\n//Provides: caml_ml_set_channel_name\n//Requires: caml_ml_channels\nfunction caml_ml_set_channel_name(chanid, name) {\n  var chan = caml_ml_channels[chanid];\n  chan.name = name;\n  return 0;\n}\n\n//Provides: caml_ml_channels\nvar caml_ml_channels = new Array();\n\n//Provides: caml_ml_out_channels_list\n//Requires: caml_ml_channels\nfunction caml_ml_out_channels_list () {\n  var l = 0;\n  for(var c = 0; c < caml_ml_channels.length; c++){\n    if(caml_ml_channels[c] && caml_ml_channels[c].opened && caml_ml_channels[c].out)\n      l=[0,caml_ml_channels[c].fd,l];\n  }\n  return l;\n}\n\n\n//Provides: caml_ml_open_descriptor_out\n//Requires: caml_ml_channels, caml_sys_fds\n//Requires: caml_raise_sys_error\n//Requires: caml_sys_open\nfunction caml_ml_open_descriptor_out (fd) {\n  var file = caml_sys_fds[fd];\n  if(file.flags.rdonly) caml_raise_sys_error(\"fd \"+ fd + \" is readonly\");\n  var buffered = (file.flags.buffered !== undefined) ? file.flags.buffered : 1;\n  var channel = {\n    file:file,\n    offset:file.flags.append?file.length():0,\n    fd:fd,\n    opened:true,\n    out:true,\n    buffer_curr:0,\n    buffer:new Uint8Array(65536),\n    buffered:buffered\n  };\n  caml_ml_channels[channel.fd]=channel;\n  return channel.fd;\n}\n\n//Provides: caml_ml_open_descriptor_in\n//Requires: caml_ml_channels, caml_sys_fds\n//Requires: caml_raise_sys_error\n//Requires: caml_sys_open\nfunction caml_ml_open_descriptor_in (fd)  {\n  var file = caml_sys_fds[fd];\n  if(file.flags.wronly) caml_raise_sys_error(\"fd \"+ fd + \" is writeonly\");\n  var refill = null;\n  var channel = {\n    file:file,\n    offset:file.flags.append?file.length():0,\n    fd:fd,\n    opened:true,\n    out: false,\n    buffer_curr:0,\n    buffer_max:0,\n    buffer:new Uint8Array(65536),\n    refill:refill\n  };\n  caml_ml_channels[channel.fd]=channel;\n  return channel.fd;\n}\n\n\n//Provides: caml_ml_open_descriptor_in_with_flags\n//Requires: caml_ml_open_descriptor_in\n//Version: >= 5.1\nfunction caml_ml_open_descriptor_in_with_flags(fd, flags){\n  return caml_ml_open_descriptor_in(fd);\n}\n\n//Provides: caml_ml_open_descriptor_out_with_flags\n//Requires: caml_ml_open_descriptor_out\n//Version: >= 5.1\nfunction caml_ml_open_descriptor_out_with_flags(fd, flags){\n  return caml_ml_open_descriptor_out(fd);\n}\n\n//Provides: caml_channel_descriptor\n//Requires: caml_ml_channels\n//Alias: win_filedescr_of_channel\nfunction caml_channel_descriptor(chanid){\n  var chan = caml_ml_channels[chanid];\n  return chan.fd;\n}\n\n//Provides: caml_ml_set_binary_mode\n//Requires: caml_ml_channels\nfunction caml_ml_set_binary_mode(chanid,mode){\n  var chan = caml_ml_channels[chanid];\n  chan.file.flags.text = !mode\n  chan.file.flags.binary = mode\n  return 0;\n}\n\n//Input from in_channel\n\n//Provides: caml_ml_close_channel\n//Requires: caml_ml_flush, caml_ml_channels\n//Requires: caml_sys_close\nfunction caml_ml_close_channel (chanid) {\n  var chan = caml_ml_channels[chanid];\n  chan.opened = false;\n  caml_sys_close(chan.fd)\n  return 0;\n}\n\n//Provides: caml_ml_channel_size\n//Requires: caml_ml_channels\nfunction caml_ml_channel_size(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return chan.file.length();\n}\n\n//Provides: caml_ml_channel_size_64\n//Requires: caml_int64_of_float,caml_ml_channels\nfunction caml_ml_channel_size_64(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return caml_int64_of_float(chan.file.length ());\n}\n\n//Provides: caml_ml_set_channel_output\n//Requires: caml_ml_channels\nfunction caml_ml_set_channel_output(chanid,f) {\n  var chan = caml_ml_channels[chanid];\n  chan.output = (function (s) {f(s)});\n  return 0;\n}\n\n//Provides: caml_ml_set_channel_refill\n//Requires: caml_ml_channels\nfunction caml_ml_set_channel_refill(chanid,f) {\n  caml_ml_channels[chanid].refill = f;\n  return 0;\n}\n\n//Provides: caml_refill\n//Requires: caml_ml_string_length, caml_uint8_array_of_string\nfunction caml_refill (chan) {\n  if(chan.refill != null){\n    var str = chan.refill();\n    var str_a = caml_uint8_array_of_string(str);\n    if (str_a.length == 0) {\n      chan.refill = null\n    }\n    else {\n      if(chan.buffer.length < chan.buffer_max + str_a.length){\n        var b = new Uint8Array(chan.buffer_max + str_a.length);\n        b.set(chan.buffer);\n        chan.buffer = b;\n      }\n      chan.buffer.set(str_a,chan.buffer_max);\n      chan.offset += str_a.length;\n      chan.buffer_max += str_a.length;\n    }\n  } else {\n    var nread = chan.file.read(chan.offset, chan.buffer, chan.buffer_max, chan.buffer.length - chan.buffer_max);\n    chan.offset += nread;\n    chan.buffer_max += nread;\n  }\n}\n\n//Provides: caml_ml_input\n//Requires: caml_ml_input_block\n//Requires: caml_uint8_array_of_bytes\nfunction caml_ml_input (chanid, b, i, l) {\n  var ba = caml_uint8_array_of_bytes(b);\n  return caml_ml_input_block(chanid, ba, i, l)\n}\n\n//Provides: caml_ml_input_bigarray\n//Requires: caml_ml_input_block\n//Requires: caml_ba_to_typed_array\nfunction caml_ml_input_bigarray (chanid, b, i, l) {\n  var ba = caml_ba_to_typed_array(b);\n  return caml_ml_input_block(chanid, ba, i, l)\n}\n\n//Provides: caml_ml_input_block\n//Requires: caml_refill, caml_ml_channels\nfunction caml_ml_input_block (chanid, ba, i, l) {\n  var chan = caml_ml_channels[chanid];\n  var n = l;\n  var avail = chan.buffer_max - chan.buffer_curr;\n  if(l <= avail) {\n    ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + l), i);\n    chan.buffer_curr += l;\n  }\n  else if(avail > 0) {\n    ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + avail), i);\n    chan.buffer_curr += avail;\n    n = avail;\n  } else {\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n    caml_refill(chan);\n    var avail = chan.buffer_max - chan.buffer_curr;\n    if(n > avail) n = avail;\n    ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + n), i);\n    chan.buffer_curr += n;\n  }\n  return n | 0;\n}\n\n//Provides: caml_input_value\n//Requires: caml_marshal_data_size, caml_input_value_from_bytes, caml_create_bytes, caml_ml_channels, caml_bytes_of_array\n//Requires: caml_refill, caml_failwith, caml_raise_end_of_file\n//Requires: caml_marshal_header_size\nfunction caml_input_value (chanid) {\n  var chan = caml_ml_channels[chanid];\n  var header = new Uint8Array(caml_marshal_header_size);\n  function block(buffer, offset, n) {\n    var r = 0;\n    while(r < n){\n      if(chan.buffer_curr >= chan.buffer_max){\n        chan.buffer_curr = 0;\n        chan.buffer_max = 0;\n        caml_refill(chan);\n      }\n      if (chan.buffer_curr >= chan.buffer_max)\n        break;\n      buffer[offset+r] = chan.buffer[chan.buffer_curr];\n      chan.buffer_curr++;\n      r++;\n    }\n    return r;\n  }\n  var r = block(header, 0, caml_marshal_header_size);\n  if(r == 0)\n    caml_raise_end_of_file();\n  else if (r < caml_marshal_header_size)\n    caml_failwith(\"input_value: truncated object\");\n  var len = caml_marshal_data_size (caml_bytes_of_array(header), 0);\n  var buf = new Uint8Array(len + caml_marshal_header_size);\n  buf.set(header,0);\n  var r = block(buf, caml_marshal_header_size, len)\n  if(r < len)\n    caml_failwith(\"input_value: truncated object \" + r + \"  \" + len);\n  var offset = [0];\n  var res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);\n  chan.offset = chan.offset + offset[0];\n  return res;\n}\n\n//Provides: caml_input_value_to_outside_heap\n//Requires: caml_input_value\nfunction caml_input_value_to_outside_heap(c) {\n  return caml_input_value(c);\n}\n\n//Provides: caml_ml_input_char\n//Requires: caml_raise_end_of_file, caml_array_bound_error\n//Requires: caml_ml_channels, caml_refill\nfunction caml_ml_input_char (chanid) {\n  var chan = caml_ml_channels[chanid];\n  if(chan.buffer_curr >= chan.buffer_max){\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n    caml_refill(chan);\n  }\n  if (chan.buffer_curr >= chan.buffer_max)\n    caml_raise_end_of_file();\n  var res = chan.buffer[chan.buffer_curr];\n  chan.buffer_curr++;\n  return res;\n}\n\n//Provides: caml_ml_input_int\n//Requires: caml_raise_end_of_file\n//Requires: caml_ml_input_char, caml_ml_channels\nfunction caml_ml_input_int (chanid) {\n  var chan = caml_ml_channels[chanid];\n  var res = 0;\n  for(var i = 0; i < 4; i++){\n    res = (res << 8) + caml_ml_input_char(chanid) | 0;\n  }\n  return res | 0;\n}\n\n//Provides: caml_seek_in\n//Requires: caml_raise_sys_error, caml_ml_channels\nfunction caml_seek_in(chanid, pos) {\n  var chan = caml_ml_channels[chanid];\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  if(pos >= chan.offset - chan.buffer_max\n     && pos <= chan.offset\n     && chan.file.flags.binary) {\n    chan.buffer_curr = chan.buffer_max - (chan.offset - pos);\n  } else {\n    chan.offset = pos;\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n  }\n  return 0;\n}\n\n//Provides: caml_ml_seek_in\n//Requires: caml_seek_in\nfunction caml_ml_seek_in(chanid,pos){\n  return caml_seek_in(chanid,pos);\n}\n\n//Provides: caml_ml_seek_in_64\n//Requires: caml_int64_to_float, caml_seek_in\nfunction caml_ml_seek_in_64(chanid,pos){\n  var pos = caml_int64_to_float(pos);\n  return caml_seek_in(chanid, pos);\n}\n\n//Provides: caml_pos_in\n//Requires: caml_ml_channels\nfunction caml_pos_in(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;\n}\n\n//Provides: caml_ml_pos_in\n//Requires: caml_pos_in\nfunction caml_ml_pos_in(chanid) {\n  return caml_pos_in(chanid);\n}\n\n//Provides: caml_ml_pos_in_64\n//Requires: caml_int64_of_float, caml_pos_in\nfunction caml_ml_pos_in_64(chanid) {\n  return caml_int64_of_float(caml_pos_in(chanid));\n}\n\n//Provides: caml_ml_input_scan_line\n//Requires: caml_array_bound_error\n//Requires: caml_ml_channels, caml_refill\nfunction caml_ml_input_scan_line(chanid){\n  var chan = caml_ml_channels[chanid];\n  var p = chan.buffer_curr;\n  do {\n    if(p >= chan.buffer_max) {\n      if(chan.buffer_curr > 0) {\n        chan.buffer.set(chan.buffer.subarray(chan.buffer_curr),0);\n        p -= chan.buffer_curr;\n        chan.buffer_max -= chan.buffer_curr;\n        chan.buffer_curr = 0;\n      }\n      if(chan.buffer_max >= chan.buffer.length) {\n        return -(chan.buffer_max) | 0;\n      }\n      var prev_max = chan.buffer_max;\n      caml_refill (chan);\n      if(prev_max == chan.buffer_max) {\n        return -(chan.buffer_max) | 0;\n      }\n    }\n  } while (chan.buffer[p++] != 10);\n  return (p - chan.buffer_curr) | 0;\n}\n\n//Provides: caml_ml_flush\n//Requires: caml_raise_sys_error, caml_ml_channels\n//Requires: caml_subarray_to_jsbytes\nfunction caml_ml_flush (chanid) {\n  var chan = caml_ml_channels[chanid];\n  if(! chan.opened) caml_raise_sys_error(\"Cannot flush a closed channel\");\n  if(!chan.buffer || chan.buffer_curr == 0) return 0;\n  if(chan.output) {\n    chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));\n  } else {\n    chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);\n  }\n  chan.offset += chan.buffer_curr;\n  chan.buffer_curr = 0;\n  return 0;\n}\n\n//output to out_channel\n\n//Provides: caml_ml_output_ta\n//Requires: caml_ml_flush,caml_ml_bytes_length\n//Requires: caml_raise_sys_error, caml_ml_channels\nfunction caml_ml_output_ta(chanid,buffer,offset,len) {\n  var chan = caml_ml_channels[chanid];\n  if(! chan.opened) caml_raise_sys_error(\"Cannot output to a closed channel\");\n  buffer = buffer.subarray(offset, offset + len);\n  if(chan.buffer_curr + buffer.length > chan.buffer.length) {\n    var b = new Uint8Array(chan.buffer_curr + buffer.length);\n    b.set(chan.buffer);\n    chan.buffer = b\n  }\n  switch(chan.buffered){\n  case 0: // Unbuffered\n    chan.buffer.set(buffer, chan.buffer_curr);\n    chan.buffer_curr += buffer.length;\n    caml_ml_flush (chanid);\n    break\n  case 1: // Buffered (the default)\n    chan.buffer.set(buffer, chan.buffer_curr);\n    chan.buffer_curr += buffer.length;\n    if(chan.buffer_curr >= chan.buffer.length)\n      caml_ml_flush (chanid);\n    break;\n  case 2: // Buffered (only for stdout and stderr)\n    var id = buffer.lastIndexOf(10)\n    if(id < 0) {\n      chan.buffer.set(buffer, chan.buffer_curr);\n      chan.buffer_curr += buffer.length;\n      if(chan.buffer_curr >= chan.buffer.length)\n        caml_ml_flush (chanid);\n    }\n    else {\n      chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);\n      chan.buffer_curr += id + 1;\n      caml_ml_flush (chanid);\n      chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);\n      chan.buffer_curr += buffer.length - id - 1;\n    }\n    break;\n  }\n  return 0;\n}\n\n//Provides: caml_ml_output_bytes\n//Requires: caml_uint8_array_of_bytes, caml_ml_output_ta\nfunction caml_ml_output_bytes(chanid,buffer,offset,len) {\n  var buffer = caml_uint8_array_of_bytes(buffer);\n  return caml_ml_output_ta(chanid,buffer,offset,len);\n}\n\n\n//Provides: caml_ml_output_bigarray\n//Requires: caml_ba_to_typed_array, caml_ml_output_ta\nfunction caml_ml_output_bigarray(chanid,buffer,offset,len) {\n  var buffer = caml_ba_to_typed_array(buffer);\n  return caml_ml_output_ta(chanid,buffer,offset,len);\n}\n\n\n\n//Provides: caml_ml_output\n//Requires: caml_ml_output_bytes, caml_bytes_of_string\nfunction caml_ml_output(chanid,buffer,offset,len){\n  return caml_ml_output_bytes(chanid,caml_bytes_of_string(buffer),offset,len);\n}\n\n//Provides: caml_ml_output_char\n//Requires: caml_ml_output\n//Requires: caml_string_of_jsbytes\nfunction caml_ml_output_char (chanid,c) {\n  var s = caml_string_of_jsbytes(String.fromCharCode(c));\n  caml_ml_output(chanid,s,0,1);\n  return 0;\n}\n\n//Provides: caml_output_value\n//Requires: caml_output_value_to_string, caml_ml_output,caml_ml_string_length\nfunction caml_output_value (chanid,v,flags) {\n  var s = caml_output_value_to_string(v, flags);\n  caml_ml_output(chanid,s,0,caml_ml_string_length(s));\n  return 0;\n}\n\n\n//Provides: caml_seek_out\n//Requires: caml_ml_channels, caml_ml_flush\nfunction caml_seek_out(chanid, pos){\n  caml_ml_flush(chanid);\n  var chan = caml_ml_channels[chanid];\n  chan.offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_out\n//Requires: caml_seek_out\nfunction caml_ml_seek_out(chanid,pos){\n  return caml_seek_out(chanid, pos);\n}\n//Provides: caml_ml_seek_out_64\n//Requires: caml_int64_to_float, caml_seek_out\nfunction caml_ml_seek_out_64(chanid,pos){\n  var pos = caml_int64_to_float(pos);\n  return caml_seek_out(chanid, pos);\n}\n\n//Provides: caml_pos_out\n//Requires: caml_ml_channels, caml_ml_flush\nfunction caml_pos_out(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return chan.offset + chan.buffer_curr\n}\n\n//Provides: caml_ml_pos_out\n//Requires: caml_pos_out\nfunction caml_ml_pos_out(chanid) {\n  return caml_pos_out(chanid);\n}\n\n//Provides: caml_ml_pos_out_64\n//Requires: caml_int64_of_float, caml_pos_out\nfunction caml_ml_pos_out_64(chanid) {\n  return caml_int64_of_float (caml_pos_out(chanid));\n}\n\n//Provides: caml_ml_output_int\n//Requires: caml_ml_output\n//Requires: caml_string_of_array\nfunction caml_ml_output_int (chanid,i) {\n  var arr = [(i>>24) & 0xFF,(i>>16) & 0xFF,(i>>8) & 0xFF,i & 0xFF ];\n  var s = caml_string_of_array(arr);\n  caml_ml_output(chanid,s,0,4);\n  return 0\n}\n\n//Provides: caml_ml_is_buffered\n//Requires: caml_ml_channels\nfunction caml_ml_is_buffered(chanid) {\n  return caml_ml_channels[chanid].buffered ? 1 : 0\n}\n\n//Provides: caml_ml_set_buffered\n//Requires: caml_ml_channels, caml_ml_flush\nfunction caml_ml_set_buffered(chanid,v) {\n  caml_ml_channels[chanid].buffered = v;\n  if(!v) caml_ml_flush(chanid);\n  return 0\n}\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* The run-time library for lexers generated by camllex *)\n\ntype position = {\n  pos_fname : string;\n  pos_lnum : int;\n  pos_bol : int;\n  pos_cnum : int;\n}\n\nlet dummy_pos = {\n  pos_fname = \"\";\n  pos_lnum = 0;\n  pos_bol = 0;\n  pos_cnum = -1;\n}\n\ntype lexbuf =\n  { refill_buff : lexbuf -> unit;\n    mutable lex_buffer : bytes;\n    mutable lex_buffer_len : int;\n    mutable lex_abs_pos : int;\n    mutable lex_start_pos : int;\n    mutable lex_curr_pos : int;\n    mutable lex_last_pos : int;\n    mutable lex_last_action : int;\n    mutable lex_eof_reached : bool;\n    mutable lex_mem : int array;\n    mutable lex_start_p : position;\n    mutable lex_curr_p : position;\n  }\n\ntype lex_tables =\n  { lex_base: string;\n    lex_backtrk: string;\n    lex_default: string;\n    lex_trans: string;\n    lex_check: string;\n    lex_base_code : string;\n    lex_backtrk_code : string;\n    lex_default_code : string;\n    lex_trans_code : string;\n    lex_check_code : string;\n    lex_code: string;}\n\nexternal c_engine : lex_tables -> int -> lexbuf -> int = \"caml_lex_engine\"\nexternal c_new_engine : lex_tables -> int -> lexbuf -> int\n                      = \"caml_new_lex_engine\"\n\nlet engine tbl state buf =\n  let result = c_engine tbl state buf in\n  if result >= 0 && buf.lex_curr_p != dummy_pos then begin\n    buf.lex_start_p <- buf.lex_curr_p;\n    buf.lex_curr_p <- {buf.lex_curr_p\n                       with pos_cnum = buf.lex_abs_pos + buf.lex_curr_pos};\n  end;\n  result\n\n\nlet new_engine tbl state buf =\n  let result = c_new_engine tbl state buf in\n  if result >= 0 && buf.lex_curr_p != dummy_pos then begin\n    buf.lex_start_p <- buf.lex_curr_p;\n    buf.lex_curr_p <- {buf.lex_curr_p\n                       with pos_cnum = buf.lex_abs_pos + buf.lex_curr_pos};\n  end;\n  result\n\nlet lex_refill read_fun aux_buffer lexbuf =\n  let read =\n    read_fun aux_buffer (Bytes.length aux_buffer) in\n  let n =\n    if read > 0\n    then read\n    else (lexbuf.lex_eof_reached <- true; 0) in\n  (* Current state of the buffer:\n        <-------|---------------------|----------->\n        |  junk |      valid data     |   junk    |\n        ^       ^                     ^           ^\n        0    start_pos             buffer_end    Bytes.length buffer\n  *)\n  if lexbuf.lex_buffer_len + n > Bytes.length lexbuf.lex_buffer then begin\n    (* There is not enough space at the end of the buffer *)\n    if lexbuf.lex_buffer_len - lexbuf.lex_start_pos + n\n       <= Bytes.length lexbuf.lex_buffer\n    then begin\n      (* But there is enough space if we reclaim the junk at the beginning\n         of the buffer *)\n      Bytes.blit lexbuf.lex_buffer lexbuf.lex_start_pos\n                  lexbuf.lex_buffer 0\n                  (lexbuf.lex_buffer_len - lexbuf.lex_start_pos)\n    end else begin\n      (* We must grow the buffer.  Doubling its size will provide enough\n         space since n <= String.length aux_buffer <= String.length buffer.\n         Watch out for string length overflow, though. *)\n      let newlen =\n        Int.min (2 * Bytes.length lexbuf.lex_buffer) Sys.max_string_length in\n      if lexbuf.lex_buffer_len - lexbuf.lex_start_pos + n > newlen\n      then failwith \"Lexing.lex_refill: cannot grow buffer\";\n      let newbuf = Bytes.create newlen in\n      (* Copy the valid data to the beginning of the new buffer *)\n      Bytes.blit lexbuf.lex_buffer lexbuf.lex_start_pos\n                  newbuf 0\n                  (lexbuf.lex_buffer_len - lexbuf.lex_start_pos);\n      lexbuf.lex_buffer <- newbuf\n    end;\n    (* Reallocation or not, we have shifted the data left by\n       start_pos characters; update the positions *)\n    let s = lexbuf.lex_start_pos in\n    lexbuf.lex_abs_pos <- lexbuf.lex_abs_pos + s;\n    lexbuf.lex_curr_pos <- lexbuf.lex_curr_pos - s;\n    lexbuf.lex_start_pos <- 0;\n    lexbuf.lex_last_pos <- lexbuf.lex_last_pos - s;\n    lexbuf.lex_buffer_len <- lexbuf.lex_buffer_len - s ;\n    let t = lexbuf.lex_mem in\n    for i = 0 to Array.length t-1 do\n      let v = t.(i) in\n      if v >= 0 then\n        t.(i) <- v-s\n    done\n  end;\n  (* There is now enough space at the end of the buffer *)\n  Bytes.blit aux_buffer 0 lexbuf.lex_buffer lexbuf.lex_buffer_len n;\n  lexbuf.lex_buffer_len <- lexbuf.lex_buffer_len + n\n\nlet zero_pos = {\n  pos_fname = \"\";\n  pos_lnum = 1;\n  pos_bol = 0;\n  pos_cnum = 0;\n}\n\nlet from_function ?(with_positions = true) f =\n  { refill_buff = lex_refill f (Bytes.create 512);\n    lex_buffer = Bytes.create 1024;\n    lex_buffer_len = 0;\n    lex_abs_pos = 0;\n    lex_start_pos = 0;\n    lex_curr_pos = 0;\n    lex_last_pos = 0;\n    lex_last_action = 0;\n    lex_mem = [||];\n    lex_eof_reached = false;\n    lex_start_p = if with_positions then zero_pos else dummy_pos;\n    lex_curr_p = if with_positions then zero_pos else dummy_pos;\n  }\n\nlet from_channel ?with_positions ic =\n  from_function ?with_positions (fun buf n -> input ic buf 0 n)\n\nlet from_string ?(with_positions = true) s =\n  { refill_buff = (fun lexbuf -> lexbuf.lex_eof_reached <- true);\n    lex_buffer = Bytes.of_string s; (* have to make a copy for compatibility\n                                       with unsafe-string mode *)\n    lex_buffer_len = String.length s;\n    lex_abs_pos = 0;\n    lex_start_pos = 0;\n    lex_curr_pos = 0;\n    lex_last_pos = 0;\n    lex_last_action = 0;\n    lex_mem = [||];\n    lex_eof_reached = true;\n    lex_start_p = if with_positions then zero_pos else dummy_pos;\n    lex_curr_p = if with_positions then zero_pos else dummy_pos;\n  }\n\nlet set_position lexbuf position =\n  lexbuf.lex_curr_p  <- {position with pos_fname = lexbuf.lex_curr_p.pos_fname};\n  lexbuf.lex_abs_pos <- position.pos_cnum\n\nlet set_filename lexbuf fname =\n  lexbuf.lex_curr_p <- {lexbuf.lex_curr_p with pos_fname = fname}\n\nlet with_positions lexbuf = lexbuf.lex_curr_p != dummy_pos\n\nlet lexeme lexbuf =\n  let len = lexbuf.lex_curr_pos - lexbuf.lex_start_pos in\n  Bytes.sub_string lexbuf.lex_buffer lexbuf.lex_start_pos len\n\nlet sub_lexeme lexbuf i1 i2 =\n  let len = i2-i1 in\n  Bytes.sub_string lexbuf.lex_buffer i1 len\n\nlet sub_lexeme_opt lexbuf i1 i2 =\n  if i1 >= 0 then begin\n    let len = i2-i1 in\n    Some (Bytes.sub_string lexbuf.lex_buffer i1 len)\n  end else begin\n    None\n  end\n\nlet sub_lexeme_char lexbuf i = Bytes.get lexbuf.lex_buffer i\n\nlet sub_lexeme_char_opt lexbuf i =\n  if i >= 0 then\n    Some (Bytes.get lexbuf.lex_buffer i)\n  else\n    None\n\n\nlet lexeme_char lexbuf i =\n  Bytes.get lexbuf.lex_buffer (lexbuf.lex_start_pos + i)\n\nlet lexeme_start lexbuf = lexbuf.lex_start_p.pos_cnum\nlet lexeme_end lexbuf = lexbuf.lex_curr_p.pos_cnum\n\nlet lexeme_start_p lexbuf = lexbuf.lex_start_p\nlet lexeme_end_p lexbuf = lexbuf.lex_curr_p\n\nlet new_line lexbuf =\n  let lcp = lexbuf.lex_curr_p in\n  if lcp != dummy_pos then\n    lexbuf.lex_curr_p <-\n      { lcp with\n        pos_lnum = lcp.pos_lnum + 1;\n        pos_bol = lcp.pos_cnum;\n      }\n\n\n\n(* Discard data left in lexer buffer. *)\n\nlet flush_input lb =\n  lb.lex_curr_pos <- 0;\n  lb.lex_abs_pos <- 0;\n  let lcp = lb.lex_curr_p in\n  if lcp != dummy_pos then\n    lb.lex_curr_p <- {zero_pos with pos_fname = lcp.pos_fname};\n  lb.lex_buffer_len <- 0;\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen Printf\n\ntype t = exn = ..\n\nlet printers = Atomic.make []\n\nlet locfmt = format_of_string \"File \\\"%s\\\", line %d, characters %d-%d: %s\"\n\nlet field x i =\n  let f = Obj.field x i in\n  if not (Obj.is_block f) then\n    sprintf \"%d\" (Obj.magic f : int)           (* can also be a char *)\n  else if Obj.tag f = Obj.string_tag then\n    sprintf \"%S\" (Obj.magic f : string)\n  else if Obj.tag f = Obj.double_tag then\n    string_of_float (Obj.magic f : float)\n  else\n    \"_\"\n\nlet rec other_fields x i =\n  if i >= Obj.size x then \"\"\n  else sprintf \", %s%s\" (field x i) (other_fields x (i+1))\n\nlet fields x =\n  match Obj.size x with\n  | 0 -> \"\"\n  | 1 -> \"\"\n  | 2 -> sprintf \"(%s)\" (field x 1)\n  | _ -> sprintf \"(%s%s)\" (field x 1) (other_fields x 2)\n\nlet use_printers x =\n  let rec conv = function\n    | hd :: tl ->\n        (match hd x with\n         | None | exception _ -> conv tl\n         | Some s -> Some s)\n    | [] -> None in\n  conv (Atomic.get printers)\n\nlet to_string_default = function\n  | Out_of_memory -> \"Out of memory\"\n  | Stack_overflow -> \"Stack overflow\"\n  | Match_failure(file, line, char) ->\n      sprintf locfmt file line char (char+5) \"Pattern matching failed\"\n  | Assert_failure(file, line, char) ->\n      sprintf locfmt file line char (char+6) \"Assertion failed\"\n  | Undefined_recursive_module(file, line, char) ->\n      sprintf locfmt file line char (char+6) \"Undefined recursive module\"\n  | x ->\n      let x = Obj.repr x in\n      if Obj.tag x <> 0 then\n        (Obj.magic (Obj.field x 0) : string)\n      else\n        let constructor =\n          (Obj.magic (Obj.field (Obj.field x 0) 0) : string) in\n        constructor ^ (fields x)\n\nlet to_string e =\n  match use_printers e with\n  | Some s -> s\n  | None -> to_string_default e\n\nlet print fct arg =\n  try\n    fct arg\n  with x ->\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    flush stderr;\n    raise x\n\nlet catch fct arg =\n  try\n    fct arg\n  with x ->\n    flush stdout;\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    exit 2\n\ntype raw_backtrace_slot\ntype raw_backtrace_entry = private int\ntype raw_backtrace = raw_backtrace_entry array\n\nlet raw_backtrace_entries bt = bt\n\nexternal get_raw_backtrace:\n  unit -> raw_backtrace = \"caml_get_exception_raw_backtrace\"\n\nexternal raise_with_backtrace: exn -> raw_backtrace -> 'a\n  = \"%raise_with_backtrace\"\n\ntype backtrace_slot =\n  | Known_location of {\n      is_raise    : bool;\n      filename    : string;\n      line_number : int;\n      start_char  : int;\n      end_char    : int;\n      is_inline   : bool;\n      defname     : string;\n    }\n  | Unknown_location of {\n      is_raise : bool\n    }\n\n(* to avoid warning *)\nlet _ = [Known_location { is_raise = false; filename = \"\";\n                          line_number = 0; start_char = 0; end_char = 0;\n                          is_inline = false; defname = \"\" };\n         Unknown_location { is_raise = false }]\n\nexternal convert_raw_backtrace_slot:\n  raw_backtrace_slot -> backtrace_slot = \"caml_convert_raw_backtrace_slot\"\n\nexternal convert_raw_backtrace:\n  raw_backtrace -> backtrace_slot array = \"caml_convert_raw_backtrace\"\n\nlet convert_raw_backtrace bt =\n  try Some (convert_raw_backtrace bt)\n  with Failure _ -> None\n\nlet format_backtrace_slot pos slot =\n  let info is_raise =\n    if is_raise then\n      if pos = 0 then \"Raised at\" else \"Re-raised at\"\n    else\n      if pos = 0 then \"Raised by primitive operation at\" else \"Called from\"\n  in\n  match slot with\n  | Unknown_location l ->\n      if l.is_raise then\n        (* compiler-inserted re-raise, skipped *) None\n      else\n        Some (sprintf \"%s unknown location\" (info false))\n  | Known_location l ->\n      Some (sprintf \"%s %s in file \\\"%s\\\"%s, line %d, characters %d-%d\"\n              (info l.is_raise) l.defname l.filename\n              (if l.is_inline then \" (inlined)\" else \"\")\n              l.line_number l.start_char l.end_char)\n\nlet print_exception_backtrace outchan backtrace =\n  match backtrace with\n  | None ->\n      fprintf outchan\n        \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> fprintf outchan \"%s\\n\" str\n      done\n\nlet print_raw_backtrace outchan raw_backtrace =\n  print_exception_backtrace outchan (convert_raw_backtrace raw_backtrace)\n\n(* confusingly named: prints the global current backtrace *)\nlet print_backtrace outchan =\n  print_raw_backtrace outchan (get_raw_backtrace ())\n\nlet backtrace_to_string backtrace =\n  match backtrace with\n  | None ->\n     \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      let b = Buffer.create 1024 in\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> bprintf b \"%s\\n\" str\n      done;\n      Buffer.contents b\n\nlet raw_backtrace_to_string raw_backtrace =\n  backtrace_to_string (convert_raw_backtrace raw_backtrace)\n\nlet backtrace_slot_is_raise = function\n  | Known_location l -> l.is_raise\n  | Unknown_location l -> l.is_raise\n\nlet backtrace_slot_is_inline = function\n  | Known_location l -> l.is_inline\n  | Unknown_location _ -> false\n\ntype location = {\n  filename : string;\n  line_number : int;\n  start_char : int;\n  end_char : int;\n}\n\nlet backtrace_slot_location = function\n  | Unknown_location _ -> None\n  | Known_location l ->\n    Some {\n      filename    = l.filename;\n      line_number = l.line_number;\n      start_char  = l.start_char;\n      end_char    = l.end_char;\n    }\n\nlet backtrace_slot_defname = function\n  | Unknown_location _\n  | Known_location { defname = \"\" } -> None\n  | Known_location l -> Some l.defname\n\nlet backtrace_slots raw_backtrace =\n  (* The documentation of this function guarantees that Some is\n     returned only if a part of the trace is usable. This gives us\n     a bit more work than just convert_raw_backtrace, but it makes the\n     API more user-friendly -- otherwise most users would have to\n     reimplement the \"Program not linked with -g, sorry\" logic\n     themselves. *)\n  match convert_raw_backtrace raw_backtrace with\n    | None -> None\n    | Some backtrace ->\n      let usable_slot = function\n        | Unknown_location _ -> false\n        | Known_location _ -> true in\n      let rec exists_usable = function\n        | (-1) -> false\n        | i -> usable_slot backtrace.(i) || exists_usable (i - 1) in\n      if exists_usable (Array.length backtrace - 1)\n      then Some backtrace\n      else None\n\nlet backtrace_slots_of_raw_entry entry =\n  backtrace_slots [| entry |]\n\nmodule Slot = struct\n  type t = backtrace_slot\n  let format = format_backtrace_slot\n  let is_raise = backtrace_slot_is_raise\n  let is_inline = backtrace_slot_is_inline\n  let location = backtrace_slot_location\n  let name = backtrace_slot_defname\nend\n\nlet raw_backtrace_length bt = Array.length bt\n\nexternal get_raw_backtrace_slot :\n  raw_backtrace -> int -> raw_backtrace_slot = \"caml_raw_backtrace_slot\"\n\nexternal get_raw_backtrace_next_slot :\n  raw_backtrace_slot -> raw_backtrace_slot option\n  = \"caml_raw_backtrace_next_slot\"\n\n(* confusingly named:\n   returns the *string* corresponding to the global current backtrace *)\nlet get_backtrace () = raw_backtrace_to_string (get_raw_backtrace ())\n\nexternal record_backtrace: bool -> unit = \"caml_record_backtrace\"\nexternal backtrace_status: unit -> bool = \"caml_backtrace_status\"\n\nlet rec register_printer fn =\n  let old_printers = Atomic.get printers in\n  let new_printers = fn :: old_printers in\n  let success = Atomic.compare_and_set printers old_printers new_printers in\n  if not success then register_printer fn\n\nexternal get_callstack: int -> raw_backtrace = \"caml_get_current_callstack\"\n\nlet exn_slot x =\n  let x = Obj.repr x in\n  if Obj.tag x = 0 then Obj.field x 0 else x\n\nlet exn_slot_id x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 1) : int)\n\nlet exn_slot_name x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 0) : string)\n\nexternal get_debug_info_status : unit -> int = \"caml_ml_debug_info_status\"\n\n(* Descriptions for errors in startup.h. See also backtrace.c *)\nlet errors = [| \"\";\n  (* FILE_NOT_FOUND *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file not found)\";\n  (* BAD_BYTECODE *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file appears to be corrupt)\";\n  (* WRONG_MAGIC *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file has wrong magic number)\";\n  (* NO_FDS *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file cannot be opened;\\n \\\n      -- too many open files. Try running with OCAMLRUNPARAM=b=2)\"\n|]\n\nlet default_uncaught_exception_handler exn raw_backtrace =\n  eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n  print_raw_backtrace stderr raw_backtrace;\n  let status = get_debug_info_status () in\n  if status < 0 then\n    prerr_endline errors.(abs status);\n  flush stderr\n\nlet uncaught_exception_handler = ref default_uncaught_exception_handler\n\nlet set_uncaught_exception_handler fn = uncaught_exception_handler := fn\n\nlet empty_backtrace : raw_backtrace = [| |]\n\nlet try_get_raw_backtrace () =\n  try\n    get_raw_backtrace ()\n  with _ (* Out_of_memory? *) ->\n    empty_backtrace\n\nlet handle_uncaught_exception' exn debugger_in_use =\n  try\n    (* Get the backtrace now, in case one of the [at_exit] function\n       destroys it. *)\n    let raw_backtrace =\n      if debugger_in_use (* Same test as in [runtime/printexc.c] *) then\n        empty_backtrace\n      else\n        try_get_raw_backtrace ()\n    in\n    (try Stdlib.do_at_exit () with _ -> ());\n    try\n      !uncaught_exception_handler exn raw_backtrace\n    with exn' ->\n      let raw_backtrace' = try_get_raw_backtrace () in\n      eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n      print_raw_backtrace stderr raw_backtrace;\n      eprintf \"Fatal error in uncaught exception handler: exception %s\\n\"\n        (to_string exn');\n      print_raw_backtrace stderr raw_backtrace';\n      flush stderr\n  with\n    | Out_of_memory ->\n        prerr_endline\n          \"Fatal error: out of memory in uncaught exception handler\"\n\n(* This function is called by [caml_fatal_uncaught_exception] in\n   [runtime/printexc.c] which expects no exception is raised. *)\nlet handle_uncaught_exception exn debugger_in_use =\n  try\n    handle_uncaught_exception' exn debugger_in_use\n  with _ ->\n    (* There is not much we can do at this point *)\n    ()\n\nexternal register_named_value : string -> 'a -> unit\n  = \"caml_register_named_value\"\n\nlet () =\n  register_named_value \"Printexc.handle_uncaught_exception\"\n    handle_uncaught_exception\n","open BearGame\nopen Game\nopen Graph\nopen IntHash\nopen IntMap\nopen List0\nopen Player\nopen PrimInt63\n\ntype coq_Spoke =\n| S1\n| S2\n| S3\n| S4\n| S5\n| S6\n| S7\n| S8\n\n(** val clockwise : coq_Spoke -> coq_Spoke **)\n\nlet clockwise = function\n| S1 -> S2\n| S2 -> S3\n| S3 -> S4\n| S4 -> S5\n| S5 -> S6\n| S6 -> S7\n| S7 -> S8\n| S8 -> S1\n\n(** val c_clockwise : coq_Spoke -> coq_Spoke **)\n\nlet c_clockwise = function\n| S1 -> S8\n| S2 -> S1\n| S3 -> S2\n| S4 -> S3\n| S5 -> S4\n| S6 -> S5\n| S7 -> S6\n| S8 -> S7\n\n(** val list_spokes : coq_Spoke list **)\n\nlet list_spokes =\n  S1 :: (S2 :: (S3 :: (S4 :: (S5 :: (S6 :: (S7 :: (S8 :: [])))))))\n\ntype coq_SpokeLoc =\n| Mid\n| L\n| R\n\n(** val list_locs : coq_SpokeLoc list **)\n\nlet list_locs =\n  Mid :: (L :: (R :: []))\n\ntype coq_RWVert =\n| Center\n| SpokeVert of coq_Spoke * coq_SpokeLoc\n\n(** val hash_RWVert : coq_RWVert -> Uint63.t **)\n\nlet hash_RWVert = function\n| Center -> (Uint63.of_int (0))\n| SpokeVert (s, l) ->\n  (match s with\n   | S1 ->\n     (match l with\n      | Mid -> (Uint63.of_int (2))\n      | L -> (Uint63.of_int (1))\n      | R -> (Uint63.of_int (3)))\n   | S2 ->\n     (match l with\n      | Mid -> (Uint63.of_int (5))\n      | L -> (Uint63.of_int (4))\n      | R -> (Uint63.of_int (6)))\n   | S3 ->\n     (match l with\n      | Mid -> (Uint63.of_int (8))\n      | L -> (Uint63.of_int (7))\n      | R -> (Uint63.of_int (9)))\n   | S4 ->\n     (match l with\n      | Mid -> (Uint63.of_int (11))\n      | L -> (Uint63.of_int (10))\n      | R -> (Uint63.of_int (12)))\n   | S5 ->\n     (match l with\n      | Mid -> (Uint63.of_int (14))\n      | L -> (Uint63.of_int (13))\n      | R -> (Uint63.of_int (15)))\n   | S6 ->\n     (match l with\n      | Mid -> (Uint63.of_int (17))\n      | L -> (Uint63.of_int (16))\n      | R -> (Uint63.of_int (18)))\n   | S7 ->\n     (match l with\n      | Mid -> (Uint63.of_int (20))\n      | L -> (Uint63.of_int (19))\n      | R -> (Uint63.of_int (21)))\n   | S8 ->\n     (match l with\n      | Mid -> (Uint63.of_int (23))\n      | L -> (Uint63.of_int (22))\n      | R -> (Uint63.of_int (24))))\n\n(** val coq_IntHash_RWVert : coq_RWVert coq_IntHash **)\n\nlet coq_IntHash_RWVert =\n  hash_RWVert\n\n(** val coq_RomanWheel : coq_Graph **)\n\nlet coq_RomanWheel =\n  { coq_Vert_disc = (coq_Hash_disc (Obj.magic coq_IntHash_RWVert));\n    coq_Vert_enum =\n    ((Obj.magic Center) :: (concat\n                             (map (fun s ->\n                               map (Obj.magic (fun x -> SpokeVert (s, x)))\n                                 list_locs) list_spokes))); successors =\n    (fun v ->\n    match Obj.magic v with\n    | Center -> map (fun s -> Obj.magic (SpokeVert (s, Mid))) list_spokes\n    | SpokeVert (s, l) ->\n      (match l with\n       | Mid ->\n         (Obj.magic Center) :: ((Obj.magic (SpokeVert (s, L))) :: ((Obj.magic\n                                                                    (SpokeVert\n                                                                    (s, R))) :: []))\n       | L ->\n         (Obj.magic (SpokeVert (s, R))) :: ((Obj.magic (SpokeVert (s, Mid))) :: (\n           (Obj.magic (SpokeVert ((c_clockwise s), R))) :: []))\n       | R ->\n         (Obj.magic (SpokeVert (s, L))) :: ((Obj.magic (SpokeVert (s, Mid))) :: (\n           (Obj.magic (SpokeVert ((clockwise s), L))) :: [])))) }\n\n(** val coq_IntHash_RWV : coq_Vert coq_IntHash **)\n\nlet coq_IntHash_RWV =\n  Obj.magic coq_IntHash_RWVert\n\n(** val add_vert : coq_Vert -> Uint63.t -> Uint63.t **)\n\nlet add_vert v i =\n  coq_lor (coq_IntHash_RWV v) (coq_lsl i (Uint63.of_int (5)))\n\n(** val add_verts : coq_Vert list -> Uint63.t -> Uint63.t **)\n\nlet add_verts vs i =\n  fold_right add_vert i vs\n\n(** val add_player : coq_Player -> Uint63.t -> Uint63.t **)\n\nlet add_player p i =\n  match p with\n  | White -> coq_lsl i (Uint63.of_int (1))\n  | Black -> coq_lor (Uint63.of_int (1)) (coq_lsl i (Uint63.of_int (1)))\n\n(** val hash_RW_State : coq_BG_State -> Uint63.t **)\n\nlet hash_RW_State s =\n  let { BearGame.to_play = p; bear = b; hunters = hs } = s in\n  add_player p (add_vert b (add_verts hs (Uint63.of_int (0))))\n\n(** val coq_IntHash_RW : coq_GameState coq_IntHash **)\n\nlet coq_IntHash_RW =\n  Obj.magic hash_RW_State\n","(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\ntype c = int\ntype t = (c * c) list\n\nlet rec union l l' =\n  match l, l' with\n    _, [] -> l\n  | [], _ -> l'\n  | (c1, c2)::r, (c1', c2')::r' ->\n    if c2 + 1 < c1' then\n      (c1, c2)::union r l'\n    else if c2' + 1 < c1 then\n      (c1', c2')::union l r'\n    else if c2 < c2' then\n      union r ((min c1 c1', c2')::r')\n    else\n      union ((min c1 c1', c2)::r) r'\n\nlet rec inter l l' =\n  match l, l' with\n    _, [] -> []\n  | [], _ -> []\n  | (c1, c2)::r, (c1', c2')::r' ->\n    if c2 < c1' then\n      inter r l'\n    else if c2' < c1 then\n      inter l r'\n    else if c2 < c2' then\n      (max c1 c1', c2)::inter r l'\n    else\n      (max c1 c1', c2')::inter l r'\n\nlet rec diff l l' =\n  match l, l' with\n    _, [] -> l\n  | [], _ -> []\n  | (c1, c2)::r, (c1', c2')::r' ->\n    if c2 < c1' then\n      (c1, c2)::diff r l'\n    else if c2' < c1 then\n      diff l r'\n    else\n      let r'' = if c2' < c2 then (c2' + 1, c2) :: r else r in\n      if c1 < c1' then\n        (c1, c1' - 1)::diff r'' r'\n      else\n        diff r'' r'\n\nlet single c = [c, c]\n\nlet add c l = union (single c) l\n\nlet seq c c' = if c <= c' then [c, c'] else [c', c]\n\nlet rec offset o l =\n  match l with\n    []            -> []\n  | (c1, c2) :: r -> (c1 + o, c2 + o) :: offset o r\n\nlet empty = []\n\nlet rec mem (c : int) s =\n  match s with\n    []              -> false\n  | (c1, c2) :: rem -> if c <= c2 then c >= c1 else mem c rem\n\n(****)\n\ntype hash = int\n\nlet rec hash_rec = function\n  | []        -> 0\n  | (i, j)::r -> i + 13 * j + 257 * hash_rec r\nlet hash l = (hash_rec l) land 0x3FFFFFFF\n\n(****)\n\nlet print_one ch (c1, c2) =\n  if c1 = c2 then\n    Format.fprintf ch \"%d\" c1\n  else\n    Format.fprintf ch \"%d-%d\" c1 c2\n\nlet pp = Fmt.list print_one\n\nlet rec iter t ~f =\n  match t with\n  | [] -> ()\n  | (x, y)::xs ->\n    f x y;\n    iter xs  ~f\n\nlet one_char = function\n  | [i, j] when i = j -> Some i\n  | _ -> None\n\n\nmodule CSetMap = Map.Make (struct\n    type t = int * (int * int) list\n    let compare (i, u) (j, v) =\n      let c = compare i j in\n      if c <> 0\n      then c\n      else compare u v\n  end)\n\nlet fold_right t ~init ~f = List.fold_right f t init\n\nlet csingle c = single (Char.code c)\n\nlet cany = [0, 255]\n\nlet is_empty = function\n  | [] -> true\n  | _ -> false\n\nlet rec prepend s x l =\n  match s, l with\n  | [], _ -> l\n  | _r, [] -> []\n  | (_c, c') :: r, ([d, _d'], _x') :: _r' when c' < d -> prepend r x l\n  | (c, c') :: r, ([d, d'], x') :: r' ->\n    if c <= d then begin\n      if c' < d'\n      then ([d, c'], x @ x') :: prepend r x (([c' + 1, d'], x') :: r')\n      else ([d, d'], x @ x') :: prepend s x r'\n    end else begin\n      if c > d'\n      then ([d, d'], x') :: prepend s x r'\n      else ([d, c - 1], x') :: prepend s x (([c, d'], x') :: r')\n    end\n  | _ -> assert false\n\nlet pick = function\n  | [] -> invalid_arg \"Re_cset.pick\"\n  | (x, _)::_ -> x\n","(* This file is part of Lwt, released under the MIT license. See LICENSE.md for\n   details, or visit https://github.com/ocsigen/lwt/blob/master/LICENSE.md. *)\n\n\n\n(* Reading guide\n\n   Welcome to the implementation of the Lwt core! This is a big file, but we\n   hope that reading it (parts at a time!) will not be scary :) Here is why:\n\n\n   * Sectioning\n\n   The code is broken up into sections, each one of which is an internal module.\n   Most of the modules have a signature, which serves as a neat table of\n   contents.\n\n   It is recommended that you read this file with code folding enabled. If you\n   fold all the modules, you can visualize the logical structure of Lwt quite\n   easily. You can then expand modules as needed, depending on what part of the\n   implementation you are interested in. Without code folding, you face an\n   intimidating wall of code :( You can still visually parse the file, however,\n   because there are plenty of blank lines to help section things off. You can\n   also view this file folded online:\n\n     https://gist.github.com/aantron/9fab0bdead98a60fccf06e0189186863\n     https://gist.github.com/aantron/97b58520d5bb4858ccac6f54700a24d7\n\n   The signatures are unusual: big comments are absent. They are moved into the\n   modules, so that they are hidden by code folding when you (the reader!) are\n   not interested in those modules.\n\n\n   * Documentation\n\n   The documentation begins with an overview of major concepts and components.\n   This overview puts everything into context. You don't have to read the whole\n   thing. The overview begins with basic concepts, moves on to advanced ones,\n   and then gets into the truly esoteric. You can read about each concept on an\n   as-needed basis. However, once you have read the whole overview, you will be\n   aware of *everything* that is needed to understand, and work with, the core\n   of Lwt.\n\n   Littered in the code are additional comments, that go in-depth on various\n   local implementation details, opportunities, regrets, and the like.\n\n   The sections (modules) of the code correspond closely to sections of the\n   overview.\n\n\n   * Whitespace\n\n   The total line count of this file may seem frightening, but one third of it\n   is whitespace and comments, both there to help you read the remaining two\n   thirds!\n\n   Also, within those two thirds, there are large groups of functions that are\n   repetitive and formulaic, so there is much less conceptually-unique code in\n   Lwt than you might think at first.\n\n\n   * Please edit the code and the docs!\n\n   This code is meant to be readable, and to be edited. If you are reading\n   something, and think there is a better way to express it, please go ahead and\n   open a pull request to the Lwt repository at\n\n     https://github.com/ocsigen/lwt\n\n   Even if your pull request somehow doesn't get merged, you will have educated\n   the maintainers, not to mention other contributors, and users. This is true\n   even if the change is trivial -- sometimes, maintainers just need to be\n   educated multiple times before they see the wisdom of it :/\n\n   Likewise, if you would like to make a code contribution to the Lwt core, it\n   is quite welcome, and we hope that this code is readable enough for you to be\n   able to make it!\n\n\n   Enjoy! *)\n\n\n\n(* Overview\n\n   In this file, there is a \"model\" function -- [Lwt.bind] -- which pulls\n   together many (though not all) of the concepts and helpers discussed in this\n   overview. To find it, search for \"let bind,\" and you can examine it while\n   reading the overview. The authors of this file intend to put extra effort\n   into writing nice comments inside [Lwt.bind] :)\n\n\n   0. Main mechanism and two aspects\n\n   The Lwt interface ([lwt.mli]) provides one main mechanism, promises, and two\n   \"aspects,\" which are *not* necessary to understand the main mechanism\n   promises, but they are still there:\n\n   - promise cancellation\n   - sequence-associated storage\n\n   If you are not interested in cancellation or storage, you can ignore these\n   two complications, and still get a pretty good understanding of the code. To\n   help, all identifiers related to cancellation contain the string \"cancel,\"\n   and all identifiers related to storage contain \"storage.\"\n\n\n   1. Promises\n\n   A promise is a cell that can be in one of two states: \"resolved\" or\n   \"pending.\"\n\n   - Resolved promises\n\n     A resolved promise is either \"fulfilled\" with a value, or \"rejected\" with\n     an exception. The state of a resolved promise will never change again: a\n     resolved promise is immutable. A resolved promise is basically equivalent\n     to an [('a, exn) Stdlib.result]. Resolved promises are produced in two\n     ways:\n\n     - [Lwt.return], [Lwt.fail], and related functions, produce \"trivial\"\n       promises that are resolved from the start.\n     - The other way is to resolve a promise that started out pending.\n\n     Note that rejected promises have nothing to do with unhandled exceptions.\n\n   - Pending promises\n\n     ...are those that may become resolved in the future. Each pending promise\n     carries a list of callbacks. These callbacks are added by functions like\n     [Lwt.bind], and called by Lwt if/when the promise is resolved. These\n     callbacks typically end up resolving additional promises; see section\n     \"Resolution loop\" below.\n\n     Pending promises are produced in three ways, according to how they can be\n     resolved:\n\n     - Initial promises\n\n       ...are created by [Lwt.wait] and [Lwt.task]. The user of Lwt resolves\n       these promises manually, through the resolvers returned by those\n       functions.\n\n     - Sequential composition\n\n       For example, [Lwt.bind]. These promises only are only resolved when the\n       preceding sequence of promises resolves. The user cannot resolve these\n       promises directly (but see the section on cancellation below).\n\n     - Concurrent composition\n\n       For example, [Lwt.join] or [Lwt.choose]. These promises are only resolved\n       when all or one of a set of \"preceding\" promises resolve. The user cannot\n       resolve these promises directly (but see the section on cancellation\n       below).\n\n\n   2. Resolvers\n\n   Resolvers are given to the user by [Lwt.wait] and [Lwt.task], and can be used\n   by the user to resolve the corresponding promises. Note that this means the\n   user only ever gets resolvers for initial promises.\n\n   Internally, resolvers are the exact same objects as the promises they\n   resolve, even though the resolver is exposed as a reference of a different\n   type by [lwt.mli]. For details on why, see section \"Type system abuse\" below.\n\n\n   3. Callbacks\n\n   ...are attached by Lwt to pending promises, and are run by Lwt if/when those\n   promises are resolved. These callbacks are not directly exposed through\n   [lwt.mli] -- they are a low-level mechanism. For example, to implement\n   [Lwt.bind p f], Lwt attaches a callback to [p] that does some internal Lwt\n   book-keeping, and then calls [f] if [p] is fulfilled, and does something else\n   if [p] is rejected.\n\n   Callbacks come in two flavors: regular callbacks and cancel callbacks. The\n   only material differences between them are that:\n\n   - regular callbacks are always called when a promise is resolved, but cancel\n     callbacks are called, in addition, only if the promise is canceled, and\n   - all cancel callbacks of a promise are called before any regular callback\n     is called.\n\n   Cancellation is a special case of resolution, in particular, a special case\n   of rejection, but see the section on cancellation later below.\n\n\n   4. Resolution loop\n\n   Resolving a pending promise triggers its callbacks, and those might resolve\n   more pending promises, triggering more callbacks, etc. This behavior is the\n   *resolution loop*. Lwt has some machinery to avoid stack overflow and other\n   unfortunate situations during this loop.\n\n   This chaining of promise resolutions through callbacks can be seen as a kind\n   of promise dependency graph, in which the nodes are pending promises, and the\n   edges are callbacks. During the resolution loop, Lwt starts at some initial\n   promise that is getting resolved by the user, and recursively resolves all\n   dependent promises. The graph is modified: resolved promises are no longer\n   pending, so they are no longer part of the graph.\n\n   Some of these dependencies are explicit to Lwt, e.g. the callbacks registered\n   by [Lwt.bind]. Others are not visible to Lwt, because the user can always\n   register a callback using a function like [Lwt.on_success], and use that\n   callback to resolve another initial promise. All the explicit dependencies\n   are created by Lwt's own sequential and concurrent composition functions\n   (so, [Lwt.bind], [Lwt.join], etc). Whether dependencies are explicit or not\n   is relevant only to cancellation.\n\n\n   5. Cancellation\n\n   As described above, ordinary promise resolution proceeds from an initial\n   promise, forward along callbacks through the dependency graph. Since it\n   starts from an initial promise, it can only be triggered using a resolver.\n\n   Cancellation is a sort of dual to ordinary resolution. Instead of starting at\n   an initial promise/resolver, cancellation starts at *any* promise. It then\n   goes *backwards* through the explicit dependency graph, looking for\n   cancelable initial promises to cancel -- those that were created by\n   [Lwt.task]. After finding them, cancellation resolves them normally with\n   [Rejected Lwt.Canceled], causing an ordinary promise resolution process.\n\n   To summarize, cancellation is a way to trigger an *ordinary* resolution of\n   promises created with [Lwt.task], by first searching for them in the promise\n   dependency graph (which is assembled by [Lwt.bind], [Lwt.join], etc).\n\n   This backwards search is triggered only by [Lwt.cancel]. It is also possible\n   for the user to cancel a promise directly by rejecting it with\n   [Lwt.Canceled], but in all cases where the user can do so, the search would\n   be redundant anyway -- the user has only two ways of directly rejecting a\n   promise with [Lwt.Canceled] (or any exception, for that matter):\n\n   - The user can create an initial promise, then reject it through its\n     resolver. The search is redundant because it would find only the same\n     initial promise to cancel.\n   - The user can create a trivial promise by calling [Lwt.fail Lwt.Canceled].\n     The search is again redundant; in this case it would find nothing to\n     cancel.\n\n   Note that there is a quirk: only promises created by [Lwt.task] are\n   susceptible to being canceled by [Lwt.cancel], but the user can manually\n   cancel initial promises created by both [Lwt.task] and [Lwt.wait].\n\n   Due to [Lwt.cancel], promise cancellation, and therefore resolution, can be\n   initiated by the user without access to a resolver. This is important for\n   reasoning about state changes in the implementation of Lwt, and is referenced\n   in some implementation detail comments.\n\n\n   6. No I/O\n\n   The Lwt core deliberately doesn't do I/O. The resolution loop stops running\n   once no promises can be resolved immediately. It has to be restarted later\n   by some surrounding I/O loop. This I/O loop typically keeps track of pending\n   promises that represent blocked or in-progress I/O; other pending promises\n   that indirectly depend on I/O are not explicitly tracked. They are retained\n   in memory by references captured inside callbacks.\n\n   On Unix and Windows, a separate top-level loop, typically [Lwt_main.run], is\n   necessary to repeatedly call [select], [epoll], or [kevent], and resolve\n   blocked I/O promises.\n\n   In JavaScript, references to promises are retained by JavaScript code, which\n   is, in turn, triggered by the JS engine. In other words, the top-level loop\n   is buried inside the JS engine.\n\n   This separation of the Lwt core from the top-level I/O loop keeps the core\n   portable.\n\n\n   7. Promise \"proxying\"\n\n   In [Lwt.bind : 'a t -> ('a -> 'b t) -> 'b t], the outer ['b t] is created by\n   [bind] first, and returned to the user. The inner ['b t] is created by the\n   user later, and then returned to [bind]. At that point, [bind] needs to make\n   the inner and outer ['b t]s behave identically.\n\n   This is accomplished by making one of the promises point to the other. The\n   first of the promises thus becomes a \"proxy,\" and the other is its\n   \"underlying\" promise.\n\n   After that, all operations that would be performed by Lwt on the proxy are\n   instead performed on the underlying promise. This is ensured by the numerous\n   calls to the internal function [underlying] in this file.\n\n   Because of the pervasive use of [underlying], proxies can be more or less\n   ignored on a first reading the code. However, becoming a proxy is a kind of\n   state change, and any promise that is returned by a callback to [bind], or to\n   a similar Lwt function, might become a proxy. That means: just about any\n   promise that is handed to the user, might become a proxy promise by the next\n   time Lwt sees it. This is important for reasoning about possible state\n   changes in implementation of Lwt, and is referenced in some implementation\n   detail comments.\n\n\n   8. Sequence-associated storage\n\n   Lwt has a global key-value map. The map can be preserved across sequential\n   composition functions, so that it has the same state in the user's callback\n   [f] as it did at the time the user called [Lwt.bind p f].\n\n   The details are pretty straightforward, and discussed in module\n   [Sequence_associated_storage]. The main thing to be aware of is the many\n   references to [current_storage] throughout Lwt, which are needed to properly\n   save and restore the mapping.\n\n\n   9. Type system abuse\n\n   The implementation uses the type system somewhat extensively. Gentle\n   introductions can be found here:\n\n     https://discuss.ocaml.org/t/161/7\n     https://discuss.ocaml.org/t/161/16\n\n   A short summary follows.\n\n   The promise state is, internally, a GADT which encodes the state in its type\n   parameters. Thus, if you do [let p = underlying p], the shadowing reference\n   [p] is statically known *not* to be a proxy, and the compiler knows that the\n   corresponding match case [Proxy _] is impossible.\n\n   The external promise type, ['a t], and the external resolver type, ['a u],\n   are not GADTs. Furthermore, they are, respectively, covariant and\n   contravariant in ['a], while the internal promise type is invariant in ['a].\n   For these reasons, there are nasty casts between ['a t], ['a u], and the\n   internal promise type. The implementation is, of course, written in terms of\n   the internal type.\n\n   Casting from an ['a t] to an internal promise produces a reference for\n   which the state is \"unknown\": this is simulated with a helper GADT, which\n   encodes existential types. There are several similar casts, which are used\n   to document possible state changes between the time a promise is created,\n   and the later time it is used in a callback. You can see these casts in\n   action in [Lwt.bind]. The cast syntax is pretty light, and, besides being\n   commented in [bind], all such casts are documented in modules [Public_types]\n   and [Basic_helpers].\n\n\n   If you've made it this far, you are an Lwt expert! Rejoice! *)\n\n\n\n(* [Lwt_sequence] is deprecated – we don't want users outside Lwt using it.\n   However, it is still used internally by Lwt. So, briefly disable warning 3\n   (\"deprecated\"), and create a local, non-deprecated alias for\n   [Lwt_sequence] that can be referred to by the rest of the code in this\n   module without triggering any more warnings. *)\n[@@@ocaml.warning \"-3\"]\nmodule Lwt_sequence = Lwt_sequence\n[@@@ocaml.warning \"+3\"]\n\n(* Some sequence-associated storage types\n\n   Sequence-associated storage is defined and documented later, in module\n   [Sequence_associated_storage]. However, the following types are mentioned in\n   the definition of [promise], so they must be defined here first. *)\nmodule Storage_map =\n  Map.Make\n    (struct\n      type t = int\n      let compare = compare\n    end)\ntype storage = (unit -> unit) Storage_map.t\n\n\n\nmodule Main_internal_types =\nstruct\n  (* Phantom types for use with types [promise] and [state]. These are never\n     constructed; the purpose of the constructors is to prove to the type\n     checker that these types are distinct from each other. Warning 37, \"unused\n     constructor,\" therefore has to be temporarily suppressed. *)\n\n  [@@@ocaml.warning \"-37\"]\n\n  type underlying = private Underlying_and_this_constructor_is_not_used\n  type proxy = private Proxy_and_this_constructor_is_not_used\n\n  type resolved = private Resolved_and_this_constructor_is_not_used\n  type pending = private Pending_and_this_constructor_is_not_used\n\n  [@@@ocaml.warning \"+37\"]\n\n\n\n  (* Promises proper. *)\n\n  type ('a, 'u, 'c) promise = {\n    mutable state : ('a, 'u, 'c) state;\n  }\n\n  and (_, _, _) state =\n    | Fulfilled : 'a                  -> ('a, underlying, resolved) state\n    | Rejected  : exn                 -> ( _, underlying, resolved) state\n    | Pending   : 'a callbacks        -> ('a, underlying, pending)  state\n    | Proxy     : ('a, _, 'c) promise -> ('a, proxy,      'c)       state\n\n  (* Note:\n\n     A promise whose state is [Proxy _] is a \"proxy\" promise. A promise whose\n     state is *not* [Proxy _] is an \"underlying\" promise.\n\n     The \"underlying promise of [p]\" is:\n\n     - [p], if [p] is itself underlying.\n     - Otherwise, [p] is a proxy and has state [Proxy p']. The underlying\n       promise of [p] is the underlying promise of [p'].\n\n     In other words, to find the underlying promise of a proxy, Lwt follows the\n     [Proxy _] links to the end. *)\n\n  (* Note:\n\n     When a promise is resolved, or becomes a proxy, its state field is\n     mutated. This invalidates the type invariants on the promise. See internal\n     function [set_promise_state] for details about that.\n\n     When an Lwt function has a reference to a promise, and also registers a\n     callback that has a reference to the same promise, the invariants on the\n     reference may become invalid by the time the callback is called. All such\n     callbacks have comments explaining what the valid invariants are at that\n     point, and/or casts to (1) get the correct typing and (2) document the\n     potential state change for readers of the code. *)\n\n\n\n  (* Callback information for pending promises. *)\n\n  and 'a callbacks = {\n    mutable regular_callbacks : 'a regular_callback_list;\n    mutable cancel_callbacks  : 'a cancel_callback_list;\n    mutable how_to_cancel     : how_to_cancel;\n    mutable cleanups_deferred : int;\n  }\n\n  and 'a regular_callback = 'a resolved_state -> unit\n\n  and cancel_callback = unit -> unit\n\n  and 'a resolved_state = ('a, underlying, resolved) state\n\n  and how_to_cancel =\n    | Not_cancelable              :                           how_to_cancel\n    | Cancel_this_promise         :                           how_to_cancel\n    | Propagate_cancel_to_one     : (_, _, _) promise      -> how_to_cancel\n    | Propagate_cancel_to_several : (_, _, _) promise list -> how_to_cancel\n\n  and 'a regular_callback_list =\n    | Regular_callback_list_empty\n    | Regular_callback_list_concat of\n      'a regular_callback_list * 'a regular_callback_list\n    | Regular_callback_list_implicitly_removed_callback of\n      'a regular_callback\n    | Regular_callback_list_explicitly_removable_callback of\n      'a regular_callback option ref\n\n  and _ cancel_callback_list =\n    | Cancel_callback_list_empty :\n      _ cancel_callback_list\n    | Cancel_callback_list_concat :\n      'a cancel_callback_list * 'a cancel_callback_list ->\n        'a cancel_callback_list\n    | Cancel_callback_list_callback :\n      storage * cancel_callback ->\n        _ cancel_callback_list\n    | Cancel_callback_list_remove_sequence_node :\n      ('a, _, _) promise Lwt_sequence.node ->\n        'a cancel_callback_list\n\n  (* Notes:\n\n     These type definitions are guilty of performing several optimizations,\n     without which they would be much easier to understand.\n\n     - The type parameters of ['a resolved_state] guarantee that it is either\n       [Fulfilled _] or [Rejected _]. So, it is equivalent to\n       [('a, exn) Stdlib.result], and, indeed, should have an identical\n       memory representation.\n\n     - As per the Overview, there are regular callbacks and cancel callbacks.\n       Cancel callbacks are called only on cancellation, and, then, before any\n       regular callbacks are called.\n\n       Despite the different types for the two kinds of callbacks, they are\n       otherwise the same. Cancel callbacks just don't need a result state\n       argument, because it is known to be [Rejected Canceled].\n\n     - Regular callbacks are not allowed to raise exceptions. All regular\n       callbacks are created in this file, so this can be checked.\n\n       Cancel callbacks can raise exceptions, but if they do so, the exceptions\n       are passed to [async_exception_hook].\n\n     - [how_to_cancel] implements the dependency graph mentioned in the\n       Overview. It is traversed backwards during [Lwt.cancel]. It is a GADT\n       because we don't care about the actual types of the promise references\n       stored, or their invariants. The constructors correspond to pending\n       promise kinds as follows:\n         - [Not_cancelable]: initial, [Lwt.wait].\n         - [Cancel_this_promise]: initial, [Lwt.task].\n         - [Propagate_cancel_to_one]: sequential composition, e.g. [Lwt.bind].\n         - [Propagate_cancel_to_several]: concurrent composition, e.g.\n           [Lwt.join].\n\n     - The two callback list types are ordinary append-friendly lists, with two\n       optimizations inlined:\n\n       - ['a regular_callback_list] apparently has two \"kinds\" of regular\n         callbacks, implicitly removed and explicitly removable. All callbacks\n         are removable. It's just that, for some callbacks, they will only be\n         removed at the same time that the promise they are attached to becomes\n         resolved. When that happens, the entire state of that promise changes\n         to [Fulfilled _] or [Rejected _], and the reference to the whole\n         callback list is simply lost. This \"removes\" the callback. For these\n         callbacks, ['a regular_callback_list] attempts to trim an option and a\n         reference cell with the\n         [Regular_callback_list_implicitly_removed_callback] constructor.\n\n       - ['a cancel_callback_list] has\n         [Cancel_callback_list_remove_sequence_node node], which is the same as\n         [Cancel_callback_list_callback (_, (fun _ ->\n           Lwt_sequence.remove node))].\n         This was probably done to avoid a closure allocation.\n\n     - The [cleanups_deferred] field is explained in module\n       [Pending_callbacks]. *)\nend\nopen Main_internal_types\n\n\n\nmodule Public_types =\nstruct\n  type +'a t\n  type -'a u\n\n  let to_public_promise : ('a, _, _) promise -> 'a t = Obj.magic\n  let to_public_resolver : ('a, _, _) promise -> 'a u = Obj.magic\n\n  type _ packed_promise =\n    | Internal : ('a, _, _) promise -> 'a packed_promise\n    [@@ocaml.unboxed]\n\n  let to_internal_promise (p : 'a t) : 'a packed_promise =\n    Internal (Obj.magic p)\n  let to_internal_resolver (r : 'a u) : 'a packed_promise =\n    Internal (Obj.magic r)\n\n  (* Most functions that take a public promise (['a t]) convert it to an\n     internal promise as follows:\n\n       (* p : 'a t *)\n\n       let Internal p = to_internal_promise p in\n\n       (* p : ('a, u, c) promise, where u and c are fresh types, i.e. the\n          invariants on p are unknown. *)\n\n     This cast is a no-op cast. It only produces a reference with a different\n     type. The introduction and immediate elimination of [Internal _] seems to\n     be optimized away even on older versions of OCaml that don't have Flambda\n     and don't support [[@@ocaml.unboxed]]. *)\n\n  (* This could probably save an allocation by using [Obj.magic]. *)\n  let state_of_result = function\n    | Ok x -> Fulfilled x\n    | Error exn -> Rejected exn\nend\ninclude Public_types\n\n\n\nmodule Basic_helpers :\nsig\n  val identical : ('a, _, _) promise -> ('a, _, _) promise -> bool\n  val underlying : ('a, 'u, 'c) promise -> ('a, underlying, 'c) promise\n\n  type ('a, 'u, 'c) state_changed =\n    | State_may_have_changed of ('a, 'u, 'c) promise\n    [@@ocaml.unboxed]\n  val set_promise_state :\n    ('a, _, _) promise -> ('a, 'u, 'c) state -> ('a, 'u, 'c) state_changed\n\n  type 'a may_now_be_proxy =\n    | State_may_now_be_pending_proxy :\n      ('a, _, pending) promise -> 'a may_now_be_proxy\n    [@@ocaml.unboxed]\n  val may_now_be_proxy :\n    ('a, underlying, pending) promise -> 'a may_now_be_proxy\nend =\nstruct\n  (* Checks physical equality ([==]) of two internal promises. Unlike [==], does\n     not force unification of their invariants. *)\n  let identical p1 p2 =\n    (to_public_promise p1) == (to_public_promise p2)\n\n  (* [underlying p] evaluates to the underlying promise of [p].\n\n     If multiple [Proxy _] links are traversed, [underlying] updates all the\n     proxies to point immediately to their final underlying promise. *)\n  let rec underlying\n      : type u c. ('a, u, c) promise -> ('a, underlying, c) promise =\n    fun p ->\n\n    match p.state with\n    | Fulfilled _ -> (p : (_, underlying, _) promise)\n    | Rejected _ -> p\n    | Pending _ -> p\n    | Proxy p' ->\n      let p'' = underlying p' in\n      if not (identical p'' p') then\n        p.state <- Proxy p'';\n      p''\n\n\n\n  type ('a, 'u, 'c) state_changed =\n    | State_may_have_changed of ('a, 'u, 'c) promise\n    [@@ocaml.unboxed]\n\n  let set_promise_state p state =\n    let p : (_, _, _) promise = Obj.magic p in\n    p.state <- state;\n    State_may_have_changed p\n\n  (* [set_promise_state p state] mutates the state of [p], and evaluates to a\n     (wrapped) reference to [p] with the same invariants as on [state]. The\n     original reference [p] should be shadowed when calling this function:\n\n       let State_may_have_changed p = set_promise_state p (Fulfilled 42) in ...\n\n     This is a kind of cheap imitation of linear typing, which is good enough\n     for the needs of [lwt.ml].\n\n     Internal functions that transitively call [set_promise_state] likewise\n     return the new reference. This ends at some top-level function, typically\n     either a callback or a function in the public API. There, the new reference\n     is still bound, but is then explicitly ignored.\n\n     The state of a promise is never updated directly outside this module\n     [Basic_helpers]. All updates elsewhere are done through\n     [set_promise_state].\n\n     To avoid problems with type-level invariants not matching reality, data\n     structures do not store promises with concrete invariants -- except\n     resolved promises, which are immutable. Indeed, if one looks at\n     definitions of data structures that can store pending promises, e.g. the\n     [how_to_cancel] graph, the invariants are existentially quantified.\n\n     Note: it's possible to statically disallow the setting of the [state] field\n     by making type [promise] private. However, that seems to require writing a\n     signature that is a near-duplicate of [Main_internal_types], or some abuse\n     of functors. *)\n\n\n\n  type 'a may_now_be_proxy =\n    | State_may_now_be_pending_proxy :\n      ('a, _, pending) promise -> 'a may_now_be_proxy\n    [@@ocaml.unboxed]\n\n  let may_now_be_proxy p = State_may_now_be_pending_proxy p\n\n  (* Many functions, for example [Lwt.bind] and [Lwt.join], create a fresh\n     pending promise [p] and return it to the user.\n\n     They do not return a corresponding resolver. That means that only the\n     function itself (typically, a callback registered by it) can resolve [p].\n     The only thing the user can do directly is try to cancel [p], but, since\n     [p] is not an initial promise, the cancellation attempt simply propagates\n     past [p] to [p]'s predecessors. If that eventually results in canceling\n     [p], it will be through the normal mechanisms of the function (e.g.\n     [Lwt.bind]'s callback).\n\n     As a result, the only possible state change, before the callback, is that\n     [p] may have become a proxy. Now,\n\n     - If [p] does not undergo this state change and become a proxy, it remains\n       an underlying, pending promise.\n     - If [p] does become a proxy, it will be a proxy for another promise [p']\n       created fresh by [Lwt.bind], to which this same argument applies. See\n       [make_into_proxy].\n\n     So, by induction on the length of the proxy ([Proxy _]) chain, at the time\n     the callback is called, [p] is either an underlying, pending promise, or a\n     proxy for a pending promise.\n\n     The cast\n\n       let State_may_now_be_pending_proxy p = may_now_be_proxy p in ...\n\n     encodes the possibility of this state change. It replaces a reference\n\n       p : ('a, underlying, pending)\n\n     with\n\n       p : ('a, $Unknown, pending)\n\n     and is typically seen at the beginning of callbacks registered by\n     [Lwt.bind] and similar functions.\n\n     The cast is a no-op cast. The introduction and immediate elimination of\n     [State_may_have_changed _] seems to be optimized away even on old versions\n     of OCaml. *)\nend\nopen Basic_helpers\n\n(* Small helpers to avoid catching ocaml-runtime exceptions *)\nmodule Exception_filter = struct\n  type t = exn -> bool\n  let handle_all = fun _ -> true\n  let handle_all_except_runtime = function\n    | Out_of_memory -> false\n    | Stack_overflow -> false\n    | _ -> true\n  let v =\n    (* Default value: the legacy behaviour to avoid breaking programs *)\n    ref handle_all\n  let set f = v := f\n  let run e = !v e\nend\n\nmodule Sequence_associated_storage :\nsig\n  (* Public interface *)\n  type 'v key\n  val new_key : unit -> _ key\n  val get : 'v key -> 'v option\n  val with_value : 'v key -> 'v option -> (unit -> 'b) -> 'b\n\n  (* Internal interface *)\n  val current_storage : storage ref\nend =\nstruct\n  (* The idea behind sequence-associated storage is to preserve some values\n     during a call to [bind] or other sequential composition operation, and\n     restore those values in the callback function:\n\n       Lwt.with_value my_key (Some \"foo\") (fun () ->\n       p >|= fun () ->\n       assert (Lwt.get my_key = Some \"foo\"))\n         (* Will succeed even if this callback is called later. *)\n\n     Note that it does not matter that the callback is defined within an\n     argument of [with_value], i.e., this does the same:\n\n       let f = fun () -> assert (Lwt.get my_key = Some \"foo\") in\n       Lwt.with_value my_key (Some \"foo\") (fun () -> p >|= f)\n\n     All that matters is that the top-most sequencing operation (in this case,\n     map) is executed by that argument.\n\n     This is implemented using a single global heterogeneous key-value map.\n     Sequential composition functions snapshot this map when they are called,\n     and restore the snapshot right before calling the user's callback. The same\n     happens for cancel triggers added by [on_cancel].\n\n     Maintainer's note: I think using this mechanism should be discouraged in\n     new code. *)\n\n  type 'v key = {\n    id : int;\n    mutable value : 'v option;\n  }\n\n  let next_key_id = ref 0\n\n  let new_key () =\n    let id = !next_key_id in\n    next_key_id := id + 1;\n    {id = id; value = None}\n\n  let current_storage = ref Storage_map.empty\n\n  let get key =\n    if Storage_map.mem key.id !current_storage then begin\n      let refresh = Storage_map.find key.id !current_storage in\n      refresh ();\n      let value = key.value in\n      key.value <- None;\n      value\n    end\n    else\n      None\n\n  let with_value key value f =\n    let new_storage =\n      match value with\n      | Some _ ->\n        let refresh = fun () -> key.value <- value in\n        Storage_map.add key.id refresh !current_storage\n      | None ->\n        Storage_map.remove key.id !current_storage\n    in\n\n    let saved_storage = !current_storage in\n    current_storage := new_storage;\n    try\n      let result = f () in\n      current_storage := saved_storage;\n      result\n    with exn when Exception_filter.run exn ->\n      current_storage := saved_storage;\n      raise exn\nend\ninclude Sequence_associated_storage\n\n\n\nmodule Pending_callbacks :\nsig\n  (* Mutating callback lists attached to pending promises *)\n  val add_implicitly_removed_callback :\n    'a callbacks -> 'a regular_callback -> unit\n  val add_explicitly_removable_callback_to_each_of :\n    'a t list -> 'a regular_callback -> unit\n  val add_explicitly_removable_callback_and_give_remove_function :\n    'a t list -> 'a regular_callback -> cancel_callback\n  val add_cancel_callback : 'a callbacks -> cancel_callback -> unit\n  val merge_callbacks : from:'a callbacks -> into:'a callbacks -> unit\nend =\nstruct\n  let concat_regular_callbacks l1 l2 =\n    begin match l1, l2 with\n    | Regular_callback_list_empty, _ -> l2\n    | _, Regular_callback_list_empty -> l1\n    | _, _ -> Regular_callback_list_concat (l1, l2)\n    end [@ocaml.warning \"-4\"]\n\n  let concat_cancel_callbacks l1 l2 =\n    begin match l1, l2 with\n    | Cancel_callback_list_empty, _ -> l2\n    | _, Cancel_callback_list_empty -> l1\n    | _, _ -> Cancel_callback_list_concat (l1, l2)\n    end [@ocaml.warning \"-4\"]\n\n  (* In a callback list, filters out cells of explicitly removable callbacks\n     that have been removed. *)\n  let rec clean_up_callback_cells = function\n    | Regular_callback_list_explicitly_removable_callback {contents = None} ->\n      Regular_callback_list_empty\n\n    | Regular_callback_list_explicitly_removable_callback {contents = Some _}\n    | Regular_callback_list_implicitly_removed_callback _\n    | Regular_callback_list_empty as callbacks ->\n      callbacks\n\n    | Regular_callback_list_concat (l1, l2) ->\n      let l1 = clean_up_callback_cells l1 in\n      let l2 = clean_up_callback_cells l2 in\n      concat_regular_callbacks l1 l2\n\n  (* See [clear_explicitly_removable_callback_cell] and [merge_callbacks]. *)\n  let cleanup_throttle = 42\n\n  (* Explicitly removable callbacks are added (mainly) by [Lwt.choose] and its\n     similar functions. In [Lwt.choose [p; p']], if [p'] resolves first, the\n     callback added by [Lwt.choose] to [p] is removed.\n\n     The removal itself is accomplished when this function clears the reference\n     cell [cell], which contains the reference to that callback.\n\n     If [p] is a long-pending promise that repeatedly participates in\n     [Lwt.choose], perhaps in a loop, it will accumulate a large number of\n     cleared reference cells in this fashion. To avoid a memory leak, they must\n     be cleaned up. However, the cells are not cleaned up on *every* removal,\n     presumably because scanning the callback list that often, and rebuilding\n     it, can get expensive.\n\n     Cleanup is throttled by maintaining a counter, [cleanups_deferred], on each\n     pending promise. The counter is incremented each time this function wants\n     to clean the callback list (right after clearing a cell). When the counter\n     reaches [cleanup_throttle], the callback list is actually scanned and\n     cleared callback cells are removed. *)\n  let clear_explicitly_removable_callback_cell cell ~originally_added_to:ps =\n    cell := None;\n\n    (* Go through the promises the cell had originally been added to, and either\n       defer a cleanup, or actually clean up their callback lists. *)\n    ps |> List.iter (fun p ->\n      let Internal p = to_internal_promise p in\n      match (underlying p).state with\n      (* Some of the promises may already have been resolved at the time this\n         function is called. *)\n      | Fulfilled _ -> ()\n      | Rejected _ -> ()\n\n      | Pending callbacks ->\n        match callbacks.regular_callbacks with\n        (* If the promise has only one regular callback, and it is removable, it\n           must have been the cell cleared in this function, above. In that\n           case, just set its callback list to empty. *)\n        | Regular_callback_list_explicitly_removable_callback _ ->\n          callbacks.regular_callbacks <- Regular_callback_list_empty\n\n        (* Maintainer's note: I think this function shouldn't try to trigger a\n           cleanup in the first two cases, but I am preserving them for now, as\n           this is how the code was written in the past. *)\n        | Regular_callback_list_empty\n        | Regular_callback_list_implicitly_removed_callback _\n        | Regular_callback_list_concat _ ->\n          let cleanups_deferred = callbacks.cleanups_deferred + 1 in\n          if cleanups_deferred > cleanup_throttle then begin\n            callbacks.cleanups_deferred <- 0;\n            callbacks.regular_callbacks <-\n              clean_up_callback_cells callbacks.regular_callbacks\n          end else\n            callbacks.cleanups_deferred <- cleanups_deferred)\n\n  (* Concatenates both kinds of callbacks on [~from] to the corresponding lists\n     of [~into]. The callback lists on [~from] are *not* then cleared, because\n     this function is called only by [Sequential_composition.make_into_proxy],\n     which immediately changes the state of [~from] and loses references to the\n     original callback lists.\n\n     The [cleanups_deferred] fields of both promises are summed, and if the sum\n     exceeds [cleanup_throttle], a cleanup of regular callbacks is triggered.\n     This is to prevent memory leaks; see\n     [clear_explicitly_removable_callback_cell]. *)\n  let merge_callbacks ~from ~into =\n    let regular_callbacks =\n      concat_regular_callbacks into.regular_callbacks from.regular_callbacks in\n    let cleanups_deferred = into.cleanups_deferred + from.cleanups_deferred in\n\n    let regular_callbacks, cleanups_deferred =\n      if cleanups_deferred > cleanup_throttle then\n        clean_up_callback_cells regular_callbacks, 0\n      else\n        regular_callbacks, cleanups_deferred\n    in\n\n    let cancel_callbacks =\n      concat_cancel_callbacks into.cancel_callbacks from.cancel_callbacks in\n\n    into.regular_callbacks <- regular_callbacks;\n    into.cancel_callbacks <- cancel_callbacks;\n    into.cleanups_deferred <- cleanups_deferred\n\n\n\n  (* General, internal, function for adding a regular callback. *)\n  let add_regular_callback_list_node callbacks node =\n    callbacks.regular_callbacks <-\n      match callbacks.regular_callbacks with\n      | Regular_callback_list_empty ->\n        node\n      | Regular_callback_list_implicitly_removed_callback _\n      | Regular_callback_list_explicitly_removable_callback _\n      | Regular_callback_list_concat _ as existing ->\n        Regular_callback_list_concat (node, existing)\n\n  let add_implicitly_removed_callback callbacks f =\n    add_regular_callback_list_node\n      callbacks (Regular_callback_list_implicitly_removed_callback f)\n\n  (* Adds [callback] as removable to each promise in [ps]. The first promise in\n     [ps] to trigger [callback] removes [callback] from the other promises; this\n     guarantees that [callback] is called at most once. All the promises in [ps]\n     must be pending.\n\n     This is an internal function, indirectly used by the implementations of\n     [Lwt.choose] and related functions. *)\n  let add_explicitly_removable_callback_and_give_cell ps f =\n    let rec cell = ref (Some self_removing_callback_wrapper)\n    and self_removing_callback_wrapper result =\n      clear_explicitly_removable_callback_cell cell ~originally_added_to:ps;\n      f result\n    in\n\n    let node = Regular_callback_list_explicitly_removable_callback cell in\n    ps |> List.iter (fun p ->\n      let Internal p = to_internal_promise p in\n      match (underlying p).state with\n      | Pending callbacks -> add_regular_callback_list_node callbacks node\n      | Fulfilled _ -> assert false\n      | Rejected _ -> assert false);\n\n    cell\n\n  let add_explicitly_removable_callback_to_each_of ps f =\n    ignore (add_explicitly_removable_callback_and_give_cell ps f)\n\n  (* This is basically just to support [Lwt.protected], which needs to remove\n     the callback in circumstances other than the callback being called. *)\n  let add_explicitly_removable_callback_and_give_remove_function ps f =\n    let cell = add_explicitly_removable_callback_and_give_cell ps f in\n    fun () ->\n      clear_explicitly_removable_callback_cell cell ~originally_added_to:ps\n\n  let add_cancel_callback callbacks f =\n    let node = Cancel_callback_list_callback (!current_storage, f) in\n\n    callbacks.cancel_callbacks <-\n      match callbacks.cancel_callbacks with\n      | Cancel_callback_list_empty ->\n        node\n\n      | Cancel_callback_list_callback _\n      | Cancel_callback_list_remove_sequence_node _\n      | Cancel_callback_list_concat _ ->\n        Cancel_callback_list_concat (node, callbacks.cancel_callbacks)\nend\nopen Pending_callbacks\n\n\n\nmodule Resolution_loop :\nsig\n  (* All user-provided callbacks are called by Lwt only through this module. It\n     tracks the current callback stack depth, and decides whether each callback\n     call should be deferred or not. *)\n\n  (* Internal interface used only in this module Lwt *)\n  val resolve :\n    ?allow_deferring:bool ->\n    ?maximum_callback_nesting_depth:int ->\n    ('a, underlying, pending) promise ->\n    'a resolved_state ->\n      ('a, underlying, resolved) state_changed\n\n  val run_callbacks_or_defer_them :\n    ?allow_deferring:bool ->\n    ?maximum_callback_nesting_depth:int ->\n    ('a callbacks) ->\n    'a resolved_state ->\n      unit\n\n  val run_callback_or_defer_it :\n    ?run_immediately_and_ensure_tail_call:bool ->\n    callback:(unit -> 'a) ->\n    if_deferred:(unit -> 'a * 'b regular_callback * 'b resolved_state) ->\n      'a\n\n  val handle_with_async_exception_hook : ('a -> unit) -> 'a -> unit\n\n  (* Internal interface exposed to other modules in Lwt *)\n  val abandon_wakeups : unit -> unit\n\n  (* Public interface *)\n  exception Canceled\n\n  val async_exception_hook : (exn -> unit) ref\nend =\nstruct\n  (* When Lwt needs to call a callback, it enters the resolution loop. This\n     typically happens when Lwt sets the state of one promise to [Fulfilled _]\n     or [Rejected _]. The callbacks that were attached to the promise when it\n     was pending must then be called.\n\n     This also happens in a few other situations. For example, when [Lwt.bind]\n     is called on a promise, but that promise is already resolved, the callback\n     passed to [bind] must be called.\n\n     The callbacks triggered during the resolution loop might resolve more\n     promises, triggering more callbacks, and so on. This is what makes the\n     resolution loop a {e loop}.\n\n     Lwt generally tries to call each callback immediately. However, this can\n     lead to a progressive deepening of the call stack, until there is a stack\n     overflow. This can't be avoided by doing tail calls, because Lwt always\n     needs to do exception handling around callbacks calls: each callback call\n     is followed by an exception handler. Instead, what Lwt does is track the\n     current callback call depth. Once that depth reaches a certain number,\n     [default_maximum_callback_nesting_depth], defined below, further callbacks\n     are deferred into a queue instead. That queue is drained when Lwt exits\n     from the top-most callback call that triggered the resolution loop in the\n     first place.\n\n     To ensure that this deferral mechanism is always properly invoked, all\n     callbacks called by Lwt are called through one of three functions provided\n     by this module:\n\n     - [resolve], which calls all the callbacks associated to a pending promise\n       (and resolves it, changing its state).\n     - [run_callbacks_or_defer_them], which is internally used by [resolve] to\n       call callbacks that are in a record of type ['a callbacks], which records\n       are associated with pending promises. This function is exposed because\n       the current implementation of [Lwt.cancel] needs to call it directly.\n       Promise resolution and callback calling are separated in a unique way in\n       [cancel].\n     - [run_callback_or_defer_it], which is used by [Lwt.bind] and similar\n       functions to call single callbacks when the promises passed to\n       [Lwt.bind], etc., are already resolved.\n\n     Current Lwt actually has a messy mix of callback-calling behaviors. For\n     example, [Lwt.bind] is expected to always call its callback immediately,\n     while [Lwt.wakeup_later] is expected to defer all callbacks of the promise\n     resolved, {e unless} Lwt is not already inside the resolution loop.\n\n     We planned to make these behaviors uniform in Lwt 4.0.0, but decided\n     against it due to the risk of breaking users. See\n\n     - https://github.com/ocsigen/lwt/pull/500\n     - https://github.com/ocsigen/lwt/pull/519\n\n     As part of the preparation for the change, the above callback-invoking\n     functions support several optional arguments to emulate the various\n     behaviors. We decided not to remove this machinery, because we might want\n     to expose different APIs to Lwt in the future.\n\n     - [~allow_deferring:false] allows ignoring the callback stack depth, and\n       calling the callbacks immediately. This emulates the old resolution\n       behavior.\n     - [~maximum_callback_nesting_depth:1] allows limiting the depth which\n       triggers deferral on a per-call-site basis. This is used by\n       [Lwt.wakeup_later].\n     - [~run_immediately_and_ensure_tail_call:true] is like\n       [~allow_deferring:false], which ignores the callback stack depth.\n       However, to ensure that the callback is tail-called, Lwt doesn't even\n       update the callback stack depth for the benefit of *other* callback\n       calls. It just blindly calls the callback.\n\n     See discussion of callback-calling semantics in:\n\n       https://github.com/ocsigen/lwt/issues/329\n\n     * Context\n\n     The resolution loop effectively handles all promises that can be resolved\n     immediately, without blocking on I/O. A complete program that does I/O\n     calls [Lwt_main.run]. See \"No I/O\" in the Overview. *)\n\n\n\n  let async_exception_hook =\n    ref (fun exn ->\n      prerr_string \"Fatal error: exception \";\n      prerr_string (Printexc.to_string exn);\n      prerr_char '\\n';\n      Printexc.print_backtrace stderr;\n      flush stderr;\n      exit 2)\n\n  let handle_with_async_exception_hook f v =\n    (* Note that this function does not care if [f] evaluates to a promise. In\n       particular, if [f v] evaluates to [p] and [p] is already rejected or will\n       be reject later, it is not the responsibility of this function to pass\n       the exception to [!async_exception_hook]. *)\n    try f v\n    with exn when Exception_filter.run exn ->\n      !async_exception_hook exn\n\n\n\n  exception Canceled\n\n\n\n  (* Runs the callbacks (formerly) associated to a promise. Cancel callbacks are\n     run first, if the promise was canceled. These are followed by regular\n     callbacks.\n\n     The reason for the \"formerly\" is that the promise's state has already been\n     set to [Fulfilled _] or [Rejected _], so the callbacks are no longer\n     reachable through the promise reference. This is why the direct [callbacks]\n     record must be given to this function. *)\n  let run_callbacks\n      (callbacks : 'a callbacks)\n      (result : 'a resolved_state) : unit =\n\n    let run_cancel_callbacks fs =\n      let rec iter_callback_list fs rest =\n        match fs with\n        | Cancel_callback_list_empty ->\n          iter_list rest\n        | Cancel_callback_list_callback (storage, f) ->\n          current_storage := storage;\n          handle_with_async_exception_hook f ();\n          iter_list rest\n        | Cancel_callback_list_remove_sequence_node node ->\n          Lwt_sequence.remove node;\n          iter_list rest\n        | Cancel_callback_list_concat (fs, fs') ->\n          iter_callback_list fs (fs'::rest)\n\n      and iter_list rest =\n        match rest with\n        | [] -> ()\n        | fs::rest -> iter_callback_list fs rest\n\n      in\n\n      iter_callback_list fs []\n    in\n\n    let run_regular_callbacks fs =\n      let rec iter_callback_list fs rest =\n        match fs with\n        | Regular_callback_list_empty ->\n          iter_list rest\n        | Regular_callback_list_implicitly_removed_callback f ->\n          f result;\n          iter_list rest\n        | Regular_callback_list_explicitly_removable_callback\n            {contents = None} ->\n          iter_list rest\n        | Regular_callback_list_explicitly_removable_callback\n            {contents = Some f} ->\n          f result;\n          iter_list rest\n        | Regular_callback_list_concat (fs, fs') ->\n          iter_callback_list fs (fs'::rest)\n\n      and iter_list rest =\n        match rest with\n        | [] -> ()\n        | fs::rest -> iter_callback_list fs rest\n\n      in\n\n      iter_callback_list fs []\n    in\n\n    (* Pattern matching is much faster than polymorphic comparison. *)\n    let is_canceled =\n      match result with\n      | Rejected Canceled -> true\n      | Rejected _ -> false\n      | Fulfilled _ -> false\n    in\n    if is_canceled then\n      run_cancel_callbacks callbacks.cancel_callbacks;\n    run_regular_callbacks callbacks.regular_callbacks\n\n\n\n  let default_maximum_callback_nesting_depth = 42\n\n  let current_callback_nesting_depth = ref 0\n\n  type deferred_callbacks =\n    Deferred : ('a callbacks * 'a resolved_state) -> deferred_callbacks\n    [@@ocaml.unboxed]\n\n  let deferred_callbacks : deferred_callbacks Queue.t = Queue.create ()\n\n  (* Before entering a resolution loop, it is necessary to take a snapshot of\n     the current state of sequence-associated storage. This is because many of\n     the callbacks that will be run will modify the storage. The storage is\n     restored to the snapshot when the resolution loop is exited. *)\n  let enter_resolution_loop () =\n    current_callback_nesting_depth := !current_callback_nesting_depth + 1;\n    let storage_snapshot = !current_storage in\n    storage_snapshot\n\n  let leave_resolution_loop (storage_snapshot : storage) : unit =\n    if !current_callback_nesting_depth = 1 then begin\n      while not (Queue.is_empty deferred_callbacks) do\n        let Deferred (callbacks, result) = Queue.pop deferred_callbacks in\n        run_callbacks callbacks result\n      done\n    end;\n    current_callback_nesting_depth := !current_callback_nesting_depth - 1;\n    current_storage := storage_snapshot\n\n  let run_in_resolution_loop f =\n    let storage_snapshot = enter_resolution_loop () in\n    let result = f () in\n    leave_resolution_loop storage_snapshot;\n    result\n\n  (* This is basically a hack to fix https://github.com/ocsigen/lwt/issues/48.\n     If currently resolving promises, it immediately exits all recursive\n     entries of the resolution loop, goes to the top level, runs any deferred\n     callbacks, and exits the top-level resolution loop.\n\n     The name should probably be [abaondon_resolution_loop]. *)\n  let abandon_wakeups () =\n    if !current_callback_nesting_depth <> 0 then\n      leave_resolution_loop Storage_map.empty\n\n\n\n  let run_callbacks_or_defer_them\n      ?(allow_deferring = true)\n      ?(maximum_callback_nesting_depth = default_maximum_callback_nesting_depth)\n      callbacks result =\n\n    let should_defer =\n      allow_deferring\n      && !current_callback_nesting_depth >= maximum_callback_nesting_depth\n    in\n\n    if should_defer then\n      Queue.push (Deferred (callbacks, result)) deferred_callbacks\n    else\n      run_in_resolution_loop (fun () ->\n        run_callbacks callbacks result)\n\n  let resolve ?allow_deferring ?maximum_callback_nesting_depth p result =\n    let Pending callbacks = p.state in\n    let p = set_promise_state p result in\n\n    run_callbacks_or_defer_them\n      ?allow_deferring ?maximum_callback_nesting_depth callbacks result;\n\n    p\n\n  let run_callback_or_defer_it\n      ?(run_immediately_and_ensure_tail_call = false)\n      ~callback:f\n      ~if_deferred =\n\n    if run_immediately_and_ensure_tail_call then\n      f ()\n\n    else\n      let should_defer =\n        !current_callback_nesting_depth\n          >= default_maximum_callback_nesting_depth\n      in\n\n      if should_defer then begin\n        let immediate_result, deferred_callback, deferred_result =\n          if_deferred () in\n        let deferred_record =\n          {\n            regular_callbacks =\n              Regular_callback_list_implicitly_removed_callback\n                deferred_callback;\n            cancel_callbacks = Cancel_callback_list_empty;\n            how_to_cancel = Not_cancelable;\n            cleanups_deferred = 0\n          }\n        in\n        Queue.push\n          (Deferred (deferred_record, deferred_result)) deferred_callbacks;\n        immediate_result\n      end\n      else\n        run_in_resolution_loop (fun () ->\n          f ())\nend\ninclude Resolution_loop\n\n\n\nmodule Resolving :\nsig\n  val wakeup_later_result : 'a u -> ('a, exn) result -> unit\n  val wakeup_later : 'a u -> 'a -> unit\n  val wakeup_later_exn : _ u -> exn -> unit\n\n  val wakeup_result : 'a u -> ('a, exn) result -> unit\n  val wakeup : 'a u -> 'a -> unit\n  val wakeup_exn : _ u -> exn -> unit\n\n  val cancel : 'a t -> unit\nend =\nstruct\n  (* Note that this function deviates from the \"ideal\" callback deferral\n     behavior: it runs callbacks directly on the current stack. It should\n     therefore be possible to cause a stack overflow using this function. *)\n  let wakeup_general api_function_name r result =\n    let Internal p = to_internal_resolver r in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      ()\n    | Fulfilled _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n    | Rejected _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n\n    | Pending _ ->\n      let result = state_of_result result in\n      let State_may_have_changed p = resolve ~allow_deferring:false p result in\n      ignore p\n\n  let wakeup_result r result = wakeup_general \"wakeup_result\" r result\n  let wakeup r v = wakeup_general \"wakeup\" r (Ok v)\n  let wakeup_exn r exn = wakeup_general \"wakeup_exn\" r (Error exn)\n\n  let wakeup_later_general api_function_name r result =\n    let Internal p = to_internal_resolver r in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      ()\n    | Fulfilled _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n    | Rejected _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n\n    | Pending _ ->\n      let result = state_of_result result in\n      let State_may_have_changed p =\n        resolve ~maximum_callback_nesting_depth:1 p result in\n      ignore p\n\n  let wakeup_later_result r result =\n    wakeup_later_general \"wakeup_later_result\" r result\n  let wakeup_later r v =\n    wakeup_later_general \"wakeup_later\" r (Ok v)\n  let wakeup_later_exn r exn =\n    wakeup_later_general \"wakeup_later_exn\" r (Error exn)\n\n\n\n  type packed_callbacks =\n    | Packed : _ callbacks -> packed_callbacks\n    [@@ocaml.unboxed]\n\n  (* Note that this function deviates from the \"ideal\" callback deferral\n     behavior: it runs callbacks directly on the current stack. It should\n     therefore be possible to cause a stack overflow using this function. *)\n  let cancel p =\n    let canceled_result = Rejected Canceled in\n\n    (* Walks the promise dependency graph backwards, looking for cancelable\n       initial promises, and cancels (only) them.\n\n       Found initial promises are canceled immediately, as they are found, by\n       setting their state to [Rejected Canceled]. This is to prevent them from\n       being \"found twice\" if they are reachable by two or more distinct paths\n       through the promise dependency graph.\n\n       The callbacks of these initial promises are then run, in a separate\n       phase. These callbacks propagate cancellation forwards to any dependent\n       promises. See \"Cancellation\" in the Overview. *)\n    let propagate_cancel : (_, _, _) promise -> packed_callbacks list =\n        fun p ->\n      let rec cancel_and_collect_callbacks :\n          'a 'u 'c. packed_callbacks list -> ('a, 'u, 'c) promise ->\n            packed_callbacks list =\n          fun (type c) callbacks_accumulator (p : (_, _, c) promise) ->\n\n        let p = underlying p in\n        match p.state with\n        (* If the promise is not still pending, it can't be canceled. *)\n        | Fulfilled _ ->\n          callbacks_accumulator\n        | Rejected _ ->\n          callbacks_accumulator\n\n        | Pending callbacks ->\n          match callbacks.how_to_cancel with\n          | Not_cancelable ->\n            callbacks_accumulator\n          | Cancel_this_promise ->\n            let State_may_have_changed p =\n              set_promise_state p canceled_result in\n            ignore p;\n            (Packed callbacks)::callbacks_accumulator\n          | Propagate_cancel_to_one p' ->\n            cancel_and_collect_callbacks callbacks_accumulator p'\n          | Propagate_cancel_to_several ps ->\n            List.fold_left cancel_and_collect_callbacks callbacks_accumulator ps\n      in\n      cancel_and_collect_callbacks [] p\n    in\n\n    let Internal p = to_internal_promise p in\n    let callbacks = propagate_cancel p in\n\n    callbacks |> List.iter (fun (Packed callbacks) ->\n      run_callbacks_or_defer_them\n        ~allow_deferring:false callbacks canceled_result)\nend\ninclude Resolving\n\n\n\nmodule Trivial_promises :\nsig\n  val return : 'a -> 'a t\n  val fail : exn -> _ t\n  val of_result : ('a, exn) result -> 'a t\n\n  val return_unit : unit t\n  val return_true : bool t\n  val return_false : bool t\n  val return_none : _ option t\n  val return_some : 'a -> 'a option t\n  val return_ok : 'a -> ('a, _) result t\n  val return_error : 'e -> (_, 'e) result t\n  val return_nil : _ list t\n\n  val fail_with : string -> _ t\n  val fail_invalid_arg : string -> _ t\nend =\nstruct\n  let return v =\n    to_public_promise {state = Fulfilled v}\n\n  let of_result result =\n    to_public_promise {state = state_of_result result}\n\n  let fail exn =\n    to_public_promise {state = Rejected exn}\n\n  let return_unit = return ()\n  let return_none = return None\n  let return_some x = return (Some x)\n  let return_nil = return []\n  let return_true = return true\n  let return_false = return false\n  let return_ok x = return (Ok x)\n  let return_error x = return (Error x)\n\n  let fail_with msg =\n    to_public_promise {state = Rejected (Failure msg)}\n\n  let fail_invalid_arg msg =\n    to_public_promise {state = Rejected (Invalid_argument msg)}\nend\ninclude Trivial_promises\n\n\n\nmodule Pending_promises :\nsig\n  (* Internal *)\n  val new_pending :\n    how_to_cancel:how_to_cancel -> ('a, underlying, pending) promise\n  val propagate_cancel_to_several : _ t list -> how_to_cancel\n\n  (* Initial pending promises (public) *)\n  val wait : unit -> 'a t * 'a u\n  val task : unit -> 'a t * 'a u\n\n  val add_task_r : 'a u Lwt_sequence.t -> 'a t\n  val add_task_l : 'a u Lwt_sequence.t -> 'a t\n\n  val protected : 'a t -> 'a t\n  val no_cancel : 'a t -> 'a t\nend =\nstruct\n  let new_pending ~how_to_cancel =\n    let state =\n      Pending {\n        regular_callbacks = Regular_callback_list_empty;\n        cancel_callbacks = Cancel_callback_list_empty;\n        how_to_cancel;\n        cleanups_deferred = 0;\n      }\n    in\n    {state}\n\n  let propagate_cancel_to_several ps =\n    (* Using a dirty cast here to avoid rebuilding the list :( Not bothering\n       with the invariants, because [Propagate_cancel_to_several] packs them,\n       and code that matches on [Propagate_cancel_to_several] doesn't care about\n       them anyway. *)\n    let cast_promise_list : 'a t list -> ('a, _, _) promise list = Obj.magic in\n    Propagate_cancel_to_several (cast_promise_list ps)\n\n\n\n  let wait () =\n    let p = new_pending ~how_to_cancel:Not_cancelable in\n    to_public_promise p, to_public_resolver p\n\n  let task () =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    to_public_promise p, to_public_resolver p\n\n\n\n\n  let cast_sequence_node\n      (node : 'a u Lwt_sequence.node)\n      (_actual_content:('a, 'u, 'c) promise)\n        : ('a, 'u, 'c) promise Lwt_sequence.node =\n    Obj.magic node\n\n  let add_task_r sequence =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    let node = Lwt_sequence.add_r (to_public_resolver p) sequence in\n    let node = cast_sequence_node node p in\n\n    let Pending callbacks = p.state in\n    callbacks.cancel_callbacks <-\n      Cancel_callback_list_remove_sequence_node node;\n\n    to_public_promise p\n\n  let add_task_l sequence =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    let node = Lwt_sequence.add_l (to_public_resolver p) sequence in\n    let node = cast_sequence_node node p in\n\n    let Pending callbacks = p.state in\n    callbacks.cancel_callbacks <-\n      Cancel_callback_list_remove_sequence_node node;\n\n    to_public_promise p\n\n\n\n  let protected p =\n    let Internal p_internal = to_internal_promise p in\n    match (underlying p_internal).state with\n    | Fulfilled _ -> p\n    | Rejected _ -> p\n\n    | Pending _ ->\n      let p' = new_pending ~how_to_cancel:Cancel_this_promise in\n\n      let callback p_result =\n        let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n        let p' = underlying p' in\n        (* In this callback, [p'] will either still itself be pending, or it\n           will have become a proxy for a pending promise. The reasoning for\n           this is almost the same as in the comment at [may_now_be_proxy]. The\n           differences are:\n\n           - [p'] *is* an initial promise, so it *can* get canceled. However, if\n             it does, the [on_cancel] handler installed below will remove this\n             callback.\n           - [p'] never gets passed to [make_into_proxy], the only effect of\n             which is that it cannot be the underlying promise of another\n             (proxy) promise. So, [p'] can only appear at the head of a chain of\n             [Proxy _] links, and it's not necessary to worry about whether the\n             inductive reasoning at [may_now_be_proxy] applies. *)\n\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false p' p_result in\n        ignore p'\n      in\n\n      let remove_the_callback =\n        add_explicitly_removable_callback_and_give_remove_function\n          [p] callback\n      in\n\n      let Pending p'_callbacks = p'.state in\n      add_cancel_callback p'_callbacks remove_the_callback;\n\n      to_public_promise p'\n\n  let no_cancel p =\n    let Internal p_internal = to_internal_promise p in\n    match (underlying p_internal).state with\n    | Fulfilled _ -> p\n    | Rejected _ -> p\n\n    | Pending p_callbacks ->\n      let p' = new_pending ~how_to_cancel:Not_cancelable in\n\n      let callback p_result =\n        let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n        let p' = underlying p' in\n        (* In this callback, [p'] will either still itself be pending, or it\n           will have become a proxy for a pending promise. The reasoning for\n           this is as in [protected] and [may_now_be_proxy], but even simpler,\n           because [p'] is not cancelable. *)\n\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false p' p_result in\n        ignore p'\n      in\n      add_implicitly_removed_callback p_callbacks callback;\n\n      to_public_promise p'\nend\ninclude Pending_promises\n\n\n\nmodule Sequential_composition :\nsig\n  (* Main interface (public) *)\n  val bind : 'a t -> ('a -> 'b t) -> 'b t\n  val map : ('a -> 'b) -> 'a t -> 'b t\n  external reraise : exn -> 'a = \"%reraise\"\n  val catch : (unit -> 'a t) -> (exn -> 'a t) -> 'a t\n  val finalize : (unit -> 'a t) -> (unit -> unit t) -> 'a t\n  val try_bind : (unit -> 'a t) -> ('a -> 'b t) -> (exn -> 'b t) -> 'b t\n\n  (* Cancel callbacks (public). *)\n  val on_cancel : 'a t -> (unit -> unit) -> unit\n\n  (* Non-promise callbacks (public) *)\n  val on_success : 'a t -> ('a -> unit) -> unit\n  val on_failure : _ t -> (exn -> unit) -> unit\n  val on_termination : _ t -> (unit -> unit) -> unit\n  val on_any : 'a t -> ('a -> unit) -> (exn -> unit) -> unit\n\n  (* Backtrace support (internal; for use by the PPX) *)\n  val backtrace_bind :\n    (exn -> exn) -> 'a t -> ('a -> 'b t) -> 'b t\n  val backtrace_catch :\n    (exn -> exn) -> (unit -> 'a t) -> (exn -> 'a t) -> 'a t\n  val backtrace_finalize :\n    (exn -> exn) -> (unit -> 'a t) -> (unit -> unit t) -> 'a t\n  val backtrace_try_bind :\n    (exn -> exn) -> (unit -> 'a t) -> ('a -> 'b t) -> (exn -> 'b t) -> 'b t\nend =\nstruct\n  (* There are five primary sequential composition functions: [bind], [map],\n     [catch], [finalize], and [try_bind]. Of these, [try_bind] is the most\n     general -- all the others can be implemented in terms of it.\n\n     Lwt conflates concurrency with error propagation. If Lwt did not do this,\n     there would be only two primary functions: [bind] and [map], and, of these\n     two, [bind] is the most general. Since [bind] is the most relevant\n     specifically to concurrency, and is also the most familiar function in Lwt,\n     its implementation serves as a kind of \"model\" for the rest. It is the most\n     commented, and all the other functions follow a similar pattern to [bind].\n\n     Four of the primary functions have [backtrace_*] versions, which are not\n     truly public, and exist to support the PPX. [backtrace_map] does not exist\n     because the PPX does not need it.\n\n     The remaining four functions in this section attach \"lower-level-ish\"\n     non-promise-producing callbacks to promises: these are the [on_*]\n     functions. Of these, [on_any] is the most general. If Lwt did not conflate\n     concurrency with error handling, there would only be one: [on_success]. *)\n\n\n\n  (* Makes [~user_provided_promise] into a proxy of [~outer_promise]. After\n     [make_into_proxy], these two promise references \"behave identically.\"\n\n     Note that this is not symmetric: [user_provided_promise] always becomes the\n     proxy. [make_into_proxy] is called only by [bind] and similar functions in\n     this module. This means that:\n\n     - the only way for a promise to become a proxy is by being returned from\n       the callback given by the user to [bind], or a similar function, and\n     - the only way for a promise to become underlying for a promise other than\n       itself is to be the outer promise originally returned to the user from\n       [bind], or a similar function.\n\n     These two facts are important for reasoning about how and which promises\n     can become proxies, underlying, etc.; in particular, it is used in the\n     argument in [may_now_be_proxy] for correct predictions about state changes.\n\n     [~outer_promise] is always a pending promise when [make_into_proxy] is\n     called; for the explanation, see [may_now_be_proxy] (though the caller of\n     [make_into_proxy] always calls [underlying] first to pass the underlying\n     pending promise to [make_into_proxy]).\n\n     The reasons proxying is used, instead of adding a callback to\n     [~user_provided_promise] to resolve [~outer_promise] when the former\n     becomes resolved probably are:\n\n     - Promises have more behaviors than resolution. One would have to add a\n       cancellation handler to [~outer_promise] to propagate the cancellation\n       back to [~user_provided_promise], for example. It may be easier to just\n       think of them as the same promise.\n     - If using callbacks, resolving [~user_provided_promise] would not\n       immediately resolve [~outer_promise]. Another callback added to\n       [~user_provided_promise] might see [~user_provided_promise] resolved,\n       but [~outer_promise] still pending, depending on the order in which\n       callbacks are run. *)\n  let make_into_proxy\n      (type c)\n      ~(outer_promise : ('a, underlying, pending) promise)\n      ~(user_provided_promise : ('a, _, c) promise)\n        : ('a, underlying, c) state_changed =\n\n    (* Using [p'] as it's the name used inside [bind], etc., for promises with\n       this role -- [p'] is the promise returned by the user's function. *)\n    let p' = underlying user_provided_promise in\n\n    if identical p' outer_promise then\n      State_may_have_changed p'\n      (* We really want to return [State_may_have_changed outer_promise], but\n         the reference through [p'] has the right type. *)\n\n    else\n      match p'.state with\n      | Fulfilled _ ->\n        resolve ~allow_deferring:false outer_promise p'.state\n      | Rejected _ ->\n        resolve ~allow_deferring:false outer_promise p'.state\n\n      | Pending p'_callbacks ->\n        let Pending outer_callbacks = outer_promise.state in\n\n        merge_callbacks ~from:p'_callbacks ~into:outer_callbacks;\n        outer_callbacks.how_to_cancel <- p'_callbacks.how_to_cancel;\n\n        let State_may_have_changed p' =\n          set_promise_state p' (Proxy outer_promise) in\n        ignore p';\n\n        State_may_have_changed outer_promise\n        (* The state hasn't actually changed, but we still have to wrap\n           [outer_promise] for type checking. *)\n\n        (* The state of [p'] may instead have changed -- it may have become a\n           proxy. However, callers of [make_into_proxy] don't know if\n           [user_provided_promise] was a proxy or not (that's why we call\n           underlying on it at the top of this function, to get [p']). We can\n           therefore take a dangerous shortcut and not bother returning a new\n           reference to [user_provided_promise] for shadowing. *)\n\n\n\n  (* Maintainer's note: a lot of the code below can probably be deduplicated in\n     some way, especially if assuming Flambda. *)\n\n  let bind p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    (* In case [Lwt.bind] needs to defer the call to [f], this function will be\n       called to create:\n\n       1. The promise, [p''], that must be returned to the caller immediately.\n       2. The callback that resolves [p''].\n\n       [Lwt.bind] defers the call to [f] in two circumstances:\n\n       1. The promise [p] is pending.\n       2. The promise [p] is fulfilled, but the current callback call nesting\n          depth is such that the call to [f] must go into the callback queue, in\n          order to avoid stack overflow.\n\n      Mechanism (2) is currently disabled. It may be used in an alternative Lwt\n      API.\n\n      Functions other than [Lwt.bind] have analogous deferral behavior. *)\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n      (* The result promise is a fresh pending promise.\n\n         Initially, trying to cancel this fresh pending promise [p''] will\n         propagate the cancellation attempt to [p] (backwards through the\n         promise dependency graph). If/when [p] is fulfilled, Lwt will call the\n         user's callback [f] below, which will provide a new promise [p'], and\n         [p'] will become a proxy of [p'']. At that point, trying to cancel\n         [p''] will be equivalent to trying to cancel [p'], so the behavior will\n         depend on how the user obtained [p']. *)\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f v with exn\n            when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n          (* Run the user's function [f]. *)\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n          (* [p''] was an underlying promise when it was created above, but it\n             may have become a proxy by the time this code is being executed.\n             However, it is still either an underlying pending promise, or a\n             proxy for a pending promise. Therefore, [may_now_be_proxy] produces\n             a reference with the right type variables. We immediately get\n             [p'']'s current underlying promise. *)\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n          (* Make the outer promise [p''] behaviorally identical to the promise\n             [p'] returned by [f] by making [p'] into a proxy of [p'']. *)\n\n        | Rejected _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected _ as result ->\n      to_public_promise {state = result}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_bind add_loc p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f v\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn) in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' (Rejected (add_loc exn)) in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      to_public_promise {state = Rejected (add_loc exn)}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let map f p =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p''_result =\n            try Fulfilled (f v) with exn\n            when Exception_filter.run exn -> Rejected exn\n          in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p''_result in\n          ignore p''\n\n        | Rejected _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () ->\n          to_public_promise\n            {state =\n              try Fulfilled (f v)\n              with exn when Exception_filter.run exn -> Rejected exn})\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected _ as result ->\n      to_public_promise {state = result}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let catch f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      to_public_promise p\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h exn)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_catch add_loc f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      to_public_promise p\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h (add_loc exn))\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let try_bind f f' h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f' v\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f' v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h exn)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_try_bind add_loc f f' h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f' v\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f' v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h (add_loc exn))\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let finalize f f' =\n    try_bind f\n      (fun x -> bind (f' ()) (fun () -> return x))\n      (fun e -> bind (f' ()) (fun () -> fail e))\n\n  let backtrace_finalize add_loc f f' =\n    backtrace_try_bind add_loc f\n      (fun x -> bind (f' ()) (fun () -> return x))\n      (fun e -> bind (f' ()) (fun () -> fail (add_loc e)))\n\n\n\n  let on_cancel p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          ((), (fun _ -> handle_with_async_exception_hook f ()), Fulfilled ()))\n\n    | Rejected _ ->\n      ()\n\n    | Fulfilled _ ->\n      ()\n\n    | Pending callbacks ->\n      add_cancel_callback callbacks f\n\n\n\n  let on_success p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f v\n\n        | Rejected _ ->\n          ()\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f v)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected _ ->\n      ()\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_failure p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled _ ->\n          ()\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f exn\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      ()\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f exn)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_termination p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun _result ->\n        current_storage := saved_storage;\n        handle_with_async_exception_hook f ()\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected _ ->\n      run_callback_or_defer_it\n      ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_any p f g =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f v\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook g exn\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f v)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook g exn)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\nend\ninclude Sequential_composition\n\n\n(* This belongs with the [protected] and such, but it depends on primitives from\n   [Sequential_composition]. *)\nlet wrap_in_cancelable p =\n let Internal p_internal = to_internal_promise p in\n let p_underlying = underlying p_internal in\n match p_underlying.state with\n | Fulfilled _ -> p\n | Rejected _ -> p\n | Pending _ ->\n   let p', r = task () in\n   on_cancel p' (fun () -> cancel p);\n   on_any p (wakeup r) (wakeup_exn r);\n   p'\n\n\nmodule Concurrent_composition :\nsig\n  val dont_wait : (unit -> _ t) -> (exn -> unit) -> unit\n  val async : (unit -> _ t) -> unit\n  val ignore_result : _ t -> unit\n\n  val both : 'a t -> 'b t -> ('a * 'b) t\n  val join : unit t list -> unit t\n  val all : ('a t) list -> ('a list) t\n\n  val choose : 'a t list -> 'a t\n  val pick : 'a t list -> 'a t\n\n  val nchoose : 'a t list -> 'a list t\n  val npick : 'a t list -> 'a list t\n\n  val nchoose_split : 'a t list -> ('a list * 'a t list) t\nend =\nstruct\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let dont_wait f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      h exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          h exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let async f =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      !async_exception_hook exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          !async_exception_hook exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let ignore_result p =\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      reraise exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          !async_exception_hook exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n\n\n  let join ps =\n    let p' = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n    let number_pending_in_ps = ref 0 in\n    let join_result = ref (Fulfilled ()) in\n\n    (* Callback attached to each promise in [ps] that is still pending at the\n       time [join] is called. *)\n    let callback new_result =\n      let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n\n      begin match new_result with\n      | Fulfilled () -> ()\n      | Rejected _ ->\n      (* For the first promise in [ps] to be rejected, set the result of the\n         [join] to rejected with the same exception.. *)\n        match !join_result with\n        | Fulfilled () -> join_result := new_result\n        | Rejected _ -> ()\n      end;\n\n      (* In all cases, decrement the number of promises still pending, and\n         resolve the [join] once all promises resolve. *)\n      number_pending_in_ps := !number_pending_in_ps - 1;\n      if !number_pending_in_ps = 0 then begin\n        let p' = underlying p' in\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false (underlying p') !join_result in\n        ignore p'\n      end\n    in\n\n    (* Attach the above callback. Simultaneously count how many pending promises\n       there are in [ps] (initially). If that number is zero, the [join] must\n       resolve immediately. *)\n    let rec attach_callback_or_resolve_immediately ps =\n      match ps with\n      | [] ->\n        if !number_pending_in_ps = 0 then\n          to_public_promise {state = !join_result}\n        else\n          to_public_promise p'\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n\n        match (underlying p).state with\n        | Pending p_callbacks ->\n          number_pending_in_ps := !number_pending_in_ps + 1;\n          add_implicitly_removed_callback p_callbacks callback;\n          attach_callback_or_resolve_immediately ps\n\n        | Rejected _ as p_result ->\n          (* As in the callback above, but for already-resolved promises in\n             [ps]: reject the [join] with the same exception as in the first\n             rejected promise found. [join] still waits for any pending promises\n             before actually resolving, though. *)\n          begin match !join_result with\n          | Fulfilled () -> join_result := p_result;\n          | Rejected _ -> ()\n          end;\n          attach_callback_or_resolve_immediately ps\n\n        | Fulfilled () ->\n          attach_callback_or_resolve_immediately ps\n    in\n\n    attach_callback_or_resolve_immediately ps\n\n  (* this is 3 words, smaller than the 2 times 2 words a pair of references\n     would take. *)\n  type ('a,'b) pair = {\n    mutable x1: 'a option;\n    mutable x2: 'b option;\n  }\n\n  let both p1 p2 =\n    let pair = {x1 = None; x2 = None} in\n    let p1' = bind p1 (fun v -> pair.x1 <- Some v; return_unit) in\n    let p2' = bind p2 (fun v -> pair.x2 <- Some v; return_unit) in\n    join [p1'; p2'] |> map (fun () ->\n      match pair.x1, pair.x2 with\n      | Some v1, Some v2 -> v1, v2\n      | _ -> assert false)\n\n  let all ps =\n    match ps with\n    | [] -> return_nil\n    | [x] -> map (fun y -> [y]) x\n    | [x; y] -> map (fun (x, y) -> [x; y]) (both x y)\n    | _ ->\n      let vs = Array.make (List.length ps) None in\n      ps\n      |> List.mapi (fun index p ->\n        bind p (fun v -> vs.(index) <- Some v; return_unit))\n      |> join\n      |> map (fun () ->\n          let rec to_list_unopt i acc =\n            if i < 0 then\n              acc\n            else\n              match Array.unsafe_get vs i with\n              | None -> assert false\n              | Some x -> to_list_unopt (i - 1) (x::acc)\n          in\n          to_list_unopt (Array.length vs - 1) [])\n\n  (* Maintainer's note: the next few functions are helpers for [choose] and\n     [pick]. Perhaps they should be factored into some kind of generic\n     [choose]/[pick] implementation, which may actually be optimal anyway with\n     Flambda. *)\n\n  let count_resolved_promises_in (ps : 'a t list) =\n    let rec count_and_gather_rejected total rejected ps =\n       match ps with\n       | [] -> Error (total, rejected)\n       | p :: ps ->\n            let Internal q = to_internal_promise p in\n            match (underlying q).state with\n            | Fulfilled _ -> count_and_gather_rejected total rejected ps\n            | Rejected _ -> count_and_gather_rejected (total + 1) (p :: rejected) ps\n            | Pending _ -> count_and_gather_rejected total rejected ps\n    in\n    let rec count_fulfilled total ps =\n       match ps with\n       | [] -> Ok total\n       | p :: ps ->\n            let Internal q = to_internal_promise p in\n            match (underlying q).state with\n            | Fulfilled _ -> count_fulfilled (total + 1) ps\n            | Rejected _ -> count_and_gather_rejected 1 [p] ps\n            | Pending _ -> count_fulfilled total ps\n    in\n    count_fulfilled 0 ps\n\n  (* Evaluates to the [n]th promise in [ps], among only those promises in [ps]\n     that are resolved. The caller is expected to ensure that there are at\n     least [n] resolved promises in [ps]. *)\n  let rec nth_resolved (ps : 'a t list) (n : int) : 'a t =\n    match ps with\n    | [] ->\n      assert false\n\n    | p::ps ->\n      let Internal p' = to_internal_promise p in\n      match (underlying p').state with\n      | Pending _ ->\n        nth_resolved ps n\n\n      | Fulfilled _ ->\n        if n <= 0 then p\n        else nth_resolved ps (n - 1)\n      | Rejected _ ->\n        if n <= 0 then p\n        else nth_resolved ps (n - 1)\n\n  (* Like [nth_resolved], but cancels all pending promises found while\n     traversing [ps]. *)\n  let rec nth_resolved_and_cancel_pending (ps : 'a t list) (n : int) : 'a t =\n    match ps with\n    | [] ->\n      assert false\n\n    | p::ps ->\n      let Internal p' = to_internal_promise p in\n      match (underlying p').state with\n      | Pending _ ->\n        cancel p;\n        nth_resolved_and_cancel_pending ps n\n\n      | Fulfilled _ ->\n        if n <= 0 then (List.iter cancel ps; p)\n        else nth_resolved_and_cancel_pending ps (n - 1)\n      | Rejected _ ->\n        if n <= 0 then (List.iter cancel ps; p)\n        else nth_resolved_and_cancel_pending ps (n - 1)\n\n  (* The PRNG state is initialized with a constant to make non-IO-based programs\n     deterministic. *)\n  (* Maintainer's note: is this necessary? *)\n  let prng = lazy (Random.State.make [||])\n\n  let choose ps =\n    if ps = [] then\n      invalid_arg\n        \"Lwt.choose [] would return a promise that is pending forever\";\n    match count_resolved_promises_in ps with\n    | Ok 0 ->\n      let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n      let callback result =\n        let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n        let p = underlying p in\n        let State_may_have_changed p =\n          resolve ~allow_deferring:false p result in\n        ignore p\n      in\n      add_explicitly_removable_callback_to_each_of ps callback;\n\n      to_public_promise p\n\n    | Ok 1 ->\n      nth_resolved ps 0\n\n    | Ok n ->\n      nth_resolved ps (Random.State.int (Lazy.force prng) n)\n\n    | Error (n, ps) ->\n      nth_resolved ps (Random.State.int (Lazy.force prng) n)\n\n  let pick ps =\n    if ps = [] then\n      invalid_arg \"Lwt.pick [] would return a promise that is pending forever\";\n    match count_resolved_promises_in ps with\n    | Ok 0 ->\n      let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n      let callback result =\n        let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n        List.iter cancel ps;\n        let p = underlying p in\n        let State_may_have_changed p =\n          resolve ~allow_deferring:false p result in\n        ignore p\n      in\n      add_explicitly_removable_callback_to_each_of ps callback;\n\n      to_public_promise p\n\n    | Ok 1 ->\n      nth_resolved_and_cancel_pending ps 0\n\n    | Ok n ->\n      nth_resolved_and_cancel_pending ps\n        (Random.State.int (Lazy.force prng) n)\n\n    | Error (n, qs) ->\n      List.iter cancel ps;\n      nth_resolved qs (Random.State.int (Lazy.force prng) n)\n\n\n\n  (* If [nchoose ps] or [npick ps] found all promises in [ps] pending, the\n     callback added to each promise in [ps] eventually calls this function. The\n     function collects promises in [ps] that have become fulfilled, or finds one\n     promise in [ps] that has been rejected. It then returns the desired state\n     of the final promise: either the list of results collected, or the\n     exception found. *)\n  let rec collect_fulfilled_promises_after_pending\n      (results : 'a list)\n      (ps : 'a t list) :\n        ('a list resolved_state) =\n\n    match ps with\n    | [] ->\n      Fulfilled (List.rev results)\n\n    | p::ps ->\n      let Internal p = to_internal_promise p in\n\n      match (underlying p).state with\n      | Fulfilled v ->\n        collect_fulfilled_promises_after_pending (v::results) ps\n\n      | Rejected _ as result ->\n        result\n\n      | Pending _ ->\n        collect_fulfilled_promises_after_pending results ps\n\n  let nchoose ps =\n    (* If at least one promise in [ps] is found fulfilled, this function is\n       called to find all such promises. *)\n    if ps = [] then\n      invalid_arg\n        \"Lwt.nchoose [] would return a promise that is pending forever\";\n    let rec collect_already_fulfilled_promises_or_find_rejected acc ps =\n      match ps with\n      | [] ->\n        return (List.rev acc)\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected (v::acc) ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_fulfilled_promises_or_find_rejected acc ps\n    in\n\n    (* Looks for already-resolved promises in [ps]. If none are fulfilled or\n       rejected, adds a callback to all promises in [ps] (all of which are\n       pending). *)\n    let rec check_for_already_resolved_promises ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let result = collect_fulfilled_promises_after_pending [] ps in\n          let State_may_have_changed p =\n            resolve ~allow_deferring:false p result in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected [v] ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises ps\n    in\n\n    let p = check_for_already_resolved_promises ps in\n    p\n\n  (* See [nchoose]. This function differs only in having additional calls to\n     [cancel]. *)\n  let npick ps =\n    if ps = [] then\n      invalid_arg \"Lwt.npick [] would return a promise that is pending forever\";\n    let rec collect_already_fulfilled_promises_or_find_rejected acc ps' =\n      match ps' with\n      | [] ->\n        List.iter cancel ps;\n        return (List.rev acc)\n\n      | p::ps' ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected (v::acc) ps'\n\n        | Rejected _ as result ->\n          List.iter cancel ps;\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_fulfilled_promises_or_find_rejected acc ps'\n    in\n\n    let rec check_for_already_resolved_promises ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let result = collect_fulfilled_promises_after_pending [] ps in\n          List.iter cancel ps;\n          let State_may_have_changed p =\n            resolve ~allow_deferring:false p result in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps' ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected [v] ps'\n\n        | Rejected _ as result ->\n          List.iter cancel ps;\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises ps'\n    in\n\n    let p = check_for_already_resolved_promises ps in\n    p\n\n\n\n  (* Same general pattern as [npick] and [nchoose]. *)\n  let nchoose_split ps =\n    if ps = [] then\n      invalid_arg\n        \"Lwt.nchoose_split [] would return a promise that is pending forever\";\n    let rec finish\n        (to_resolve : ('a list * 'a t list, underlying, pending) promise)\n        (fulfilled : 'a list)\n        (pending : 'a t list)\n        (ps : 'a t list)\n          : ('a list * 'a t list, underlying, resolved) state_changed =\n\n      match ps with\n      | [] ->\n        resolve ~allow_deferring:false to_resolve\n          (Fulfilled (List.rev fulfilled, List.rev pending))\n\n      | p::ps ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          finish to_resolve (v::fulfilled) pending ps\n\n        | Rejected _ as result ->\n          resolve ~allow_deferring:false to_resolve result\n\n        | Pending _ ->\n          finish to_resolve fulfilled (p::pending) ps\n    in\n\n    let rec collect_already_resolved_promises results pending ps =\n      match ps with\n      | [] ->\n        (* Maintainer's note: should the pending promise list also be\n           reversed? It is reversed in finish. *)\n        return (List.rev results, pending)\n\n      | p::ps ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          collect_already_resolved_promises (v::results) pending ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_resolved_promises results (p::pending) ps\n    in\n\n    let rec check_for_already_resolved_promises pending_acc ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let State_may_have_changed p = finish p [] [] ps in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps' ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          collect_already_resolved_promises [v] pending_acc ps'\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises (p::pending_acc) ps'\n    in\n\n    let p = check_for_already_resolved_promises [] ps in\n    p\nend\ninclude Concurrent_composition\n\n\n\nmodule Miscellaneous :\nsig\n  (* Promise state query *)\n  type 'a state =\n    | Return of 'a\n    | Fail of exn\n    | Sleep\n\n  val state : 'a t -> 'a state\n  val is_sleeping : 'a t -> bool\n  val debug_state_is : 'a state -> 'a t -> bool t\n\n  (* Function lifters *)\n  val apply : ('a -> 'b t) -> 'a -> 'b t\n\n  val wrap :\n    (unit -> 'b) ->\n    'b t\n  val wrap1 :\n    ('a1 -> 'b) ->\n    ('a1 -> 'b t)\n  val wrap2 :\n    ('a1 -> 'a2 -> 'b) ->\n    ('a1 -> 'a2 -> 'b t)\n  val wrap3 :\n    ('a1 -> 'a2 -> 'a3 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'b t)\n  val wrap4 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'b t)\n  val wrap5 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'b t)\n  val wrap6 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'b t)\n  val wrap7 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'a7 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'a7 -> 'b t)\n\n  (* Paused promises *)\n  val pause : unit -> unit t\n  val wakeup_paused : unit -> unit\n  val paused_count : unit -> int\n  val register_pause_notifier : (int -> unit) -> unit\n  val abandon_paused : unit -> unit\n\n  (* Internal interface for other modules in Lwt *)\n  val poll : 'a t -> 'a option\nend =\nstruct\n  type 'a state =\n    | Return of 'a\n    | Fail of exn\n    | Sleep\n\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let state p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Fulfilled v -> Return v\n    | Rejected exn -> Fail exn\n    | Pending _ -> Sleep\n\n  let debug_state_is expected_state p =\n    return (state p = expected_state)\n\n  let is_sleeping p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Fulfilled _ -> false\n    | Rejected _ -> false\n    | Pending _ -> true\n\n  let poll p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Rejected e -> reraise e\n    | Fulfilled v -> Some v\n    | Pending _ -> None\n\n\n\n  let apply f x =\n    try f x with exn when Exception_filter.run exn -> fail exn\n\n  let wrap f =\n    try return (f ())\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap1 f x1 =\n    try return (f x1)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap2 f x1 x2 =\n    try return (f x1 x2)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap3 f x1 x2 x3 =\n    try return (f x1 x2 x3)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap4 f x1 x2 x3 x4 =\n    try return (f x1 x2 x3 x4)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap5 f x1 x2 x3 x4 x5 =\n    try return (f x1 x2 x3 x4 x5)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap6 f x1 x2 x3 x4 x5 x6 =\n    try return (f x1 x2 x3 x4 x5 x6)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap7 f x1 x2 x3 x4 x5 x6 x7 =\n    try return (f x1 x2 x3 x4 x5 x6 x7)\n    with exn when Exception_filter.run exn -> fail exn\n\n\n\n  let pause_hook = ref ignore\n\n  let paused = Lwt_sequence.create ()\n  let paused_count = ref 0\n\n  let pause () =\n    let p = add_task_r paused in\n    incr paused_count;\n    !pause_hook !paused_count;\n    p\n\n  let wakeup_paused () =\n    if Lwt_sequence.is_empty paused then\n      paused_count := 0\n    else begin\n      let tmp = Lwt_sequence.create () in\n      Lwt_sequence.transfer_r paused tmp;\n      paused_count := 0;\n      Lwt_sequence.iter_l (fun r -> wakeup r ()) tmp\n    end\n\n  let register_pause_notifier f = pause_hook := f\n\n  let abandon_paused () =\n    Lwt_sequence.clear paused;\n    paused_count := 0\n\n  let paused_count () = !paused_count\nend\ninclude Miscellaneous\n\nmodule Let_syntax =\nstruct\n  module Let_syntax =\n  struct\n    let return = return\n    let map t ~f = map f t\n    let bind t ~f = bind t f\n    let both = both\n\n    module Open_on_rhs =\n    struct\n    end\n  end\nend\n\nmodule Infix =\nstruct\n  let (>>=) = bind\n  let (=<<) f p = bind p f\n  let (>|=) p f = map f p\n  let (=|<) = map\n  let (<&>) p p' = join [p; p']\n  let (<?>) p p' = choose [p; p']\n\n  include Let_syntax\nend\ninclude ( Infix : module type of Infix with module Let_syntax := Let_syntax.Let_syntax )\n\nmodule Syntax =\nstruct\n  let (let*) = bind\n  let (and*) = both\n\n  let (let+) x f = map f x\n  let (and+) = both\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Exceptions *)\n\nexternal register_named_value : string -> 'a -> unit\n                              = \"caml_register_named_value\"\n\nlet () =\n  (* for runtime/fail_nat.c *)\n  register_named_value \"Pervasives.array_bound_error\"\n    (Invalid_argument \"index out of bounds\")\n\nexternal raise : exn -> 'a = \"%raise\"\nexternal raise_notrace : exn -> 'a = \"%raise_notrace\"\n\nlet failwith s = raise(Failure s)\nlet invalid_arg s = raise(Invalid_argument s)\n\nexception Exit\nexception Match_failure = Match_failure\nexception Assert_failure = Assert_failure\nexception Invalid_argument = Invalid_argument\nexception Failure = Failure\nexception Not_found = Not_found\nexception Out_of_memory = Out_of_memory\nexception Stack_overflow = Stack_overflow\nexception Sys_error = Sys_error\nexception End_of_file = End_of_file\nexception Division_by_zero = Division_by_zero\nexception Sys_blocked_io = Sys_blocked_io\nexception Undefined_recursive_module = Undefined_recursive_module\n\n(* Composition operators *)\n\nexternal ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\nexternal ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n\n(* Debugging *)\n\nexternal __LOC__ : string = \"%loc_LOC\"\nexternal __FILE__ : string = \"%loc_FILE\"\nexternal __LINE__ : int = \"%loc_LINE\"\nexternal __MODULE__ : string = \"%loc_MODULE\"\nexternal __POS__ : string * int * int * int = \"%loc_POS\"\nexternal __FUNCTION__ : string = \"%loc_FUNCTION\"\n\nexternal __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\nexternal __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\nexternal __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n\n(* Comparisons *)\n\nexternal ( = ) : 'a -> 'a -> bool = \"%equal\"\nexternal ( <> ) : 'a -> 'a -> bool = \"%notequal\"\nexternal ( < ) : 'a -> 'a -> bool = \"%lessthan\"\nexternal ( > ) : 'a -> 'a -> bool = \"%greaterthan\"\nexternal ( <= ) : 'a -> 'a -> bool = \"%lessequal\"\nexternal ( >= ) : 'a -> 'a -> bool = \"%greaterequal\"\nexternal compare : 'a -> 'a -> int = \"%compare\"\n\nlet min x y = if x <= y then x else y\nlet max x y = if x >= y then x else y\n\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( != ) : 'a -> 'a -> bool = \"%noteq\"\n\n(* Boolean operations *)\n\nexternal not : bool -> bool = \"%boolnot\"\nexternal ( & ) : bool -> bool -> bool = \"%sequand\"\nexternal ( && ) : bool -> bool -> bool = \"%sequand\"\nexternal ( or ) : bool -> bool -> bool = \"%sequor\"\nexternal ( || ) : bool -> bool -> bool = \"%sequor\"\n\n(* Integer operations *)\n\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n\nlet abs x = if x >= 0 then x else -x\n\nexternal ( land ) : int -> int -> int = \"%andint\"\nexternal ( lor ) : int -> int -> int = \"%orint\"\nexternal ( lxor ) : int -> int -> int = \"%xorint\"\n\nlet lnot x = x lxor (-1)\n\nexternal ( lsl ) : int -> int -> int = \"%lslint\"\nexternal ( lsr ) : int -> int -> int = \"%lsrint\"\nexternal ( asr ) : int -> int -> int = \"%asrint\"\n\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\n\n(* Floating-point operations *)\n\nexternal ( ~-. ) : float -> float = \"%negfloat\"\nexternal ( ~+. ) : float -> float = \"%identity\"\nexternal ( +. ) : float -> float -> float = \"%addfloat\"\nexternal ( -. ) : float -> float -> float = \"%subfloat\"\nexternal ( *. ) : float -> float -> float = \"%mulfloat\"\nexternal ( /. ) : float -> float -> float = \"%divfloat\"\nexternal ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\"\n  [@@unboxed] [@@noalloc]\nexternal exp : float -> float = \"caml_exp_float\" \"exp\" [@@unboxed] [@@noalloc]\nexternal expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\"\n  [@@unboxed] [@@noalloc]\nexternal acos : float -> float = \"caml_acos_float\" \"acos\"\n  [@@unboxed] [@@noalloc]\nexternal asin : float -> float = \"caml_asin_float\" \"asin\"\n  [@@unboxed] [@@noalloc]\nexternal atan : float -> float = \"caml_atan_float\" \"atan\"\n  [@@unboxed] [@@noalloc]\nexternal atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\"\n  [@@unboxed] [@@noalloc]\nexternal hypot : float -> float -> float\n               = \"caml_hypot_float\" \"caml_hypot\" [@@unboxed] [@@noalloc]\nexternal cos : float -> float = \"caml_cos_float\" \"cos\" [@@unboxed] [@@noalloc]\nexternal cosh : float -> float = \"caml_cosh_float\" \"cosh\"\n  [@@unboxed] [@@noalloc]\nexternal acosh : float -> float = \"caml_acosh_float\" \"caml_acosh\"\n  [@@unboxed] [@@noalloc]\nexternal log : float -> float = \"caml_log_float\" \"log\" [@@unboxed] [@@noalloc]\nexternal log10 : float -> float = \"caml_log10_float\" \"log10\"\n  [@@unboxed] [@@noalloc]\nexternal log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\"\n  [@@unboxed] [@@noalloc]\nexternal sin : float -> float = \"caml_sin_float\" \"sin\" [@@unboxed] [@@noalloc]\nexternal sinh : float -> float = \"caml_sinh_float\" \"sinh\"\n  [@@unboxed] [@@noalloc]\nexternal asinh : float -> float = \"caml_asinh_float\" \"caml_asinh\"\n  [@@unboxed] [@@noalloc]\nexternal sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\"\n  [@@unboxed] [@@noalloc]\nexternal tan : float -> float = \"caml_tan_float\" \"tan\" [@@unboxed] [@@noalloc]\nexternal tanh : float -> float = \"caml_tanh_float\" \"tanh\"\n  [@@unboxed] [@@noalloc]\nexternal atanh : float -> float = \"caml_atanh_float\" \"caml_atanh\"\n  [@@unboxed] [@@noalloc]\nexternal ceil : float -> float = \"caml_ceil_float\" \"ceil\"\n  [@@unboxed] [@@noalloc]\nexternal floor : float -> float = \"caml_floor_float\" \"floor\"\n  [@@unboxed] [@@noalloc]\nexternal abs_float : float -> float = \"%absfloat\"\nexternal copysign : float -> float -> float\n                  = \"caml_copysign_float\" \"caml_copysign\"\n                  [@@unboxed] [@@noalloc]\nexternal mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\"\n  [@@unboxed] [@@noalloc]\nexternal frexp : float -> float * int = \"caml_frexp_float\"\nexternal ldexp : (float [@unboxed]) -> (int [@untagged]) -> (float [@unboxed]) =\n  \"caml_ldexp_float\" \"caml_ldexp_float_unboxed\" [@@noalloc]\nexternal modf : float -> float * float = \"caml_modf_float\"\nexternal float : int -> float = \"%floatofint\"\nexternal float_of_int : int -> float = \"%floatofint\"\nexternal truncate : float -> int = \"%intoffloat\"\nexternal int_of_float : float -> int = \"%intoffloat\"\nexternal float_of_bits : int64 -> float\n  = \"caml_int64_float_of_bits\" \"caml_int64_float_of_bits_unboxed\"\n  [@@unboxed] [@@noalloc]\nlet infinity =\n  float_of_bits 0x7F_F0_00_00_00_00_00_00L\nlet neg_infinity =\n  float_of_bits 0xFF_F0_00_00_00_00_00_00L\nlet nan =\n  float_of_bits 0x7F_F0_00_00_00_00_00_01L\nlet max_float =\n  float_of_bits 0x7F_EF_FF_FF_FF_FF_FF_FFL\nlet min_float =\n  float_of_bits 0x00_10_00_00_00_00_00_00L\nlet epsilon_float =\n  float_of_bits 0x3C_B0_00_00_00_00_00_00L\n\ntype fpclass =\n    FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\nexternal classify_float : (float [@unboxed]) -> fpclass =\n  \"caml_classify_float\" \"caml_classify_float_unboxed\" [@@noalloc]\n\n(* String and byte sequence operations -- more in modules String and Bytes *)\n\nexternal string_length : string -> int = \"%string_length\"\nexternal bytes_length : bytes -> int = \"%bytes_length\"\nexternal bytes_create : int -> bytes = \"caml_create_bytes\"\nexternal string_blit : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal bytes_blit : bytes -> int -> bytes -> int -> int -> unit\n                        = \"caml_blit_bytes\" [@@noalloc]\nexternal bytes_unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet ( ^ ) s1 s2 =\n  let l1 = string_length s1 and l2 = string_length s2 in\n  let s = bytes_create (l1 + l2) in\n  string_blit s1 0 s 0 l1;\n  string_blit s2 0 s l1 l2;\n  bytes_unsafe_to_string s\n\n(* Character operations -- more in module Char *)\n\nexternal int_of_char : char -> int = \"%identity\"\nexternal unsafe_char_of_int : int -> char = \"%identity\"\nlet char_of_int n =\n  if n < 0 || n > 255 then invalid_arg \"char_of_int\" else unsafe_char_of_int n\n\n(* Unit operations *)\n\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* Pair operations *)\n\nexternal fst : 'a * 'b -> 'a = \"%field0\"\nexternal snd : 'a * 'b -> 'b = \"%field1\"\n\n(* References *)\n\ntype 'a ref = { mutable contents : 'a }\nexternal ref : 'a -> 'a ref = \"%makemutable\"\nexternal ( ! ) : 'a ref -> 'a = \"%field0\"\nexternal ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\nexternal incr : int ref -> unit = \"%incr\"\nexternal decr : int ref -> unit = \"%decr\"\n\n(* Result type *)\n\ntype ('a,'b) result = Ok of 'a | Error of 'b\n\n(* String conversion functions *)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nexternal format_float : string -> float -> string = \"caml_format_float\"\n\nlet string_of_bool b =\n  if b then \"true\" else \"false\"\nlet bool_of_string = function\n  | \"true\" -> true\n  | \"false\" -> false\n  | _ -> invalid_arg \"bool_of_string\"\n\nlet bool_of_string_opt = function\n  | \"true\" -> Some true\n  | \"false\" -> Some false\n  | _ -> None\n\nlet string_of_int n =\n  format_int \"%d\" n\n\nexternal int_of_string : string -> int = \"caml_int_of_string\"\n\nlet int_of_string_opt s =\n  (* TODO: provide this directly as a non-raising primitive. *)\n  try Some (int_of_string s)\n  with Failure _ -> None\n\nexternal string_get : string -> int -> char = \"%string_safe_get\"\n\nlet valid_float_lexem s =\n  let l = string_length s in\n  let rec loop i =\n    if i >= l then s ^ \".\" else\n    match string_get s i with\n    | '0' .. '9' | '-' -> loop (i + 1)\n    | _ -> s\n  in\n  loop 0\n\nlet string_of_float f = valid_float_lexem (format_float \"%.12g\" f)\n\nexternal float_of_string : string -> float = \"caml_float_of_string\"\n\nlet float_of_string_opt s =\n  (* TODO: provide this directly as a non-raising primitive. *)\n  try Some (float_of_string s)\n  with Failure _ -> None\n\n(* List operations -- more in module List *)\n\nlet rec ( @ ) l1 l2 =\n  match l1 with\n    [] -> l2\n  | hd :: tl -> hd :: (tl @ l2)\n\n(* I/O operations *)\n\ntype in_channel\ntype out_channel\n\nexternal open_descriptor_out : int -> out_channel\n                             = \"caml_ml_open_descriptor_out\"\nexternal open_descriptor_in : int -> in_channel = \"caml_ml_open_descriptor_in\"\n\nlet stdin = open_descriptor_in 0\nlet stdout = open_descriptor_out 1\nlet stderr = open_descriptor_out 2\n\n(* General output functions *)\n\ntype open_flag =\n    Open_rdonly | Open_wronly | Open_append\n  | Open_creat | Open_trunc | Open_excl\n  | Open_binary | Open_text | Open_nonblock\n\nexternal open_desc : string -> open_flag list -> int -> int = \"caml_sys_open\"\n\nexternal set_out_channel_name: out_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_out_gen mode perm name =\n  let c = open_descriptor_out(open_desc name mode perm) in\n  set_out_channel_name c name;\n  c\n\nlet open_out name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name\n\nlet open_out_bin name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name\n\nexternal flush : out_channel -> unit = \"caml_ml_flush\"\n\nexternal out_channels_list : unit -> out_channel list\n                           = \"caml_ml_out_channels_list\"\n\nlet flush_all () =\n  let rec iter = function\n      [] -> ()\n    | a::l ->\n        begin try\n            flush a\n        with Sys_error _ ->\n          () (* ignore channels closed during a preceding flush. *)\n        end;\n        iter l\n  in iter (out_channels_list ())\n\nexternal unsafe_output : out_channel -> bytes -> int -> int -> unit\n                       = \"caml_ml_output_bytes\"\nexternal unsafe_output_string : out_channel -> string -> int -> int -> unit\n                              = \"caml_ml_output\"\n\nexternal output_char : out_channel -> char -> unit = \"caml_ml_output_char\"\n\nlet output_bytes oc s =\n  unsafe_output oc s 0 (bytes_length s)\n\nlet output_string oc s =\n  unsafe_output_string oc s 0 (string_length s)\n\nlet output oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"output\"\n  else unsafe_output oc s ofs len\n\nlet output_substring oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > string_length s - len\n  then invalid_arg \"output_substring\"\n  else unsafe_output_string oc s ofs len\n\nexternal output_byte : out_channel -> int -> unit = \"caml_ml_output_char\"\nexternal output_binary_int : out_channel -> int -> unit = \"caml_ml_output_int\"\n\nexternal marshal_to_channel : out_channel -> 'a -> unit list -> unit\n     = \"caml_output_value\"\nlet output_value chan v = marshal_to_channel chan v []\n\nexternal seek_out : out_channel -> int -> unit = \"caml_ml_seek_out\"\nexternal pos_out : out_channel -> int = \"caml_ml_pos_out\"\nexternal out_channel_length : out_channel -> int = \"caml_ml_channel_size\"\nexternal close_out_channel : out_channel -> unit = \"caml_ml_close_channel\"\nlet close_out oc = flush oc; close_out_channel oc\nlet close_out_noerr oc =\n  (try flush oc with _ -> ());\n  (try close_out_channel oc with _ -> ())\nexternal set_binary_mode_out : out_channel -> bool -> unit\n                             = \"caml_ml_set_binary_mode\"\n\n(* General input functions *)\n\nexternal set_in_channel_name: in_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_in_gen mode perm name =\n  let c = open_descriptor_in(open_desc name mode perm) in\n  set_in_channel_name c name;\n  c\n\nlet open_in name =\n  open_in_gen [Open_rdonly; Open_text] 0 name\n\nlet open_in_bin name =\n  open_in_gen [Open_rdonly; Open_binary] 0 name\n\nexternal input_char : in_channel -> char = \"caml_ml_input_char\"\n\nexternal unsafe_input : in_channel -> bytes -> int -> int -> int\n                      = \"caml_ml_input\"\n\nlet input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"input\"\n  else unsafe_input ic s ofs len\n\nlet rec unsafe_really_input ic s ofs len =\n  if len <= 0 then () else begin\n    let r = unsafe_input ic s ofs len in\n    if r = 0\n    then raise End_of_file\n    else unsafe_really_input ic s (ofs + r) (len - r)\n  end\n\nlet really_input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"really_input\"\n  else unsafe_really_input ic s ofs len\n\nlet really_input_string ic len =\n  let s = bytes_create len in\n  really_input ic s 0 len;\n  bytes_unsafe_to_string s\n\nexternal input_scan_line : in_channel -> int = \"caml_ml_input_scan_line\"\n\nlet input_line chan =\n  let rec build_result buf pos = function\n    [] -> buf\n  | hd :: tl ->\n      let len = bytes_length hd in\n      bytes_blit hd 0 buf (pos - len) len;\n      build_result buf (pos - len) tl in\n  let rec scan accu len =\n    let n = input_scan_line chan in\n    if n = 0 then begin                   (* n = 0: we are at EOF *)\n      match accu with\n        [] -> raise End_of_file\n      | _  -> build_result (bytes_create len) len accu\n    end else if n > 0 then begin          (* n > 0: newline found in buffer *)\n      let res = bytes_create (n - 1) in\n      ignore (unsafe_input chan res 0 (n - 1));\n      ignore (input_char chan);           (* skip the newline *)\n      match accu with\n        [] -> res\n      |  _ -> let len = len + n - 1 in\n              build_result (bytes_create len) len (res :: accu)\n    end else begin                        (* n < 0: newline not found *)\n      let beg = bytes_create (-n) in\n      ignore(unsafe_input chan beg 0 (-n));\n      scan (beg :: accu) (len - n)\n    end\n  in bytes_unsafe_to_string (scan [] 0)\n\nexternal input_byte : in_channel -> int = \"caml_ml_input_char\"\nexternal input_binary_int : in_channel -> int = \"caml_ml_input_int\"\nexternal input_value : in_channel -> 'a = \"caml_input_value\"\nexternal seek_in : in_channel -> int -> unit = \"caml_ml_seek_in\"\nexternal pos_in : in_channel -> int = \"caml_ml_pos_in\"\nexternal in_channel_length : in_channel -> int = \"caml_ml_channel_size\"\nexternal close_in : in_channel -> unit = \"caml_ml_close_channel\"\nlet close_in_noerr ic = (try close_in ic with _ -> ())\nexternal set_binary_mode_in : in_channel -> bool -> unit\n                            = \"caml_ml_set_binary_mode\"\n\n(* Output functions on standard output *)\n\nlet print_char c = output_char stdout c\nlet print_string s = output_string stdout s\nlet print_bytes s = output_bytes stdout s\nlet print_int i = output_string stdout (string_of_int i)\nlet print_float f = output_string stdout (string_of_float f)\nlet print_endline s =\n  output_string stdout s; output_char stdout '\\n'; flush stdout\nlet print_newline () = output_char stdout '\\n'; flush stdout\n\n(* Output functions on standard error *)\n\nlet prerr_char c = output_char stderr c\nlet prerr_string s = output_string stderr s\nlet prerr_bytes s = output_bytes stderr s\nlet prerr_int i = output_string stderr (string_of_int i)\nlet prerr_float f = output_string stderr (string_of_float f)\nlet prerr_endline s =\n  output_string stderr s; output_char stderr '\\n'; flush stderr\nlet prerr_newline () = output_char stderr '\\n'; flush stderr\n\n(* Input functions on standard input *)\n\nlet read_line () = flush stdout; input_line stdin\nlet read_int () = int_of_string(read_line())\nlet read_int_opt () = int_of_string_opt(read_line())\nlet read_float () = float_of_string(read_line())\nlet read_float_opt () = float_of_string_opt(read_line())\n\n(* Operations on large files *)\n\nmodule LargeFile =\n  struct\n    external seek_out : out_channel -> int64 -> unit = \"caml_ml_seek_out_64\"\n    external pos_out : out_channel -> int64 = \"caml_ml_pos_out_64\"\n    external out_channel_length : out_channel -> int64\n                                = \"caml_ml_channel_size_64\"\n    external seek_in : in_channel -> int64 -> unit = \"caml_ml_seek_in_64\"\n    external pos_in : in_channel -> int64 = \"caml_ml_pos_in_64\"\n    external in_channel_length : in_channel -> int64 = \"caml_ml_channel_size_64\"\n  end\n\n(* Formats *)\n\ntype ('a, 'b, 'c, 'd, 'e, 'f) format6\n   = ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n   = Format of ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.fmt\n               * string\n\ntype ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n\ntype ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n\nlet string_of_format (Format (_fmt, str)) = str\n\nexternal format_of_string :\n ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n ('a, 'b, 'c, 'd, 'e, 'f) format6 = \"%identity\"\n\nlet ( ^^ ) (Format (fmt1, str1)) (Format (fmt2, str2)) =\n  Format (CamlinternalFormatBasics.concat_fmt fmt1 fmt2,\n          str1 ^ \"%,\" ^ str2)\n\n(* Miscellaneous *)\n\nexternal sys_exit : int -> 'a = \"caml_sys_exit\"\n\nlet exit_function = CamlinternalAtomic.make flush_all\n\nlet rec at_exit f =\n  let module Atomic = CamlinternalAtomic in\n  (* MPR#7253, MPR#7796: make sure \"f\" is executed only once *)\n  let f_yet_to_run = Atomic.make true in\n  let old_exit = Atomic.get exit_function in\n  let new_exit () =\n    if Atomic.compare_and_set f_yet_to_run true false then f () ;\n    old_exit ()\n  in\n  let success = Atomic.compare_and_set exit_function old_exit new_exit in\n  if not success then at_exit f\n\nlet do_at_exit () = (CamlinternalAtomic.get exit_function) ()\n\nlet exit retcode =\n  do_at_exit ();\n  sys_exit retcode\n\nlet _ = register_named_value \"Pervasives.do_at_exit\" do_at_exit\n\nexternal major : unit -> unit = \"caml_gc_major\"\nexternal naked_pointers_checked : unit -> bool\n  = \"caml_sys_const_naked_pointers_checked\"\nlet () = if naked_pointers_checked () then at_exit major\n\n(*MODULE_ALIASES*)\nmodule Arg          = Arg\nmodule Array        = Array\nmodule ArrayLabels  = ArrayLabels\nmodule Atomic       = Atomic\nmodule Bigarray     = Bigarray\nmodule Bool         = Bool\nmodule Buffer       = Buffer\nmodule Bytes        = Bytes\nmodule BytesLabels  = BytesLabels\nmodule Callback     = Callback\nmodule Char         = Char\nmodule Complex      = Complex\nmodule Digest       = Digest\nmodule Either       = Either\nmodule Ephemeron    = Ephemeron\nmodule Filename     = Filename\nmodule Float        = Float\nmodule Format       = Format\nmodule Fun          = Fun\nmodule Gc           = Gc\nmodule Genlex       = Genlex\nmodule Hashtbl      = Hashtbl\nmodule In_channel   = In_channel\nmodule Int          = Int\nmodule Int32        = Int32\nmodule Int64        = Int64\nmodule Lazy         = Lazy\nmodule Lexing       = Lexing\nmodule List         = List\nmodule ListLabels   = ListLabels\nmodule Map          = Map\nmodule Marshal      = Marshal\nmodule MoreLabels   = MoreLabels\nmodule Nativeint    = Nativeint\nmodule Obj          = Obj\nmodule Oo           = Oo\nmodule Option       = Option\nmodule Out_channel  = Out_channel\nmodule Parsing      = Parsing\nmodule Pervasives   = Pervasives\nmodule Printexc     = Printexc\nmodule Printf       = Printf\nmodule Queue        = Queue\nmodule Random       = Random\nmodule Result       = Result\nmodule Scanf        = Scanf\nmodule Seq          = Seq\nmodule Set          = Set\nmodule Stack        = Stack\nmodule StdLabels    = StdLabels\nmodule Stream       = Stream\nmodule String       = String\nmodule StringLabels = StringLabels\nmodule Sys          = Sys\nmodule Uchar        = Uchar\nmodule Unit         = Unit\nmodule Weak         = Weak\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\n\n(******************************************************************************)\n           (* Tools to manipulate scanning set of chars (see %[...]) *)\n\ntype mutable_char_set = bytes\n\n(* Create a fresh, empty, mutable char set. *)\nlet create_char_set () = Bytes.make 32 '\\000'\n\n(* Add a char in a mutable char set. *)\nlet add_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  Bytes.set char_set str_ind\n    (char_of_int (int_of_char (Bytes.get char_set str_ind) lor mask))\n\nlet freeze_char_set char_set =\n  Bytes.to_string char_set\n\n(* Compute the complement of a char set. *)\nlet rev_char_set char_set =\n  let char_set' = create_char_set () in\n  for i = 0 to 31 do\n    Bytes.set char_set' i\n      (char_of_int (int_of_char (String.get char_set i) lxor 0xFF));\n  done;\n  Bytes.unsafe_to_string char_set'\n\n(* Return true if a `c' is in `char_set'. *)\nlet is_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  (int_of_char (String.get char_set str_ind) land mask) <> 0\n\n\n(******************************************************************************)\n                         (* Ignored param conversion *)\n\n(* GADT used to abstract an existential type parameter. *)\n(* See param_format_of_ignored_format. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb = Param_format_EBB :\n    ('x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb\n\n(* Compute a padding associated to a pad_option (see \"%_42d\"). *)\nlet pad_of_pad_opt pad_opt = match pad_opt with\n  | None -> No_padding\n  | Some width -> Lit_padding (Right, width)\n\n(* Compute a precision associated to a prec_option (see \"%_.42f\"). *)\nlet prec_of_prec_opt prec_opt = match prec_opt with\n  | None -> No_precision\n  | Some ndec -> Lit_precision ndec\n\n(* Turn an ignored param into its equivalent not-ignored format node. *)\n(* Used for format pretty-printing and Scanf. *)\nlet param_format_of_ignored_format : type a b c d e f x y .\n    (a, b, c, d, y, x) ignored -> (x, b, c, y, e, f) fmt ->\n      (a, b, c, d, e, f) param_format_ebb =\nfun ign fmt -> match ign with\n  | Ignored_char ->\n    Param_format_EBB (Char fmt)\n  | Ignored_caml_char ->\n    Param_format_EBB (Caml_char fmt)\n  | Ignored_string pad_opt ->\n    Param_format_EBB (String (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_caml_string pad_opt ->\n    Param_format_EBB (Caml_string (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_int (iconv, pad_opt) ->\n    Param_format_EBB (Int (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int32 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int32 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_nativeint (iconv, pad_opt) ->\n    Param_format_EBB\n      (Nativeint (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int64 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int64 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_float (pad_opt, prec_opt) ->\n    Param_format_EBB\n      (Float ((Float_flag_, Float_f),\n              pad_of_pad_opt pad_opt, prec_of_prec_opt prec_opt, fmt))\n  | Ignored_bool pad_opt ->\n    Param_format_EBB (Bool (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_format_arg (pad_opt, fmtty) ->\n    Param_format_EBB (Format_arg (pad_opt, fmtty, fmt))\n  | Ignored_format_subst (pad_opt, fmtty) ->\n    Param_format_EBB\n      (Format_subst (pad_opt, fmtty, fmt))\n  | Ignored_reader ->\n    Param_format_EBB (Reader fmt)\n  | Ignored_scan_char_set (width_opt, char_set) ->\n    Param_format_EBB (Scan_char_set (width_opt, char_set, fmt))\n  | Ignored_scan_get_counter counter ->\n    Param_format_EBB (Scan_get_counter (counter, fmt))\n  | Ignored_scan_next_char ->\n    Param_format_EBB (Scan_next_char fmt)\n\n\n(******************************************************************************)\n                                 (* Types *)\n\ntype ('b, 'c) acc_formatting_gen =\n  | Acc_open_tag of ('b, 'c) acc\n  | Acc_open_box of ('b, 'c) acc\n\n(* Reversed list of printing atoms. *)\n(* Used to accumulate printf arguments. *)\nand ('b, 'c) acc =\n  | Acc_formatting_lit of ('b, 'c) acc * formatting_lit\n      (* Special fmtting (box) *)\n  | Acc_formatting_gen of ('b, 'c) acc * ('b, 'c) acc_formatting_gen\n      (* Special fmtting (box) *)\n  | Acc_string_literal of ('b, 'c) acc * string     (* Literal string *)\n  | Acc_char_literal   of ('b, 'c) acc * char       (* Literal char *)\n  | Acc_data_string    of ('b, 'c) acc * string     (* Generated string *)\n  | Acc_data_char      of ('b, 'c) acc * char       (* Generated char *)\n  | Acc_delay          of ('b, 'c) acc * ('b -> 'c)\n                                                (* Delayed printing (%a, %t) *)\n  | Acc_flush          of ('b, 'c) acc              (* Flush *)\n  | Acc_invalid_arg    of ('b, 'c) acc * string\n      (* Raise Invalid_argument msg *)\n  | End_of_acc\n\n(* List of heterogeneous values. *)\n(* Used to accumulate scanf callback arguments. *)\ntype ('a, 'b) heter_list =\n  | Cons : 'c * ('a, 'b) heter_list -> ('c -> 'a, 'b) heter_list\n  | Nil : ('b, 'b) heter_list\n\n(* Existential Black Boxes. *)\n(* Used to abstract some existential type parameters. *)\n\n(* GADT type associating a padding and an fmtty. *)\n(* See the type_padding function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb = Padding_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb\n\n(* GADT type associating a padding, a precision and an fmtty. *)\n(* See the type_padprec function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb = Padprec_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'z) precision * ('z, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb\n\n(* GADT type associating a padding and an fmt. *)\n(* See make_padding_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) padding_fmt_ebb = Padding_fmt_EBB :\n     (_, 'x -> 'a) padding *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) padding_fmt_ebb\n\n(* GADT type associating a precision and an fmt. *)\n(* See make_precision_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) precision_fmt_ebb = Precision_fmt_EBB :\n     (_, 'x -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) precision_fmt_ebb\n\n(* GADT type associating a padding, a precision and an fmt. *)\n(* See make_padprec_fmt_ebb and parse_format functions. *)\ntype ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb = Padprec_fmt_EBB :\n     ('x, 'y) padding * ('y, 'p -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb\n\n(* Abstract the 'a and 'd parameters of an fmt. *)\n(* Output type of the format parsing function. *)\ntype ('b, 'c, 'e, 'f) fmt_ebb = Fmt_EBB :\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('b, 'c, 'e, 'f) fmt_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_format_gen function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb = Fmt_fmtty_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmt *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmtty ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_ignored_format_substitution function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb = Fmtty_fmt_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmtty *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmt_fmtty_ebb ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb\n\n(* Abstract all fmtty type parameters. *)\n(* Used to compare format types. *)\ntype fmtty_ebb = Fmtty_EBB : ('a, 'b, 'c, 'd, 'e, 'f) fmtty -> fmtty_ebb\n\n(* Abstract all padding type parameters. *)\n(* Used to compare paddings. *)\ntype padding_ebb = Padding_EBB : ('a, 'b) padding -> padding_ebb\n\n(* Abstract all precision type parameters. *)\n(* Used to compare precisions. *)\ntype precision_ebb = Precision_EBB : ('a, 'b) precision -> precision_ebb\n\n(******************************************************************************)\n                               (* Constants *)\n\n(* Default precision for float printing. *)\nlet default_float_precision fconv =\n  match snd fconv with\n  | Float_f | Float_e | Float_E | Float_g | Float_G | Float_h | Float_H\n  | Float_CF -> -6\n  (* For %h %H and %#F formats, a negative precision means \"as many digits as\n     necessary\".  For the other FP formats, we take the absolute value\n     of the precision, hence 6 digits by default. *)\n  | Float_F -> 12\n  (* Default precision for OCaml float printing (%F). *)\n\n(******************************************************************************)\n                               (* Externals *)\n\nexternal format_float: string -> float -> string\n  = \"caml_format_float\"\nexternal format_int: string -> int -> string\n  = \"caml_format_int\"\nexternal format_int32: string -> int32 -> string\n  = \"caml_int32_format\"\nexternal format_nativeint: string -> nativeint -> string\n  = \"caml_nativeint_format\"\nexternal format_int64: string -> int64 -> string\n  = \"caml_int64_format\"\nexternal hexstring_of_float: float -> int -> char -> string\n  = \"caml_hexstring_of_float\"\n\n(******************************************************************************)\n                     (* Tools to pretty-print formats *)\n\n(* Type of extensible character buffers. *)\ntype buffer = {\n  mutable ind : int;\n  mutable bytes : bytes;\n}\n\n(* Create a fresh buffer. *)\nlet buffer_create init_size = { ind = 0; bytes = Bytes.create init_size }\n\n(* Check size of the buffer and grow it if needed. *)\nlet buffer_check_size buf overhead =\n  let len = Bytes.length buf.bytes in\n  let min_len = buf.ind + overhead in\n  if min_len > len then (\n    let new_len = Int.max (len * 2) min_len in\n    let new_str = Bytes.create new_len in\n    Bytes.blit buf.bytes 0 new_str 0 len;\n    buf.bytes <- new_str;\n  )\n\n(* Add the character `c' to the buffer `buf'. *)\nlet buffer_add_char buf c =\n  buffer_check_size buf 1;\n  Bytes.set buf.bytes buf.ind c;\n  buf.ind <- buf.ind + 1\n\n(* Add the string `s' to the buffer `buf'. *)\nlet buffer_add_string buf s =\n  let str_len = String.length s in\n  buffer_check_size buf str_len;\n  String.blit s 0 buf.bytes buf.ind str_len;\n  buf.ind <- buf.ind + str_len\n\n(* Get the content of the buffer. *)\nlet buffer_contents buf =\n  Bytes.sub_string buf.bytes 0 buf.ind\n\n(***)\n\n(* Convert an integer conversion to char. *)\nlet char_of_iconv iconv = match iconv with\n  | Int_d | Int_pd | Int_sd | Int_Cd -> 'd' | Int_i | Int_pi | Int_si\n  | Int_Ci -> 'i' | Int_x | Int_Cx -> 'x' | Int_X | Int_CX -> 'X' | Int_o\n  | Int_Co -> 'o' | Int_u | Int_Cu -> 'u'\n\n(* Convert a float conversion to char. *)\n(* `cF' will be 'F' for displaying format and 'g' to call libc printf *)\nlet char_of_fconv ?(cF='F') fconv = match snd fconv with\n  | Float_f -> 'f' | Float_e -> 'e'\n  | Float_E -> 'E' | Float_g -> 'g'\n  | Float_G -> 'G' | Float_F -> cF\n  | Float_h -> 'h' | Float_H -> 'H'\n  | Float_CF -> 'F'\n\n\n(* Convert a scanning counter to char. *)\nlet char_of_counter counter = match counter with\n  | Line_counter  -> 'l'\n  | Char_counter  -> 'n'\n  | Token_counter -> 'N'\n\n(***)\n\n(* Print a char_set in a buffer with the OCaml format lexical convention. *)\nlet bprint_char_set buf char_set =\n  let rec print_start set =\n    let is_alone c =\n      let before, after = Char.(chr (code c - 1), chr (code c + 1)) in\n      is_in_char_set set c\n      && not (is_in_char_set set before && is_in_char_set set after) in\n    if is_alone ']' then buffer_add_char buf ']';\n    print_out set 1;\n    if is_alone '-' then buffer_add_char buf '-';\n  and print_out set i =\n    if i < 256 then\n      if is_in_char_set set (char_of_int i) then print_first set i\n      else print_out set (i + 1)\n  and print_first set i =\n    match char_of_int i with\n    | '\\255' -> print_char buf 255;\n    | ']' | '-' -> print_out set (i + 1);\n    | _ -> print_second set (i + 1);\n  and print_second set i =\n    if is_in_char_set set (char_of_int i) then\n      match char_of_int i with\n      | '\\255' ->\n        print_char buf 254;\n        print_char buf 255;\n      | ']' | '-' when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_out set (i + 1);\n      | _ when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_char buf i;\n        print_out set (i + 2);\n      | _ ->\n        print_in set (i - 1) (i + 2);\n    else (\n      print_char buf (i - 1);\n      print_out set (i + 1);\n    )\n  and print_in set i j =\n    if j = 256 || not (is_in_char_set set (char_of_int j)) then (\n      print_char buf i;\n      print_char buf (int_of_char '-');\n      print_char buf (j - 1);\n      if j < 256 then print_out set (j + 1);\n    ) else\n      print_in set i (j + 1);\n  and print_char buf i = match char_of_int i with\n    | '%' -> buffer_add_char buf '%'; buffer_add_char buf '%';\n    | '@' -> buffer_add_char buf '%'; buffer_add_char buf '@';\n    | c   -> buffer_add_char buf c;\n  in\n  buffer_add_char buf '[';\n  print_start (\n    if is_in_char_set char_set '\\000'\n    then ( buffer_add_char buf '^'; rev_char_set char_set )\n    else char_set\n  );\n  buffer_add_char buf ']'\n\n(***)\n\n(* Print a padty in a buffer with the format-like syntax. *)\nlet bprint_padty buf padty = match padty with\n  | Left  -> buffer_add_char buf '-'\n  | Right -> ()\n  | Zeros -> buffer_add_char buf '0'\n\n(* Print the '_' of an ignored flag if needed. *)\nlet bprint_ignored_flag buf ign_flag =\n  if ign_flag then buffer_add_char buf '_'\n\n(***)\n\nlet bprint_pad_opt buf pad_opt = match pad_opt with\n  | None -> ()\n  | Some width -> buffer_add_string buf (Int.to_string width)\n\n(***)\n\n(* Print padding in a buffer with the format-like syntax. *)\nlet bprint_padding : type a b . buffer -> (a, b) padding -> unit =\nfun buf pad -> match pad with\n  | No_padding -> ()\n  | Lit_padding (padty, n) ->\n    bprint_padty buf padty;\n    buffer_add_string buf (Int.to_string n);\n  | Arg_padding padty ->\n    bprint_padty buf padty;\n    buffer_add_char buf '*'\n\n(* Print precision in a buffer with the format-like syntax. *)\nlet bprint_precision : type a b . buffer -> (a, b) precision -> unit =\n  fun buf prec -> match prec with\n  | No_precision -> ()\n  | Lit_precision n ->\n    buffer_add_char buf '.';\n    buffer_add_string buf (Int.to_string n);\n  | Arg_precision ->\n    buffer_add_string buf \".*\"\n\n(***)\n\n(* Print the optional '+', ' ' or '#' associated to an int conversion. *)\nlet bprint_iconv_flag buf iconv = match iconv with\n  | Int_pd | Int_pi -> buffer_add_char buf '+'\n  | Int_sd | Int_si -> buffer_add_char buf ' '\n  | Int_Cx | Int_CX | Int_Co | Int_Cd | Int_Ci | Int_Cu ->\n      buffer_add_char buf '#'\n  | Int_d | Int_i | Int_x | Int_X | Int_o | Int_u -> ()\n\n(* Print an complete int format in a buffer (ex: \"%3.*d\"). *)\nlet bprint_int_fmt buf ign_flag iconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(* Print a complete int32, nativeint or int64 format in a buffer. *)\nlet bprint_altint_fmt buf ign_flag iconv pad prec c =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf c;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(***)\n\n(* Print the optional '+', ' ' and/or '#' associated to a float conversion. *)\nlet bprint_fconv_flag buf fconv =\n  begin match fst fconv with\n  | Float_flag_p -> buffer_add_char buf '+'\n  | Float_flag_s -> buffer_add_char buf ' '\n  | Float_flag_ -> () end;\n  match snd fconv with\n  | Float_CF -> buffer_add_char buf '#'\n  | Float_f | Float_e | Float_E | Float_g | Float_G\n  | Float_F | Float_h | Float_H -> ()\n\n(* Print a complete float format in a buffer (ex: \"%+*.3f\"). *)\nlet bprint_float_fmt buf ign_flag fconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_fconv_flag buf fconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_fconv fconv)\n\n(* Compute the literal string representation of a Formatting_lit. *)\n(* Used by Printf and Scanf where formatting is not interpreted. *)\nlet string_of_formatting_lit formatting_lit = match formatting_lit with\n  | Close_box            -> \"@]\"\n  | Close_tag            -> \"@}\"\n  | Break (str, _, _)    -> str\n  | FFlush               -> \"@?\"\n  | Force_newline        -> \"@\\n\"\n  | Flush_newline        -> \"@.\"\n  | Magic_size (str, _)  -> str\n  | Escaped_at           -> \"@@\"\n  | Escaped_percent      -> \"@%\"\n  | Scan_indic c -> \"@\" ^ (String.make 1 c)\n\n(***)\n\n(* Print a literal char in a buffer, escape '%' by \"%%\". *)\nlet bprint_char_literal buf chr = match chr with\n  | '%' -> buffer_add_string buf \"%%\"\n  | _ -> buffer_add_char buf chr\n\n(* Print a literal string in a buffer, escape all '%' by \"%%\". *)\nlet bprint_string_literal buf str =\n  for i = 0 to String.length str - 1 do\n    bprint_char_literal buf str.[i]\n  done\n\n(******************************************************************************)\n                          (* Format pretty-printing *)\n\n(* Print a complete format type (an fmtty) in a buffer. *)\nlet rec bprint_fmtty : type a b c d e f g h i j k l .\n    buffer -> (a, b, c, d, e, f, g, h, i, j, k, l) fmtty_rel -> unit =\nfun buf fmtty -> match fmtty with\n  | Char_ty rest      -> buffer_add_string buf \"%c\";  bprint_fmtty buf rest;\n  | String_ty rest    -> buffer_add_string buf \"%s\";  bprint_fmtty buf rest;\n  | Int_ty rest       -> buffer_add_string buf \"%i\";  bprint_fmtty buf rest;\n  | Int32_ty rest     -> buffer_add_string buf \"%li\"; bprint_fmtty buf rest;\n  | Nativeint_ty rest -> buffer_add_string buf \"%ni\"; bprint_fmtty buf rest;\n  | Int64_ty rest     -> buffer_add_string buf \"%Li\"; bprint_fmtty buf rest;\n  | Float_ty rest     -> buffer_add_string buf \"%f\";  bprint_fmtty buf rest;\n  | Bool_ty rest      -> buffer_add_string buf \"%B\";  bprint_fmtty buf rest;\n  | Alpha_ty rest     -> buffer_add_string buf \"%a\";  bprint_fmtty buf rest;\n  | Theta_ty rest     -> buffer_add_string buf \"%t\";  bprint_fmtty buf rest;\n  | Any_ty rest       -> buffer_add_string buf \"%?\";  bprint_fmtty buf rest;\n  | Reader_ty rest    -> buffer_add_string buf \"%r\";  bprint_fmtty buf rest;\n\n  | Ignored_reader_ty rest ->\n    buffer_add_string buf \"%_r\";\n    bprint_fmtty buf rest;\n\n  | Format_arg_ty (sub_fmtty, rest) ->\n    buffer_add_string buf \"%{\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%}\"; bprint_fmtty buf rest;\n  | Format_subst_ty (sub_fmtty, _, rest) ->\n    buffer_add_string buf \"%(\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%)\"; bprint_fmtty buf rest;\n\n  | End_of_fmtty -> ()\n\n(***)\n\nlet rec int_of_custom_arity : type a b c .\n  (a, b, c) custom_arity -> int =\n  function\n  | Custom_zero -> 0\n  | Custom_succ x -> 1 + int_of_custom_arity x\n\n(* Print a complete format in a buffer. *)\nlet bprint_fmt buf fmt =\n  let rec fmtiter : type a b c d e f .\n      (a, b, c, d, e, f) fmt -> bool -> unit =\n  fun fmt ign_flag -> match fmt with\n    | String (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 's';\n      fmtiter rest false;\n    | Caml_string (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 'S';\n      fmtiter rest false;\n\n    | Int (iconv, pad, prec, rest) ->\n      bprint_int_fmt buf ign_flag iconv pad prec;\n      fmtiter rest false;\n    | Int32 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'l';\n      fmtiter rest false;\n    | Nativeint (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'n';\n      fmtiter rest false;\n    | Int64 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'L';\n      fmtiter rest false;\n    | Float (fconv, pad, prec, rest) ->\n      bprint_float_fmt buf ign_flag fconv pad prec;\n      fmtiter rest false;\n\n    | Char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'c'; fmtiter rest false;\n    | Caml_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'C'; fmtiter rest false;\n    | Bool (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 'B';\n      fmtiter rest false;\n    | Alpha rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'a'; fmtiter rest false;\n    | Theta rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 't'; fmtiter rest false;\n    | Custom (arity, _, rest) ->\n      for _i = 1 to int_of_custom_arity arity do\n        buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n        buffer_add_char buf '?';\n      done;\n      fmtiter rest false;\n    | Reader rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'r'; fmtiter rest false;\n    | Flush rest ->\n      buffer_add_string buf \"%!\";\n      fmtiter rest ign_flag;\n\n    | String_literal (str, rest) ->\n      bprint_string_literal buf str;\n      fmtiter rest ign_flag;\n    | Char_literal (chr, rest) ->\n      bprint_char_literal buf chr;\n      fmtiter rest ign_flag;\n\n    | Format_arg (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '{';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf '}';\n      fmtiter rest false;\n    | Format_subst (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '(';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf ')';\n      fmtiter rest false;\n\n    | Scan_char_set (width_opt, char_set, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf width_opt; bprint_char_set buf char_set;\n      fmtiter rest false;\n    | Scan_get_counter (counter, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf (char_of_counter counter);\n      fmtiter rest false;\n    | Scan_next_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_string_literal buf \"0c\"; fmtiter rest false;\n\n    | Ignored_param (ign, rest) ->\n      let Param_format_EBB fmt' = param_format_of_ignored_format ign rest in\n      fmtiter fmt' true;\n\n    | Formatting_lit (fmting_lit, rest) ->\n      bprint_string_literal buf (string_of_formatting_lit fmting_lit);\n      fmtiter rest ign_flag;\n    | Formatting_gen (fmting_gen, rest) ->\n      begin match fmting_gen with\n      | Open_tag (Format (_, str)) ->\n        buffer_add_string buf \"@{\"; buffer_add_string buf str\n      | Open_box (Format (_, str)) ->\n        buffer_add_string buf \"@[\"; buffer_add_string buf str\n      end;\n      fmtiter rest ign_flag;\n\n    | End_of_format -> ()\n\n  in fmtiter fmt false\n\n(***)\n\n(* Convert a format to string. *)\nlet string_of_fmt fmt =\n  let buf = buffer_create 16 in\n  bprint_fmt buf fmt;\n  buffer_contents buf\n\n(******************************************************************************)\n                          (* Type extraction *)\n\ntype (_, _) eq = Refl : ('a, 'a) eq\n\n(* Invariant: this function is the identity on values.\n\n   In particular, if (ty1, ty2) have equal values, then\n   (trans (symm ty1) ty2) respects the 'trans' precondition. *)\nlet rec symm : type a1 b1 c1 d1 e1 f1 a2 b2 c2 d2 e2 f2 .\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a1, b1, c1, d1, e1, f1) fmtty_rel\n= function\n  | Char_ty rest -> Char_ty (symm rest)\n  | Int_ty rest -> Int_ty (symm rest)\n  | Int32_ty rest -> Int32_ty (symm rest)\n  | Int64_ty rest -> Int64_ty (symm rest)\n  | Nativeint_ty rest -> Nativeint_ty (symm rest)\n  | Float_ty rest -> Float_ty (symm rest)\n  | Bool_ty rest -> Bool_ty (symm rest)\n  | String_ty rest -> String_ty (symm rest)\n  | Theta_ty rest -> Theta_ty (symm rest)\n  | Alpha_ty rest -> Alpha_ty (symm rest)\n  | Any_ty rest -> Any_ty (symm rest)\n  | Reader_ty rest -> Reader_ty (symm rest)\n  | Ignored_reader_ty rest -> Ignored_reader_ty (symm rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, symm rest)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty2, ty1, symm rest)\n  | End_of_fmtty -> End_of_fmtty\n\nlet rec fmtty_rel_det : type a1 b c d1 e1 f1 a2 d2 e2 f2 .\n  (a1, b, c, d1, e1, f1,\n   a2, b, c, d2, e2, f2) fmtty_rel ->\n    ((f1, f2) eq -> (a1, a2) eq)\n  * ((a1, a2) eq -> (f1, f2) eq)\n  * ((e1, e2) eq -> (d1, d2) eq)\n  * ((d1, d2) eq -> (e1, e2) eq)\n= function\n  | End_of_fmtty ->\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl)\n  | Char_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | String_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int32_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int64_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Nativeint_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Float_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Bool_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n\n  | Theta_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Alpha_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Any_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Ignored_reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Format_arg_ty (_ty, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    let ty = trans (symm ty1) ty2 in\n    let ag, ga, dj, jd = fmtty_rel_det ty in\n    (fun Refl -> let Refl = fa Refl in let Refl = ag Refl in Refl),\n    (fun Refl -> let Refl = ga Refl in let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in let Refl = dj Refl in Refl),\n    (fun Refl -> let Refl = jd Refl in let Refl = de Refl in Refl)\n\n(* Precondition: we assume that the two fmtty_rel arguments have equal\n   values (at possibly distinct types); this invariant comes from the way\n   fmtty_rel witnesses are produced by the type-checker\n\n   The code below uses (assert false) when this assumption is broken. The\n   code pattern is the following:\n\n     | Foo x, Foo y ->\n       (* case where indeed both values\n          start with constructor Foo *)\n     | Foo _, _\n     | _, Foo _ ->\n       (* different head constructors: broken precondition *)\n       assert false\n*)\nand trans : type\n  a1 b1 c1 d1 e1 f1\n  a2 b2 c2 d2 e2 f2\n  a3 b3 c3 d3 e3 f3\n.\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n-> (a1, b1, c1, d1, e1, f1,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n= fun ty1 ty2 -> match ty1, ty2 with\n  | Char_ty rest1, Char_ty rest2 -> Char_ty (trans rest1 rest2)\n  | String_ty rest1, String_ty rest2 -> String_ty (trans rest1 rest2)\n  | Bool_ty rest1, Bool_ty rest2 -> Bool_ty (trans rest1 rest2)\n  | Int_ty rest1, Int_ty rest2 -> Int_ty (trans rest1 rest2)\n  | Int32_ty rest1, Int32_ty rest2 -> Int32_ty (trans rest1 rest2)\n  | Int64_ty rest1, Int64_ty rest2 -> Int64_ty (trans rest1 rest2)\n  | Nativeint_ty rest1, Nativeint_ty rest2 -> Nativeint_ty (trans rest1 rest2)\n  | Float_ty rest1, Float_ty rest2 -> Float_ty (trans rest1 rest2)\n\n  | Alpha_ty rest1, Alpha_ty rest2 -> Alpha_ty (trans rest1 rest2)\n  | Alpha_ty _, _ -> assert false\n  | _, Alpha_ty _ -> assert false\n\n  | Theta_ty rest1, Theta_ty rest2 -> Theta_ty (trans rest1 rest2)\n  | Theta_ty _, _ -> assert false\n  | _, Theta_ty _ -> assert false\n\n  | Any_ty rest1, Any_ty rest2 -> Any_ty (trans rest1 rest2)\n  | Any_ty _, _ -> assert false\n  | _, Any_ty _ -> assert false\n\n  | Reader_ty rest1, Reader_ty rest2 -> Reader_ty (trans rest1 rest2)\n  | Reader_ty _, _ -> assert false\n  | _, Reader_ty _ -> assert false\n\n  | Ignored_reader_ty rest1, Ignored_reader_ty rest2 ->\n    Ignored_reader_ty (trans rest1 rest2)\n  | Ignored_reader_ty _, _ -> assert false\n  | _, Ignored_reader_ty _ -> assert false\n\n  | Format_arg_ty (ty1, rest1), Format_arg_ty (ty2, rest2) ->\n    Format_arg_ty (trans ty1 ty2, trans rest1 rest2)\n  | Format_arg_ty _, _ -> assert false\n  | _, Format_arg_ty _ -> assert false\n\n  | Format_subst_ty (ty11, ty12, rest1),\n    Format_subst_ty (ty21, ty22, rest2) ->\n    let ty = trans (symm ty12) ty21 in\n    let _, f2, _, f4 = fmtty_rel_det ty in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    Format_subst_ty (ty11, ty22, trans rest1 rest2)\n  | Format_subst_ty _, _ -> assert false\n  | _, Format_subst_ty _ -> assert false\n\n  | End_of_fmtty, End_of_fmtty -> End_of_fmtty\n  | End_of_fmtty, _ -> assert false\n  | _, End_of_fmtty -> assert false\n\nlet rec fmtty_of_formatting_gen : type a b c d e f .\n  (a, b, c, d, e, f) formatting_gen ->\n    (a, b, c, d, e, f) fmtty =\nfun formatting_gen -> match formatting_gen with\n  | Open_tag (Format (fmt, _)) -> fmtty_of_fmt fmt\n  | Open_box (Format (fmt, _)) -> fmtty_of_fmt fmt\n\n(* Extract the type representation (an fmtty) of a format. *)\nand fmtty_of_fmt : type a b c d e f .\n  (a, b, c, d, e, f) fmt -> (a, b, c, d, e, f) fmtty =\nfun fmtty -> match fmtty with\n  | String (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n  | Caml_string (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n\n  | Int (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int32 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int32_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Nativeint (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Nativeint_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int64 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int64_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Float (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Float_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n\n  | Char rest                  -> Char_ty (fmtty_of_fmt rest)\n  | Caml_char rest             -> Char_ty (fmtty_of_fmt rest)\n  | Bool (pad, rest)           ->\n      fmtty_of_padding_fmtty pad (Bool_ty (fmtty_of_fmt rest))\n  | Alpha rest                 -> Alpha_ty (fmtty_of_fmt rest)\n  | Theta rest                 -> Theta_ty (fmtty_of_fmt rest)\n  | Custom (arity, _, rest)    -> fmtty_of_custom arity (fmtty_of_fmt rest)\n  | Reader rest                -> Reader_ty (fmtty_of_fmt rest)\n\n  | Format_arg (_, ty, rest) ->\n    Format_arg_ty (ty, fmtty_of_fmt rest)\n  | Format_subst (_, ty, rest) ->\n    Format_subst_ty (ty, ty, fmtty_of_fmt rest)\n\n  | Flush rest                 -> fmtty_of_fmt rest\n  | String_literal (_, rest)   -> fmtty_of_fmt rest\n  | Char_literal (_, rest)     -> fmtty_of_fmt rest\n\n  | Scan_char_set (_, _, rest) -> String_ty (fmtty_of_fmt rest)\n  | Scan_get_counter (_, rest) -> Int_ty (fmtty_of_fmt rest)\n  | Scan_next_char rest        -> Char_ty (fmtty_of_fmt rest)\n  | Ignored_param (ign, rest)  -> fmtty_of_ignored_format ign rest\n  | Formatting_lit (_, rest)   -> fmtty_of_fmt rest\n  | Formatting_gen (fmting_gen, rest)  ->\n    concat_fmtty (fmtty_of_formatting_gen fmting_gen) (fmtty_of_fmt rest)\n\n  | End_of_format              -> End_of_fmtty\n\nand fmtty_of_custom : type x y a b c d e f .\n  (a, x, y) custom_arity -> (a, b, c, d, e, f) fmtty ->\n  (y, b, c, d, e, f) fmtty =\nfun arity fmtty -> match arity with\n  | Custom_zero -> fmtty\n  | Custom_succ arity -> Any_ty (fmtty_of_custom arity fmtty)\n\n(* Extract the fmtty of an ignored parameter followed by the rest of\n   the format. *)\nand fmtty_of_ignored_format : type x y a b c d e f .\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt ->\n    (a, b, c, d, e, f) fmtty =\nfun ign fmt -> match ign with\n  | Ignored_char                    -> fmtty_of_fmt fmt\n  | Ignored_caml_char               -> fmtty_of_fmt fmt\n  | Ignored_string _                -> fmtty_of_fmt fmt\n  | Ignored_caml_string _           -> fmtty_of_fmt fmt\n  | Ignored_int (_, _)              -> fmtty_of_fmt fmt\n  | Ignored_int32 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_nativeint (_, _)        -> fmtty_of_fmt fmt\n  | Ignored_int64 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_float (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_bool _                  -> fmtty_of_fmt fmt\n  | Ignored_format_arg _            -> fmtty_of_fmt fmt\n  | Ignored_format_subst (_, fmtty) -> concat_fmtty fmtty (fmtty_of_fmt fmt)\n  | Ignored_reader                  -> Ignored_reader_ty (fmtty_of_fmt fmt)\n  | Ignored_scan_char_set _         -> fmtty_of_fmt fmt\n  | Ignored_scan_get_counter _      -> fmtty_of_fmt fmt\n  | Ignored_scan_next_char          -> fmtty_of_fmt fmt\n\n(* Add an Int_ty node if padding is taken as an extra argument (ex: \"%*s\"). *)\nand fmtty_of_padding_fmtty : type x a b c d e f .\n    (x, a) padding -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun pad fmtty -> match pad with\n    | No_padding    -> fmtty\n    | Lit_padding _ -> fmtty\n    | Arg_padding _ -> Int_ty fmtty\n\n(* Add an Int_ty node if precision is taken as an extra argument (ex: \"%.*f\").*)\nand fmtty_of_precision_fmtty : type x a b c d e f .\n    (x, a) precision -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun prec fmtty -> match prec with\n    | No_precision    -> fmtty\n    | Lit_precision _ -> fmtty\n    | Arg_precision   -> Int_ty fmtty\n\n(******************************************************************************)\n                            (* Format typing *)\n\n(* Exception raised when a format does not match a given format type. *)\nexception Type_mismatch\n\n(* Type a padding. *)\n(* Take an Int_ty from the fmtty if the integer should be kept as argument. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padding : type a b c d e f x y .\n    (x, y) padding -> (a, b, c, d, e, f) fmtty ->\n      (a, b, c, d, e, f) padding_fmtty_ebb =\nfun pad fmtty -> match pad, fmtty with\n  | No_padding, _ -> Padding_fmtty_EBB (No_padding, fmtty)\n  | Lit_padding (padty, w), _ -> Padding_fmtty_EBB (Lit_padding (padty,w),fmtty)\n  | Arg_padding padty, Int_ty rest -> Padding_fmtty_EBB (Arg_padding padty,rest)\n  | _ -> raise Type_mismatch\n\n(* Convert a (upadding, uprecision) to a (padding, precision). *)\n(* Take one or two Int_ty from the fmtty if needed. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padprec : type a b c d e f x y z .\n  (x, y) padding -> (y, z) precision -> (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) padprec_fmtty_ebb =\nfun pad prec fmtty -> match prec, type_padding pad fmtty with\n  | No_precision, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, No_precision, rest)\n  | Lit_precision p, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, Lit_precision p, rest)\n  | Arg_precision, Padding_fmtty_EBB (pad, Int_ty rest) ->\n    Padprec_fmtty_EBB (pad, Arg_precision, rest)\n  | _, Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n\n(* Type a format according to an fmtty. *)\n(* If typing succeed, generate a copy of the format with the same\n    type parameters as the fmtty. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet rec type_format :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty -> match type_format_gen fmt fmtty with\n  | Fmt_fmtty_EBB (fmt', End_of_fmtty) -> fmt'\n  | _ -> raise Type_mismatch\n\nand type_format_gen :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun fmt fmtty -> match fmt, fmtty with\n  | Char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char fmt', fmtty')\n  | Caml_char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Caml_char fmt', fmtty')\n  | String (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (String (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Caml_string (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Caml_string (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Int (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int32 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int32_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int32 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Nativeint (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Nativeint_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Nativeint (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int64 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int64_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int64 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Float (fconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Float_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Float (fconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Bool (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, Bool_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Bool (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Flush fmt_rest, fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Flush fmt', fmtty')\n\n  | String_literal (str, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (String_literal (str, fmt'), fmtty')\n  | Char_literal (chr, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char_literal (chr, fmt'), fmtty')\n\n  | Format_arg (pad_opt, sub_fmtty, fmt_rest),\n    Format_arg_ty (sub_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub_fmtty <> Fmtty_EBB sub_fmtty' then raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Format_arg (pad_opt, sub_fmtty', fmt'), fmtty')\n  | Format_subst (pad_opt, sub_fmtty, fmt_rest),\n    Format_subst_ty (sub_fmtty1, _sub_fmtty2, fmtty_rest) ->\n    if Fmtty_EBB (erase_rel sub_fmtty) <> Fmtty_EBB (erase_rel sub_fmtty1) then\n      raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') =\n      type_format_gen fmt_rest (erase_rel fmtty_rest)\n    in\n    Fmt_fmtty_EBB (Format_subst (pad_opt, sub_fmtty1, fmt'), fmtty')\n  (* Printf and Format specific constructors: *)\n  | Alpha fmt_rest, Alpha_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Alpha fmt', fmtty')\n  | Theta fmt_rest, Theta_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Theta fmt', fmtty')\n\n  (* Format specific constructors: *)\n  | Formatting_lit (formatting_lit, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Formatting_lit (formatting_lit, fmt'), fmtty')\n  | Formatting_gen (formatting_gen, fmt_rest), fmtty_rest ->\n    type_formatting_gen formatting_gen fmt_rest fmtty_rest\n\n  (* Scanf specific constructors: *)\n  | Reader fmt_rest, Reader_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Reader fmt', fmtty')\n  | Scan_char_set (width_opt, char_set, fmt_rest), String_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_char_set (width_opt, char_set, fmt'), fmtty')\n  | Scan_get_counter (counter, fmt_rest), Int_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_get_counter (counter, fmt'), fmtty')\n  | Ignored_param (ign, rest), fmtty_rest ->\n    type_ignored_param ign rest fmtty_rest\n\n  | End_of_format, fmtty_rest -> Fmt_fmtty_EBB (End_of_format, fmtty_rest)\n\n  | _ -> raise Type_mismatch\n\nand type_formatting_gen : type a1 a3 b1 b3 c1 c3 d1 d3 e1 e2 e3 f1 f2 f3 .\n    (a1, b1, c1, d1, e1, f1) formatting_gen ->\n    (f1, b1, c1, e1, e2, f2) fmt ->\n    (a3, b3, c3, d3, e3, f3) fmtty ->\n    (a3, b3, c3, d3, e3, f3) fmt_fmtty_ebb =\nfun formatting_gen fmt0 fmtty0 -> match formatting_gen with\n  | Open_tag (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_tag (Format (fmt2, str)), fmt3), fmtty3)\n  | Open_box (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_box (Format (fmt2, str)), fmt3), fmtty3)\n\n(* Type an Ignored_param node according to an fmtty. *)\nand type_ignored_param : type p q x y z t u v a b c d e f .\n    (x, y, z, t, q, p) ignored ->\n    (p, y, z, q, u, v) fmt ->\n    (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) fmt_fmtty_ebb =\nfun ign fmt fmtty -> match ign with\n  | Ignored_char               as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_char          as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_string _           as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_string _      as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int _              as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int32 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_nativeint _        as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int64 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_float _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_bool _             as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_char_set _    as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_get_counter _ as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_next_char     as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_format_arg (pad_opt, sub_fmtty) ->\n    type_ignored_param_one (Ignored_format_arg (pad_opt, sub_fmtty)) fmt fmtty\n  | Ignored_format_subst (pad_opt, sub_fmtty) ->\n    let Fmtty_fmt_EBB (sub_fmtty', Fmt_fmtty_EBB (fmt', fmtty')) =\n      type_ignored_format_substitution sub_fmtty fmt fmtty in\n    Fmt_fmtty_EBB (Ignored_param (Ignored_format_subst (pad_opt, sub_fmtty'),\n                                  fmt'),\n                   fmtty')\n  | Ignored_reader -> (\n    match fmtty with\n    | Ignored_reader_ty fmtty_rest ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty_rest in\n      Fmt_fmtty_EBB (Ignored_param (Ignored_reader, fmt'), fmtty')\n    | _ -> raise Type_mismatch\n  )\n\nand type_ignored_param_one : type a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2 .\n    (a2, b2, c2, d2, d2, a2) ignored ->\n    (a1, b1, c1, d1, e1, f1) fmt ->\n    (a2, b2, c2, d2, e2, f2) fmtty ->\n    (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun ign fmt fmtty ->\n  let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty in\n  Fmt_fmtty_EBB (Ignored_param (ign, fmt'), fmtty')\n\n(* Typing of the complex case: \"%_(...%)\". *)\nand type_ignored_format_substitution : type w x y z p s t u a b c d e f .\n    (w, x, y, z, s, p) fmtty ->\n    (p, x, y, s, t, u) fmt ->\n    (a, b, c, d, e, f) fmtty -> (a, b, c, d, e, f) fmtty_fmt_ebb =\nfun sub_fmtty fmt fmtty -> match sub_fmtty, fmtty with\n  | Char_ty sub_fmtty_rest, Char_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Char_ty sub_fmtty_rest', fmt')\n  | String_ty sub_fmtty_rest, String_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (String_ty sub_fmtty_rest', fmt')\n  | Int_ty sub_fmtty_rest, Int_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int_ty sub_fmtty_rest', fmt')\n  | Int32_ty sub_fmtty_rest, Int32_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int32_ty sub_fmtty_rest', fmt')\n  | Nativeint_ty sub_fmtty_rest, Nativeint_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Nativeint_ty sub_fmtty_rest', fmt')\n  | Int64_ty sub_fmtty_rest, Int64_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int64_ty sub_fmtty_rest', fmt')\n  | Float_ty sub_fmtty_rest, Float_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Float_ty sub_fmtty_rest', fmt')\n  | Bool_ty sub_fmtty_rest, Bool_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Bool_ty sub_fmtty_rest', fmt')\n  | Alpha_ty sub_fmtty_rest, Alpha_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Alpha_ty sub_fmtty_rest', fmt')\n  | Theta_ty sub_fmtty_rest, Theta_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Theta_ty sub_fmtty_rest', fmt')\n  | Reader_ty sub_fmtty_rest, Reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Reader_ty sub_fmtty_rest', fmt')\n  | Ignored_reader_ty sub_fmtty_rest, Ignored_reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Ignored_reader_ty sub_fmtty_rest', fmt')\n\n  | Format_arg_ty (sub2_fmtty, sub_fmtty_rest),\n    Format_arg_ty (sub2_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub2_fmtty <> Fmtty_EBB sub2_fmtty' then raise Type_mismatch;\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Format_arg_ty (sub2_fmtty', sub_fmtty_rest'), fmt')\n  | Format_subst_ty (sub1_fmtty,  sub2_fmtty,  sub_fmtty_rest),\n    Format_subst_ty (sub1_fmtty', sub2_fmtty', fmtty_rest) ->\n    (* TODO define Fmtty_rel_EBB to remove those erase_rel *)\n    if Fmtty_EBB (erase_rel sub1_fmtty) <> Fmtty_EBB (erase_rel sub1_fmtty')\n    then raise Type_mismatch;\n    if Fmtty_EBB (erase_rel sub2_fmtty) <> Fmtty_EBB (erase_rel sub2_fmtty')\n    then raise Type_mismatch;\n    let sub_fmtty' = trans (symm sub1_fmtty') sub2_fmtty' in\n    let _, f2, _, f4 = fmtty_rel_det sub_fmtty' in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution (erase_rel sub_fmtty_rest) fmt fmtty_rest\n    in\n    Fmtty_fmt_EBB (Format_subst_ty (sub1_fmtty', sub2_fmtty',\n                                    symm sub_fmtty_rest'),\n                   fmt')\n  | End_of_fmtty, fmtty ->\n    Fmtty_fmt_EBB (End_of_fmtty, type_format_gen fmt fmtty)\n  | _ -> raise Type_mismatch\n\n(* This implementation of `recast` is a bit disappointing. The\n   invariant provided by the type are very strong: the input format's\n   type is in relation to the output type's as witnessed by the\n   fmtty_rel argument. One would at first expect this function to be\n   total, and implementable by exhaustive pattern matching. Instead,\n   we reuse the highly partial and much less well-defined function\n   `type_format` that has lost all knowledge of the correspondence\n   between the argument's types.\n\n   Besides the fact that this function reuses a lot of the\n   `type_format` logic (eg.: seeing Int_ty in the fmtty parameter does\n   not let you match on Int only, as you may in fact have Float\n   (Arg_padding, ...) (\"%.*d\") beginning with an Int_ty), it is also\n   a partial function, because the typing information in a format is\n   not quite enough to reconstruct it unambiguously. For example, the\n   format types of \"%d%_r\" and \"%_r%d\" have the same format6\n   parameters, but they are not at all exchangeable, and putting one\n   in place of the other must result in a dynamic failure.\n\n   Given that:\n   - we'd have to duplicate a lot of non-trivial typing logic from type_format\n   - this wouldn't even eliminate (all) the dynamic failures\n   we decided to just reuse type_format directly for now.\n*)\nlet recast :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a1, b1, c1, d1, e1, f1,\n      a2, b2, c2, d2, e2, f2) fmtty_rel\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty ->\n  type_format fmt (erase_rel (symm fmtty))\n\n(******************************************************************************)\n                             (* Printing tools *)\n\n(* Add padding spaces around a string. *)\nlet fix_padding padty width str =\n  let len = String.length str in\n  let width, padty =\n    abs width,\n    (* while literal padding widths are always non-negative,\n       dynamically-set widths (Arg_padding, eg. %*d) may be negative;\n       we interpret those as specifying a padding-to-the-left; this\n       means that '0' may get dropped even if it was explicitly set,\n       but:\n       - this is what the legacy implementation does, and\n         we preserve compatibility if possible\n       - we could only signal this issue by failing at runtime,\n         which is not very nice... *)\n    if width < 0 then Left else padty in\n  if width <= len then str else\n    let res = Bytes.make width (if padty = Zeros then '0' else ' ') in\n    begin match padty with\n    | Left  -> String.blit str 0 res 0 len\n    | Right -> String.blit str 0 res (width - len) len\n    | Zeros when len > 0 && (str.[0] = '+' || str.[0] = '-' || str.[0] = ' ') ->\n      Bytes.set res 0 str.[0];\n      String.blit str 1 res (width - len + 1) (len - 1)\n    | Zeros when len > 1 && str.[0] = '0' && (str.[1] = 'x' || str.[1] = 'X') ->\n      Bytes.set res 1 str.[1];\n      String.blit str 2 res (width - len + 2) (len - 2)\n    | Zeros ->\n      String.blit str 0 res (width - len) len\n    end;\n    Bytes.unsafe_to_string res\n\n(* Add '0' padding to int, int32, nativeint or int64 string representation. *)\nlet fix_int_precision prec str =\n  let prec = abs prec in\n  let len = String.length str in\n  match str.[0] with\n  | ('+' | '-' | ' ') as c when prec + 1 > len ->\n    let res = Bytes.make (prec + 1) '0' in\n    Bytes.set res 0 c;\n    String.blit str 1 res (prec - len + 2) (len - 1);\n    Bytes.unsafe_to_string res\n  | '0' when prec + 2 > len && len > 1 && (str.[1] = 'x' || str.[1] = 'X') ->\n    let res = Bytes.make (prec + 2) '0' in\n    Bytes.set res 1 str.[1];\n    String.blit str 2 res (prec - len + 4) (len - 2);\n    Bytes.unsafe_to_string res\n  | '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' when prec > len ->\n    let res = Bytes.make prec '0' in\n    String.blit str 0 res (prec - len) len;\n    Bytes.unsafe_to_string res\n  | _ ->\n    str\n\n(* Escape a string according to the OCaml lexing convention. *)\nlet string_to_caml_string str =\n  let str = String.escaped str in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\\"' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Generate the format_int/int32/nativeint/int64 first argument\n   from an int_conv. *)\nlet format_of_iconv = function\n  | Int_d | Int_Cd -> \"%d\" | Int_pd -> \"%+d\" | Int_sd -> \"% d\"\n  | Int_i | Int_Ci -> \"%i\" | Int_pi -> \"%+i\" | Int_si -> \"% i\"\n  | Int_x -> \"%x\" | Int_Cx -> \"%#x\"\n  | Int_X -> \"%X\" | Int_CX -> \"%#X\"\n  | Int_o -> \"%o\" | Int_Co -> \"%#o\"\n  | Int_u | Int_Cu -> \"%u\"\n\nlet format_of_iconvL = function\n  | Int_d | Int_Cd -> \"%Ld\" | Int_pd -> \"%+Ld\" | Int_sd -> \"% Ld\"\n  | Int_i | Int_Ci -> \"%Li\" | Int_pi -> \"%+Li\" | Int_si -> \"% Li\"\n  | Int_x -> \"%Lx\" | Int_Cx -> \"%#Lx\"\n  | Int_X -> \"%LX\" | Int_CX -> \"%#LX\"\n  | Int_o -> \"%Lo\" | Int_Co -> \"%#Lo\"\n  | Int_u | Int_Cu -> \"%Lu\"\n\nlet format_of_iconvl = function\n  | Int_d | Int_Cd -> \"%ld\" | Int_pd -> \"%+ld\" | Int_sd -> \"% ld\"\n  | Int_i | Int_Ci -> \"%li\" | Int_pi -> \"%+li\" | Int_si -> \"% li\"\n  | Int_x -> \"%lx\" | Int_Cx -> \"%#lx\"\n  | Int_X -> \"%lX\" | Int_CX -> \"%#lX\"\n  | Int_o -> \"%lo\" | Int_Co -> \"%#lo\"\n  | Int_u | Int_Cu -> \"%lu\"\n\nlet format_of_iconvn = function\n  | Int_d | Int_Cd -> \"%nd\" | Int_pd -> \"%+nd\" | Int_sd -> \"% nd\"\n  | Int_i | Int_Ci -> \"%ni\" | Int_pi -> \"%+ni\" | Int_si -> \"% ni\"\n  | Int_x -> \"%nx\" | Int_Cx -> \"%#nx\"\n  | Int_X -> \"%nX\" | Int_CX -> \"%#nX\"\n  | Int_o -> \"%no\" | Int_Co -> \"%#no\"\n  | Int_u | Int_Cu -> \"%nu\"\n\n(* Generate the format_float first argument from a float_conv. *)\nlet format_of_fconv fconv prec =\n    let prec = abs prec in\n    let symb = char_of_fconv ~cF:'g' fconv in\n    let buf = buffer_create 16 in\n    buffer_add_char buf '%';\n    bprint_fconv_flag buf fconv;\n    buffer_add_char buf '.';\n    buffer_add_string buf (Int.to_string prec);\n    buffer_add_char buf symb;\n    buffer_contents buf\n\nlet transform_int_alt iconv s =\n  match iconv with\n  | Int_Cd | Int_Ci | Int_Cu ->\n    let digits =\n      let n = ref 0 in\n      for i = 0 to String.length s - 1 do\n        match String.unsafe_get s i with\n        | '0'..'9' -> incr n\n        | _ -> ()\n      done;\n      !n\n    in\n    let buf = Bytes.create (String.length s + (digits - 1) / 3) in\n    let pos = ref 0 in\n    let put c = Bytes.set buf !pos c; incr pos in\n    let left = ref ((digits - 1) mod 3 + 1) in\n    for i = 0 to String.length s - 1 do\n      match String.unsafe_get s i with\n      | '0'..'9' as c ->\n          if !left = 0 then (put '_'; left := 3); decr left; put c\n      | c -> put c\n    done;\n    Bytes.unsafe_to_string buf\n  | _ -> s\n\n(* Convert an integer to a string according to a conversion. *)\nlet convert_int iconv n =\n  transform_int_alt iconv (format_int (format_of_iconv iconv) n)\nlet convert_int32 iconv n =\n  transform_int_alt iconv (format_int32 (format_of_iconvl iconv) n)\nlet convert_nativeint iconv n =\n  transform_int_alt iconv (format_nativeint (format_of_iconvn iconv) n)\nlet convert_int64 iconv n =\n  transform_int_alt iconv (format_int64 (format_of_iconvL iconv) n)\n\n(* Convert a float to string. *)\n(* Fix special case of \"OCaml float format\". *)\nlet convert_float fconv prec x =\n  let hex () =\n    let sign =\n      match fst fconv with\n      | Float_flag_p -> '+'\n      | Float_flag_s -> ' '\n      | _ -> '-' in\n    hexstring_of_float x prec sign in\n  let add_dot_if_needed str =\n    let len = String.length str in\n    let rec is_valid i =\n      if i = len then false else\n        match str.[i] with\n        | '.' | 'e' | 'E' -> true\n        | _ -> is_valid (i + 1) in\n    if is_valid 0 then str else str ^ \".\" in\n  let caml_special_val str = match classify_float x with\n    | FP_normal | FP_subnormal | FP_zero -> str\n    | FP_infinite -> if x < 0.0 then \"neg_infinity\" else \"infinity\"\n    | FP_nan -> \"nan\" in\n  match snd fconv with\n  | Float_h -> hex ()\n  | Float_H -> String.uppercase_ascii (hex ())\n  | Float_CF -> caml_special_val (hex ())\n  | Float_F ->\n    let str = format_float (format_of_fconv fconv prec) x in\n    caml_special_val (add_dot_if_needed str)\n  | Float_f | Float_e | Float_E | Float_g | Float_G ->\n    format_float (format_of_fconv fconv prec) x\n\n(* Convert a char to a string according to the OCaml lexical convention. *)\nlet format_caml_char c =\n  let str = Char.escaped c in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\'' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Convert a format type to string *)\nlet string_of_fmtty fmtty =\n  let buf = buffer_create 16 in\n  bprint_fmtty buf fmtty;\n  buffer_contents buf\n\n(******************************************************************************)\n                        (* Generic printing function *)\n\n(* Make a generic printing function. *)\n(* Used to generate Printf and Format printing functions. *)\n(* Parameters:\n     k: a continuation finally applied to the output stream and the accumulator.\n     o: the output stream (see k, %a and %t).\n     acc: rev list of printing entities (string, char, flush, formatting, ...).\n     fmt: the format. *)\nlet rec make_printf : type a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k acc fmt -> match fmt with\n  | Char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k new_acc rest\n  | Caml_char rest ->\n    fun c ->\n      let new_acc = Acc_data_string (acc, format_caml_char c) in\n      make_printf k new_acc rest\n  | String (pad, rest) ->\n    make_padding k acc rest pad (fun str -> str)\n  | Caml_string (pad, rest) ->\n    make_padding k acc rest pad string_to_caml_string\n  | Int (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int iconv\n  | Int32 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int32 iconv\n  | Nativeint (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_nativeint iconv\n  | Int64 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int64 iconv\n  | Float (fconv, pad, prec, rest) ->\n    make_float_padding_precision k acc rest pad prec fconv\n  | Bool (pad, rest) ->\n    make_padding k acc rest pad string_of_bool\n  | Alpha rest ->\n    fun f x -> make_printf k (Acc_delay (acc, fun o -> f o x)) rest\n  | Theta rest ->\n    fun f -> make_printf k (Acc_delay (acc, f)) rest\n  | Custom (arity, f, rest) ->\n    make_custom k acc rest arity (f ())\n  | Reader _ ->\n    (* This case is impossible, by typing of formats. *)\n    (* Indeed, since printf and co. take a format4 as argument, the 'd and 'e\n       type parameters of fmt are obviously equals. The Reader is the\n       only constructor which touch 'd and 'e type parameters of the format\n       type, it adds an (->) to the 'd parameters. Consequently, a format4\n       cannot contain a Reader node, except in the sub-format associated to\n       an %{...%}. It's not a problem because make_printf do not call\n       itself recursively on the sub-format associated to %{...%}. *)\n    assert false\n  | Flush rest ->\n    make_printf k (Acc_flush acc) rest\n\n  | String_literal (str, rest) ->\n    make_printf k (Acc_string_literal (acc, str)) rest\n  | Char_literal (chr, rest) ->\n    make_printf k (Acc_char_literal (acc, chr)) rest\n\n  | Format_arg (_, sub_fmtty, rest) ->\n    let ty = string_of_fmtty sub_fmtty in\n    (fun str ->\n      ignore str;\n      make_printf k (Acc_data_string (acc, ty)) rest)\n  | Format_subst (_, fmtty, rest) ->\n    fun (Format (fmt, _)) -> make_printf k acc\n      (concat_fmt (recast fmt fmtty) rest)\n\n  | Scan_char_set (_, _, rest) ->\n    let new_acc = Acc_invalid_arg (acc, \"Printf: bad conversion %[\") in\n    fun _ -> make_printf k new_acc rest\n  | Scan_get_counter (_, rest) ->\n    (* This case should be refused for Printf. *)\n    (* Accepted for backward compatibility. *)\n    (* Interpret %l, %n and %L as %u. *)\n    fun n ->\n      let new_acc = Acc_data_string (acc, format_int \"%u\" n) in\n      make_printf k new_acc rest\n  | Scan_next_char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k new_acc rest\n  | Ignored_param (ign, rest) ->\n    make_ignored_param k acc ign rest\n\n  | Formatting_lit (fmting_lit, rest) ->\n    make_printf k (Acc_formatting_lit (acc, fmting_lit)) rest\n  | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n    let k' kacc =\n      make_printf k (Acc_formatting_gen (acc, Acc_open_tag kacc)) rest in\n    make_printf k' End_of_acc fmt'\n  | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n    let k' kacc =\n      make_printf k (Acc_formatting_gen (acc, Acc_open_box kacc)) rest in\n    make_printf k' End_of_acc fmt'\n\n  | End_of_format ->\n    k acc\n\n(* Delay the error (Invalid_argument \"Printf: bad conversion %_\"). *)\n(* Generate functions to take remaining arguments (after the \"%_\"). *)\nand make_ignored_param : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k acc ign fmt -> match ign with\n  | Ignored_char                    -> make_invalid_arg k acc fmt\n  | Ignored_caml_char               -> make_invalid_arg k acc fmt\n  | Ignored_string _                -> make_invalid_arg k acc fmt\n  | Ignored_caml_string _           -> make_invalid_arg k acc fmt\n  | Ignored_int (_, _)              -> make_invalid_arg k acc fmt\n  | Ignored_int32 (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_nativeint (_, _)        -> make_invalid_arg k acc fmt\n  | Ignored_int64 (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_float (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_bool _                  -> make_invalid_arg k acc fmt\n  | Ignored_format_arg _            -> make_invalid_arg k acc fmt\n  | Ignored_format_subst (_, fmtty) -> make_from_fmtty k acc fmtty fmt\n  | Ignored_reader                  -> assert false\n  | Ignored_scan_char_set _         -> make_invalid_arg k acc fmt\n  | Ignored_scan_get_counter _      -> make_invalid_arg k acc fmt\n  | Ignored_scan_next_char          -> make_invalid_arg k acc fmt\n\n\n(* Special case of printf \"%_(\". *)\nand make_from_fmtty : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, y, x) fmtty ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k acc fmtty fmt -> match fmtty with\n  | Char_ty rest            -> fun _ -> make_from_fmtty k acc rest fmt\n  | String_ty rest          -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int_ty rest             -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int32_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Nativeint_ty rest       -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int64_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Float_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Bool_ty rest            -> fun _ -> make_from_fmtty k acc rest fmt\n  | Alpha_ty rest           -> fun _ _ -> make_from_fmtty k acc rest fmt\n  | Theta_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Any_ty rest             -> fun _ -> make_from_fmtty k acc rest fmt\n  | Reader_ty _             -> assert false\n  | Ignored_reader_ty _     -> assert false\n  | Format_arg_ty (_, rest) -> fun _ -> make_from_fmtty k acc rest fmt\n  | End_of_fmtty            -> make_invalid_arg k acc fmt\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let ty = trans (symm ty1) ty2 in\n    fun _ -> make_from_fmtty k acc (concat_fmtty ty rest) fmt\n\n(* Insert an Acc_invalid_arg in the accumulator and continue to generate\n   closures to get the remaining arguments. *)\nand make_invalid_arg : type a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k acc fmt ->\n  make_printf k (Acc_invalid_arg (acc, \"Printf: bad conversion %_\")) fmt\n\n(* Fix padding, take it as an extra integer argument if needed. *)\nand make_padding : type x z a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, z -> a) padding -> (z -> string) -> x =\n  fun k acc fmt pad trans -> match pad with\n  | No_padding ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, trans x) in\n      make_printf k new_acc fmt\n  | Lit_padding (padty, width) ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty width (trans x)) in\n      make_printf k new_acc fmt\n  | Arg_padding padty ->\n    fun w x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty w (trans x)) in\n      make_printf k new_acc fmt\n\n(* Fix padding and precision for int, int32, nativeint or int64. *)\n(* Take one or two extra integer arguments if needed. *)\nand make_int_padding_precision : type x y z a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, z -> a) precision -> (int_conv -> z -> string) ->\n    int_conv -> x =\n  fun k acc fmt pad prec trans iconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = trans iconv x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n\n(* Convert a float, fix padding and precision if needed. *)\n(* Take the float argument and one or two extra integer arguments if needed. *)\nand make_float_padding_precision : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, float -> a) precision -> float_conv -> x =\n  fun k acc fmt pad prec fconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = convert_float fconv p x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = convert_float fconv p x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      let str' = fix_padding padty w str in\n      make_printf k (Acc_data_string (acc, str')) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      let str' = fix_padding padty w str in\n      make_printf k (Acc_data_string (acc, str')) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\nand make_custom : type x y a b c d e f .\n  ((b, c) acc -> f) -> (b, c) acc ->\n  (a, b, c, d, e, f) fmt ->\n  (a, x, y) custom_arity -> x -> y =\n  fun k acc rest arity f -> match arity with\n  | Custom_zero -> make_printf k (Acc_data_string (acc, f)) rest\n  | Custom_succ arity ->\n    fun x ->\n      make_custom k acc rest arity (f x)\n\nlet const x _ = x\n\nlet rec make_iprintf : type a b c d e f state.\n  (state -> f) -> state -> (a, b, c, d, e, f) fmt -> a =\n  fun k o fmt -> match fmt with\n    | Char rest ->\n        const (make_iprintf k o rest)\n    | Caml_char rest ->\n        const (make_iprintf k o rest)\n    | String (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | String (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | String (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Caml_string (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Int (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int32 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Nativeint (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int64 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Float (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Bool (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | Bool (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | Bool (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Alpha rest ->\n        const (const (make_iprintf k o rest))\n    | Theta rest ->\n        const (make_iprintf k o rest)\n    | Custom (arity, _, rest) ->\n        fn_of_custom_arity k o rest arity\n    | Reader _ ->\n        (* This case is impossible, by typing of formats.  See the\n           note in the corresponding case for make_printf. *)\n        assert false\n    | Flush rest ->\n        make_iprintf k o rest\n    | String_literal (_, rest) ->\n        make_iprintf k o rest\n    | Char_literal (_, rest) ->\n        make_iprintf k o rest\n    | Format_arg (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Format_subst (_, fmtty, rest) ->\n        fun (Format (fmt, _)) ->\n          make_iprintf k o\n            (concat_fmt (recast fmt fmtty) rest)\n    | Scan_char_set (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_get_counter (_, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_next_char rest ->\n        const (make_iprintf k o rest)\n    | Ignored_param (ign, rest) ->\n        make_ignored_param (fun _ -> k o) (End_of_acc) ign rest\n    | Formatting_lit (_, rest) ->\n        make_iprintf k o rest\n    | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | End_of_format ->\n        k o\nand fn_of_padding_precision :\n  type x y z a b c d e f state.\n  (state -> f) -> state -> (a, b, c, d, e, f) fmt ->\n  (x, y) padding -> (y, z -> a) precision -> x =\n  fun k o fmt pad prec -> match pad, prec with\n    | No_padding   , No_precision    ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Lit_padding _, No_precision    ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, No_precision    ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Lit_precision _ ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Arg_precision   ->\n        const (const (const (make_iprintf k o fmt)))\nand fn_of_custom_arity : type x y a b c d e f state.\n  (state -> f) ->\n  state -> (a, b, c, d, e, f) fmt -> (a, x, y) custom_arity -> y =\n  fun k o fmt -> function\n    | Custom_zero ->\n        make_iprintf k o fmt\n    | Custom_succ arity ->\n        const (fn_of_custom_arity k o fmt arity)\n\n(******************************************************************************)\n                          (* Continuations for make_printf *)\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Used as a continuation of make_printf. *)\nlet rec output_acc o acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    output_acc o p; output_string o s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc o p; output_string o \"@{\"; output_acc o acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc o p; output_string o \"@[\"; output_acc o acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc o p; output_string o s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc o p; output_char o c\n  | Acc_delay (p, f)         -> output_acc o p; f o\n  | Acc_flush p              -> output_acc o p; flush o\n  | Acc_invalid_arg (p, msg) -> output_acc o p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Used as a continuation of make_printf. *)\nlet rec bufput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    bufput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    bufput_acc b p; Buffer.add_string b \"@{\"; bufput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    bufput_acc b p; Buffer.add_string b \"@[\"; bufput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> bufput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> bufput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> bufput_acc b p; f b\n  | Acc_flush p              -> bufput_acc b p;\n  | Acc_invalid_arg (p, msg) -> bufput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from bufput_acc by the interpretation of %a and %t. *)\n(* Used as a continuation of make_printf. *)\nlet rec strput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    strput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc b p; Buffer.add_string b \"@{\"; strput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc b p; Buffer.add_string b \"@[\"; strput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> strput_acc b p; Buffer.add_string b (f ())\n  | Acc_flush p              -> strput_acc b p;\n  | Acc_invalid_arg (p, msg) -> strput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(******************************************************************************)\n                          (* Error management *)\n\n(* Raise [Failure] with a pretty-printed error message. *)\nlet failwith_message (Format (fmt, _)) =\n  let buf = Buffer.create 256 in\n  let k acc = strput_acc buf acc; failwith (Buffer.contents buf) in\n  make_printf k End_of_acc fmt\n\n(******************************************************************************)\n                            (* Formatting tools *)\n\n(* Convert a string to an open block description (indent, block_type) *)\nlet open_box_of_string str =\n  if str = \"\" then (0, Pp_box) else\n    let len = String.length str in\n    let invalid_box () = failwith_message \"invalid box description %S\" str in\n    let rec parse_spaces i =\n      if i = len then i else\n        match str.[i] with\n        | ' ' | '\\t' -> parse_spaces (i + 1)\n        | _ -> i\n    and parse_lword i j =\n      if j = len then j else\n        match str.[j] with\n        | 'a' .. 'z' -> parse_lword i (j + 1)\n        | _ -> j\n    and parse_int i j =\n      if j = len then j else\n        match str.[j] with\n        | '0' .. '9' | '-' -> parse_int i (j + 1)\n        | _ -> j in\n    let wstart = parse_spaces 0 in\n    let wend = parse_lword wstart wstart in\n    let box_name = String.sub str wstart (wend - wstart) in\n    let nstart = parse_spaces wend in\n    let nend = parse_int nstart nstart in\n    let indent =\n      if nstart = nend then 0 else\n        try int_of_string (String.sub str nstart (nend - nstart))\n        with Failure _ -> invalid_box () in\n    let exp_end = parse_spaces nend in\n    if exp_end <> len then invalid_box ();\n    let box_type = match box_name with\n      | \"\" | \"b\" -> Pp_box\n      | \"h\"      -> Pp_hbox\n      | \"v\"      -> Pp_vbox\n      | \"hv\"     -> Pp_hvbox\n      | \"hov\"    -> Pp_hovbox\n      | _        -> invalid_box () in\n    (indent, box_type)\n\n(******************************************************************************)\n                            (* Parsing tools *)\n\n(* Create a padding_fmt_ebb from a padding and a format. *)\n(* Copy the padding to disjoin the type parameters of argument and result. *)\nlet make_padding_fmt_ebb : type x y .\n    (x, y) padding -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) padding_fmt_ebb =\nfun pad fmt -> match pad with\n  | No_padding         -> Padding_fmt_EBB (No_padding, fmt)\n  | Lit_padding (s, w) -> Padding_fmt_EBB (Lit_padding (s, w), fmt)\n  | Arg_padding s      -> Padding_fmt_EBB (Arg_padding s, fmt)\n\n(* Create a precision_fmt_ebb from a precision and a format. *)\n(* Copy the precision to disjoin the type parameters of argument and result. *)\nlet make_precision_fmt_ebb : type x y .\n    (x, y) precision -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) precision_fmt_ebb =\nfun prec fmt -> match prec with\n  | No_precision    -> Precision_fmt_EBB (No_precision, fmt)\n  | Lit_precision p -> Precision_fmt_EBB (Lit_precision p, fmt)\n  | Arg_precision   -> Precision_fmt_EBB (Arg_precision, fmt)\n\n(* Create a padprec_fmt_ebb from a padding, a precision and a format. *)\n(* Copy the padding and the precision to disjoin type parameters of arguments\n   and result. *)\nlet make_padprec_fmt_ebb : type x y z t .\n    (x, y) padding -> (z, t) precision ->\n    (_, _, _, _, _, _) fmt ->\n    (_, _, _, _, _) padprec_fmt_ebb =\nfun pad prec fmt ->\n  let Precision_fmt_EBB (prec, fmt') = make_precision_fmt_ebb prec fmt in\n  match pad with\n  | No_padding         -> Padprec_fmt_EBB (No_padding, prec, fmt')\n  | Lit_padding (s, w) -> Padprec_fmt_EBB (Lit_padding (s, w), prec, fmt')\n  | Arg_padding s      -> Padprec_fmt_EBB (Arg_padding s, prec, fmt')\n\n(******************************************************************************)\n                             (* Format parsing *)\n\n(* Parse a string representing a format and create a fmt_ebb. *)\n(* Raise [Failure] in case of invalid format. *)\nlet fmt_ebb_of_string ?legacy_behavior str =\n  (* Parameters naming convention:                                    *)\n  (*   - lit_start: start of the literal sequence.                    *)\n  (*   - str_ind: current index in the string.                        *)\n  (*   - end_ind: end of the current (sub-)format.                    *)\n  (*   - pct_ind: index of the '%' in the current micro-format.       *)\n  (*   - zero:  is the '0' flag defined in the current micro-format.  *)\n  (*   - minus: is the '-' flag defined in the current micro-format.  *)\n  (*   - plus:  is the '+' flag defined in the current micro-format.  *)\n  (*   - hash:  is the '#' flag defined in the current micro-format.  *)\n  (*   - space: is the ' ' flag defined in the current micro-format.  *)\n  (*   - ign:   is the '_' flag defined in the current micro-format.  *)\n  (*   - pad: padding of the current micro-format.                    *)\n  (*   - prec: precision of the current micro-format.                 *)\n  (*   - symb: char representing the conversion ('c', 's', 'd', ...). *)\n  (*   - char_set: set of characters as bitmap (see scanf %[...]).    *)\n\n  let legacy_behavior = match legacy_behavior with\n    | Some flag -> flag\n    | None -> true\n  (*  When this flag is enabled, the format parser tries to behave as\n      the <4.02 implementations, in particular it ignores most benine\n      nonsensical format. When the flag is disabled, it will reject any\n      format that is not accepted by the specification.\n\n      A typical example would be \"%+ d\": specifying both '+' (if the\n      number is positive, pad with a '+' to get the same width as\n      negative numbers) and ' ' (if the number is positive, pad with\n      a space) does not make sense, but the legacy (< 4.02)\n      implementation was happy to just ignore the space.\n  *)\n  in\n\n  (* Raise [Failure] with a friendly error message. *)\n  let invalid_format_message str_ind msg =\n    failwith_message\n      \"invalid format %S: at character number %d, %s\"\n      str str_ind msg\n  in\n\n  (* Used when the end of the format (or the current sub-format) was encountered\n      unexpectedly. *)\n  let unexpected_end_of_format end_ind =\n    invalid_format_message end_ind\n      \"unexpected end of format\"\n  in\n\n  (* Used for %0c: no other widths are implemented *)\n  let invalid_nonnull_char_width str_ind =\n    invalid_format_message str_ind\n      \"non-zero widths are unsupported for %c conversions\"\n  in\n  (* Raise [Failure] with a friendly error message about an option dependency\n     problem. *)\n  let invalid_format_without str_ind c s =\n    failwith_message\n      \"invalid format %S: at character number %d, '%c' without %s\"\n      str str_ind c s\n  in\n\n  (* Raise [Failure] with a friendly error message about an unexpected\n     character. *)\n  let expected_character str_ind expected read =\n    failwith_message\n     \"invalid format %S: at character number %d, %s expected, read %C\"\n      str str_ind expected read\n  in\n\n  (* Parse the string from beg_ind (included) to end_ind (excluded). *)\n  let rec parse : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun beg_ind end_ind -> parse_literal beg_ind beg_ind end_ind\n\n  (* Read literal characters up to '%' or '@' special characters. *)\n  and parse_literal : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind end_ind ->\n    if str_ind = end_ind then add_literal lit_start str_ind End_of_format else\n      match str.[str_ind] with\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse_format str_ind end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse_after_at (str_ind + 1) end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | _ ->\n        parse_literal lit_start (str_ind + 1) end_ind\n\n  (* Parse a format after '%' *)\n  and parse_format : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind end_ind -> parse_ign pct_ind (pct_ind + 1) end_ind\n\n  and parse_ign : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n      | '_' -> parse_flags pct_ind (str_ind+1) end_ind true\n      | _ -> parse_flags pct_ind str_ind end_ind false\n\n  and parse_flags : type e f . int -> int -> int -> bool -> (_, _, e, f) fmt_ebb\n  =\n  fun pct_ind str_ind end_ind ign ->\n    let zero = ref false and minus = ref false\n    and plus = ref false and space = ref false\n    and hash = ref false in\n    let set_flag str_ind flag =\n      (* in legacy mode, duplicate flags are accepted *)\n      if !flag && not legacy_behavior then\n        failwith_message\n          \"invalid format %S: at character number %d, duplicate flag %C\"\n          str str_ind str.[str_ind];\n      flag := true;\n    in\n    let rec read_flags str_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      begin match str.[str_ind] with\n      | '0' -> set_flag str_ind zero;  read_flags (str_ind + 1)\n      | '-' -> set_flag str_ind minus; read_flags (str_ind + 1)\n      | '+' -> set_flag str_ind plus;  read_flags (str_ind + 1)\n      | '#' -> set_flag str_ind hash; read_flags (str_ind + 1)\n      | ' ' -> set_flag str_ind space; read_flags (str_ind + 1)\n      | _ ->\n        parse_padding pct_ind str_ind end_ind\n          !zero !minus !plus !hash !space ign\n      end\n    in\n    read_flags str_ind\n\n  (* Try to read a digital or a '*' padding. *)\n  and parse_padding : type e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool -> bool ->\n        (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind zero minus plus hash space ign ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let padty = match zero, minus with\n      | false, false -> Right\n      | false, true  -> Left\n      |  true, false -> Zeros\n      |  true, true  ->\n        if legacy_behavior then Left\n        else incompatible_flag pct_ind str_ind '-' \"0\" in\n    match str.[str_ind] with\n    | '0' .. '9' ->\n      let new_ind, width = parse_positive str_ind end_ind 0 in\n      parse_after_padding pct_ind new_ind end_ind minus plus hash space ign\n        (Lit_padding (padty, width))\n    | '*' ->\n      parse_after_padding pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign (Arg_padding padty)\n    | _ ->\n      begin match padty with\n      | Left  ->\n        if not legacy_behavior then\n          invalid_format_without (str_ind - 1) '-' \"padding\";\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      | Zeros ->\n         (* a '0' padding indication not followed by anything should\n           be interpreted as a Right padding of width 0. This is used\n           by scanning conversions %0s and %0c *)\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          (Lit_padding (Right, 0))\n      | Right ->\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      end\n\n  (* Is precision defined? *)\n  and parse_after_padding : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '.' ->\n      parse_precision pct_ind (str_ind + 1) end_ind minus plus hash space ign\n        pad\n    | symb ->\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        No_precision pad symb\n\n  (* Read the digital or '*' precision. *)\n  and parse_precision : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_literal minus str_ind =\n      let new_ind, prec = parse_positive str_ind end_ind 0 in\n      parse_after_precision pct_ind new_ind end_ind minus plus hash space ign\n        pad (Lit_precision prec) in\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_literal minus str_ind\n    | ('+' | '-') as symb when legacy_behavior ->\n      (* Legacy mode would accept and ignore '+' or '-' before the\n         integer describing the desired precision; note that this\n         cannot happen for padding width, as '+' and '-' already have\n         a semantics there.\n\n         That said, the idea (supported by this tweak) that width and\n         precision literals are \"integer literals\" in the OCaml sense is\n         still blatantly wrong, as 123_456 or 0xFF are rejected. *)\n      parse_literal (minus || symb = '-') (str_ind + 1)\n    | '*' ->\n      parse_after_precision pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign pad Arg_precision\n    | _ ->\n      if legacy_behavior then\n        (* note that legacy implementation did not ignore '.' without\n           a number (as it does for padding indications), but\n           interprets it as '.0' *)\n        parse_after_precision pct_ind str_ind end_ind minus plus hash space ign\n          pad (Lit_precision 0)\n      else\n        invalid_format_without (str_ind - 1) '.' \"precision\"\n\n  (* Try to read the conversion. *)\n  and parse_after_precision : type x y z t e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, y) padding -> (z, t) precision -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad prec ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_conv (type u) (type v) (padprec : (u, v) padding) =\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        prec padprec str.[str_ind] in\n    (* in legacy mode, some formats (%s and %S) accept a weird mix of\n       padding and precision, which is merged as a single padding\n       information. For example, in %.10s the precision is implicitly\n       understood as padding %10s, but the left-padding component may\n       be specified either as a left padding or a negative precision:\n       %-.3s and %.-3s are equivalent to %-3s *)\n    match pad with\n    | No_padding -> (\n      match minus, prec with\n        | _, No_precision -> parse_conv No_padding\n        | false, Lit_precision n -> parse_conv (Lit_padding (Right, n))\n        | true, Lit_precision n -> parse_conv (Lit_padding (Left, n))\n        | false, Arg_precision -> parse_conv (Arg_padding Right)\n        | true, Arg_precision -> parse_conv (Arg_padding Left)\n    )\n    | pad -> parse_conv pad\n\n  (* Case analysis on conversion. *)\n  and parse_conversion : type x y z t u v e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> (x, y) padding ->\n        (z, t) precision -> (u, v) padding -> char -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind plus hash space ign pad prec padprec symb ->\n    (* Flags used to check option usages/compatibilities. *)\n    let plus_used  = ref false and hash_used = ref false\n    and space_used = ref false and ign_used   = ref false\n    and pad_used   = ref false and prec_used  = ref false in\n\n    (* Access to options, update flags. *)\n    let get_plus    () = plus_used  := true; plus\n    and get_hash   () = hash_used := true; hash\n    and get_space   () = space_used := true; space\n    and get_ign     () = ign_used   := true; ign\n    and get_pad     () = pad_used   := true; pad\n    and get_prec    () = prec_used  := true; prec\n    and get_padprec () = pad_used   := true; padprec in\n\n    let get_int_pad () : (x,y) padding =\n      (* %5.3d is accepted and meaningful: pad to length 5 with\n         spaces, but first pad with zeros upto length 3 (0-padding\n         is the interpretation of \"precision\" for integer formats).\n\n         %05.3d is redundant: pad to length 5 *with zeros*, but\n         first pad with zeros... To add insult to the injury, the\n         legacy implementation ignores the 0-padding indication and\n         does the 5 padding with spaces instead. We reuse this\n         interpretation for compatibility, but statically reject this\n         format when the legacy mode is disabled, to protect strict\n         users from this corner case. *)\n       match get_pad (), get_prec () with\n         | pad, No_precision -> pad\n         | No_padding, _     -> No_padding\n         | Lit_padding (Zeros, n), _ ->\n           if legacy_behavior then Lit_padding (Right, n)\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Arg_padding Zeros, _ ->\n           if legacy_behavior then Arg_padding Right\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Lit_padding _ as pad, _ -> pad\n         | Arg_padding _ as pad, _ -> pad in\n\n    (* Check that padty <> Zeros. *)\n    let check_no_0 symb (type a b) (pad : (a, b) padding) : (a,b) padding =\n      match pad with\n      | No_padding -> pad\n      | Lit_padding ((Left | Right), _) -> pad\n      | Arg_padding (Left | Right) -> pad\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Lit_padding (Right, width)\n        else incompatible_flag pct_ind str_ind symb \"0\"\n      | Arg_padding Zeros ->\n        if legacy_behavior then Arg_padding Right\n        else incompatible_flag pct_ind str_ind symb \"0\"\n    in\n\n    (* Get padding as a pad_option (see \"%_\", \"%{\", \"%(\" and \"%[\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let opt_of_pad c (type a) (type b) (pad : (a, b) padding) = match pad with\n      | No_padding -> None\n      | Lit_padding (Right, width) -> Some width\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'0'\"\n      | Lit_padding (Left, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'-'\"\n      | Arg_padding _ -> incompatible_flag pct_ind str_ind c \"'*'\"\n    in\n    let get_pad_opt c = opt_of_pad c (get_pad ()) in\n    let get_padprec_opt c = opt_of_pad c (get_padprec ()) in\n\n    (* Get precision as a prec_option (see \"%_f\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let get_prec_opt () = match get_prec () with\n      | No_precision       -> None\n      | Lit_precision ndec -> Some ndec\n      | Arg_precision      -> incompatible_flag pct_ind str_ind '_' \"'*'\"\n    in\n\n    let fmt_result = match symb with\n    | ',' ->\n      parse str_ind end_ind\n    | 'c' ->\n      let char_format fmt_rest = (* %c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_char, fmt_rest))\n        else Fmt_EBB (Char fmt_rest)\n      in\n      let scan_format fmt_rest = (* %0c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_scan_next_char, fmt_rest))\n        else Fmt_EBB (Scan_next_char fmt_rest)\n      in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      begin match get_pad_opt 'c' with\n        | None -> char_format fmt_rest\n        | Some 0 -> scan_format fmt_rest\n        | Some _n ->\n           if not legacy_behavior\n           then invalid_nonnull_char_width str_ind\n           else (* legacy ignores %c widths *) char_format fmt_rest\n      end\n    | 'C' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_caml_char,fmt_rest))\n      else Fmt_EBB (Caml_char fmt_rest)\n    | 's' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (String (pad', fmt_rest'))\n    | 'S' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_caml_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (Caml_string (pad', fmt_rest'))\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' ->\n      let iconv = compute_int_conv pct_ind str_ind (get_plus ()) (get_hash ())\n        (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_int (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int (iconv, pad', prec', fmt_rest'))\n    | 'N' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = Token_counter in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' | 'n' | 'L' when str_ind=end_ind || not (is_int_base str.[str_ind]) ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = counter_of_char symb in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int32 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int32 (iconv, pad', prec', fmt_rest'))\n    | 'n' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ())\n          (get_hash ()) (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_nativeint (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Nativeint (iconv, pad', prec', fmt_rest'))\n    | 'L' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int64 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int64 (iconv, pad', prec', fmt_rest'))\n    | 'f' | 'e' | 'E' | 'g' | 'G' | 'F' | 'h' | 'H' ->\n      let fconv =\n        compute_float_conv pct_ind str_ind\n          (get_plus ()) (get_hash ()) (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_float (get_pad_opt '_', get_prec_opt ()) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Float (fconv, pad', prec', fmt_rest'))\n    | 'b' | 'B' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_bool (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (Bool (pad', fmt_rest'))\n    | 'a' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Alpha fmt_rest)\n    | 't' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Theta fmt_rest)\n    | 'r' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_reader, fmt_rest))\n      else Fmt_EBB (Reader fmt_rest)\n    | '!' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Flush fmt_rest)\n    | ('%' | '@') as c ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Char_literal (c, fmt_rest))\n    | '{' ->\n      let sub_end = search_subformat_end str_ind end_ind '}' in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_arg (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_arg (get_pad_opt '{', sub_fmtty, fmt_rest))\n    | '(' ->\n      let sub_end = search_subformat_end str_ind end_ind ')' in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_subst (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_subst (get_pad_opt '(', sub_fmtty, fmt_rest))\n    | '[' ->\n      let next_ind, char_set = parse_char_set str_ind end_ind in\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_scan_char_set (get_pad_opt '_', char_set) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_char_set (get_pad_opt '[', char_set, fmt_rest))\n    | '-' | '+' | '#' | ' ' | '_' ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         flag %C is only allowed after the '%%', before padding and precision\"\n        str pct_ind symb\n    | _ ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         invalid conversion \\\"%%%c\\\"\" str (str_ind - 1) symb\n    in\n    (* Check for unused options, and reject them as incompatible.\n\n       Such checks need to be disabled in legacy mode, as the legacy\n       parser silently ignored incompatible flags. *)\n    if not legacy_behavior then begin\n    if not !plus_used && plus then\n      incompatible_flag pct_ind str_ind symb \"'+'\";\n    if not !hash_used && hash then\n      incompatible_flag pct_ind str_ind symb \"'#'\";\n    if not !space_used && space then\n      incompatible_flag pct_ind str_ind symb \"' '\";\n    if not !pad_used  && Padding_EBB pad <> Padding_EBB No_padding then\n      incompatible_flag pct_ind str_ind symb \"`padding'\";\n    if not !prec_used && Precision_EBB prec <> Precision_EBB No_precision then\n      incompatible_flag pct_ind str_ind (if ign then '_' else symb)\n        \"`precision'\";\n    if ign && plus then incompatible_flag pct_ind str_ind '_' \"'+'\";\n    end;\n    (* this last test must not be disabled in legacy mode,\n       as ignoring it would typically result in a different typing\n       than what the legacy parser used *)\n    if not !ign_used && ign then\n      begin match symb with\n        (* argument-less formats can safely be ignored in legacy mode *)\n        | ('@' | '%' | '!' | ',') when legacy_behavior -> ()\n        | _ ->\n          incompatible_flag pct_ind str_ind symb \"'_'\"\n      end;\n    fmt_result\n\n  (* Parse formatting information (after '@'). *)\n  and parse_after_at : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    if str_ind = end_ind then Fmt_EBB (Char_literal ('@', End_of_format))\n    else\n      match str.[str_ind] with\n      | '[' ->\n        parse_tag false (str_ind + 1) end_ind\n      | ']' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_box, fmt_rest))\n      | '{' ->\n        parse_tag true (str_ind + 1) end_ind\n      | '}' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_tag, fmt_rest))\n      | ',' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@,\", 0, 0), fmt_rest))\n      | ' ' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@ \", 1, 0), fmt_rest))\n      | ';' ->\n        parse_good_break (str_ind + 1) end_ind\n      | '?' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (FFlush, fmt_rest))\n      | '\\n' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Force_newline, fmt_rest))\n      | '.' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Flush_newline, fmt_rest))\n      | '<' ->\n        parse_magic_size (str_ind + 1) end_ind\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_at, fmt_rest))\n      | '%' when str_ind + 1 < end_ind && str.[str_ind + 1] = '%' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 2) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_percent, fmt_rest))\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse str_ind end_ind in\n        Fmt_EBB (Char_literal ('@', fmt_rest))\n      | c ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Scan_indic c, fmt_rest))\n\n  (* Try to read the optional <name> after \"@{\" or \"@[\". *)\n  and parse_tag : type e f . bool -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun is_open_tag str_ind end_ind ->\n    try\n      if str_ind = end_ind then raise Not_found;\n      match str.[str_ind] with\n      | '<' ->\n        let ind = String.index_from str (str_ind + 1) '>' in\n        if ind >= end_ind then raise Not_found;\n        let sub_str = String.sub str str_ind (ind - str_ind + 1) in\n        let Fmt_EBB fmt_rest = parse (ind + 1) end_ind in\n        let Fmt_EBB sub_fmt = parse str_ind (ind + 1) in\n        let sub_format = Format (sub_fmt, sub_str) in\n        let formatting =\n          if is_open_tag then Open_tag sub_format else Open_box sub_format in\n        Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n      | _ ->\n        raise Not_found\n    with Not_found ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let sub_format = Format (End_of_format, \"\") in\n      let formatting =\n        if is_open_tag then Open_tag sub_format else Open_box sub_format in\n      Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n\n  (* Try to read the optional <width offset> after \"@;\". *)\n  and parse_good_break : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    let next_ind, formatting_lit =\n      try\n        if str_ind = end_ind || str.[str_ind] <> '<' then raise Not_found;\n        let str_ind_1 = parse_spaces (str_ind + 1) end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' -> (\n          let str_ind_2, width = parse_integer str_ind_1 end_ind in\n            let str_ind_3 = parse_spaces str_ind_2 end_ind in\n            match str.[str_ind_3] with\n              | '>' ->\n                let s = String.sub str (str_ind-2) (str_ind_3-str_ind+3) in\n                str_ind_3 + 1, Break (s, width, 0)\n              | '0' .. '9' | '-' ->\n                let str_ind_4, offset = parse_integer str_ind_3 end_ind in\n                let str_ind_5 = parse_spaces str_ind_4 end_ind in\n                if str.[str_ind_5] <> '>' then raise Not_found;\n                let s = String.sub str (str_ind-2) (str_ind_5-str_ind+3) in\n                str_ind_5 + 1, Break (s, width, offset)\n              | _ -> raise Not_found\n        )\n        | _ -> raise Not_found\n      with Not_found | Failure _ ->\n        str_ind, Break (\"@;\", 1, 0)\n    in\n    let Fmt_EBB fmt_rest = parse next_ind end_ind in\n    Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n\n  (* Parse the size in a <n>. *)\n  and parse_magic_size : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    match\n      try\n        let str_ind_1 = parse_spaces str_ind end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' ->\n          let str_ind_2, size = parse_integer str_ind_1 end_ind in\n          let str_ind_3 = parse_spaces str_ind_2 end_ind in\n          if str.[str_ind_3] <> '>' then raise Not_found;\n          let s = String.sub str (str_ind - 2) (str_ind_3 - str_ind + 3) in\n          Some (str_ind_3 + 1, Magic_size (s, size))\n        | _ -> None\n      with Not_found | Failure _ ->\n        None\n    with\n    | Some (next_ind, formatting_lit) ->\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n    | None ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Formatting_lit (Scan_indic '<', fmt_rest))\n\n  (* Parse and construct a char set. *)\n  and parse_char_set str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n\n    let char_set = create_char_set () in\n    let add_char c =\n      add_in_char_set char_set c;\n    in\n    let add_range c c' =\n      for i = int_of_char c to int_of_char c' do\n        add_in_char_set char_set (char_of_int i);\n      done;\n    in\n\n    let fail_single_percent str_ind =\n      failwith_message\n        \"invalid format %S: '%%' alone is not accepted in character sets, \\\n         use %%%% instead at position %d.\" str str_ind\n    in\n\n    (* Parse the first character of a char set. *)\n    let rec parse_char_set_start str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      let c = str.[str_ind] in\n      parse_char_set_after_char (str_ind + 1) end_ind c\n\n    (* Parse the content of a char set until the first ']'. *)\n    and parse_char_set_content str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        str_ind + 1\n      | '-' ->\n        add_char '-';\n        parse_char_set_content (str_ind + 1) end_ind\n      | c ->\n        parse_char_set_after_char (str_ind + 1) end_ind c\n\n    (* Test for range in char set. *)\n    and parse_char_set_after_char str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        str_ind + 1\n      | '-' ->\n        parse_char_set_after_minus (str_ind + 1) end_ind c\n      | ('%' | '@') as c' when c = '%' ->\n        add_char c';\n        parse_char_set_content (str_ind + 1) end_ind\n      | c' ->\n        if c = '%' then fail_single_percent str_ind;\n        (* note that '@' alone is accepted, as done by the legacy\n           implementation; the documentation specifically requires %@\n           so we could warn on that *)\n        add_char c;\n        parse_char_set_after_char (str_ind + 1) end_ind c'\n\n    (* Manage range in char set (except if the '-' the last char before ']') *)\n    and parse_char_set_after_minus str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        add_char '-';\n        str_ind + 1\n      | '%' ->\n        if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n        begin match str.[str_ind + 1] with\n          | ('%' | '@') as c' ->\n            add_range c c';\n            parse_char_set_content (str_ind + 2) end_ind\n          | _ -> fail_single_percent str_ind\n        end\n      | c' ->\n        add_range c c';\n        parse_char_set_content (str_ind + 1) end_ind\n    in\n    let str_ind, reverse =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n        | '^' -> str_ind + 1, true\n        | _ -> str_ind, false in\n    let next_ind = parse_char_set_start str_ind end_ind in\n    let char_set = freeze_char_set char_set in\n    next_ind, (if reverse then rev_char_set char_set else char_set)\n\n  (* Consume all next spaces, raise an Failure if end_ind is reached. *)\n  and parse_spaces str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    if str.[str_ind] = ' ' then parse_spaces (str_ind + 1) end_ind else str_ind\n\n  (* Read a positive integer from the string, raise a Failure if end_ind is\n     reached. *)\n  and parse_positive str_ind end_ind acc =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' as c ->\n      let new_acc = acc * 10 + (int_of_char c - int_of_char '0') in\n      if new_acc > Sys.max_string_length then\n        failwith_message\n          \"invalid format %S: integer %d is greater than the limit %d\"\n          str new_acc Sys.max_string_length\n      else\n        parse_positive (str_ind + 1) end_ind new_acc\n    | _ -> str_ind, acc\n\n  (* Read a positive or negative integer from the string, raise a Failure\n     if end_ind is reached. *)\n  and parse_integer str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_positive str_ind end_ind 0\n    | '-' -> (\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind + 1] with\n      | '0' .. '9' ->\n        let next_ind, n = parse_positive (str_ind + 1) end_ind 0 in\n        next_ind, -n\n      | c ->\n        expected_character (str_ind + 1) \"digit\" c\n    )\n    | _ -> assert false\n\n  (* Add a literal to a format from a literal character sub-sequence. *)\n  and add_literal : type a d e f .\n      int -> int -> (a, _, _, d, e, f) fmt ->\n      (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind fmt -> match str_ind - lit_start with\n    | 0    -> Fmt_EBB fmt\n    | 1    -> Fmt_EBB (Char_literal (str.[lit_start], fmt))\n    | size -> Fmt_EBB (String_literal (String.sub str lit_start size, fmt))\n\n  (* Search the end of the current sub-format\n     (i.e. the corresponding \"%}\" or \"%)\") *)\n  and search_subformat_end str_ind end_ind c =\n    if str_ind = end_ind then\n      failwith_message\n        \"invalid format %S: unclosed sub-format, \\\n         expected \\\"%%%c\\\" at character number %d\" str c end_ind;\n    match str.[str_ind] with\n    | '%' ->\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      if str.[str_ind + 1] = c then (* End of format found *) str_ind else\n        begin match str.[str_ind + 1] with\n        | '_' ->\n          (* Search for \"%_(\" or \"%_{\". *)\n          if str_ind + 2 = end_ind then unexpected_end_of_format end_ind;\n          begin match str.[str_ind + 2] with\n          | '{' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind '}' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | '(' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind ')' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | _ -> search_subformat_end (str_ind + 3) end_ind c\n          end\n        | '{' ->\n          (* %{...%} sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind '}' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '(' ->\n          (* %(...%) sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind ')' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '}' ->\n          (* Error: %(...%}. *)\n          expected_character (str_ind + 1) \"character ')'\" '}'\n        | ')' ->\n          (* Error: %{...%). *)\n          expected_character (str_ind + 1) \"character '}'\" ')'\n        | _ ->\n          search_subformat_end (str_ind + 2) end_ind c\n        end\n    | _ -> search_subformat_end (str_ind + 1) end_ind c\n\n  (* Check if symb is a valid int conversion after \"%l\", \"%n\" or \"%L\" *)\n  and is_int_base symb = match symb with\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' -> true\n    | _ -> false\n\n  (* Convert a char (l, n or L) to its associated counter. *)\n  and counter_of_char symb = match symb with\n    | 'l' -> Line_counter  | 'n' -> Char_counter\n    | 'L' -> Token_counter | _ -> assert false\n\n  (* Convert (plus, symb) to its associated int_conv. *)\n  and compute_int_conv pct_ind str_ind plus hash space symb =\n    match plus, hash, space, symb with\n    | false, false, false, 'd' -> Int_d  | false, false, false, 'i' -> Int_i\n    | false, false,  true, 'd' -> Int_sd | false, false,  true, 'i' -> Int_si\n    |  true, false, false, 'd' -> Int_pd |  true, false, false, 'i' -> Int_pi\n    | false, false, false, 'x' -> Int_x  | false, false, false, 'X' -> Int_X\n    | false,  true, false, 'x' -> Int_Cx | false,  true, false, 'X' -> Int_CX\n    | false, false, false, 'o' -> Int_o\n    | false,  true, false, 'o' -> Int_Co\n    | false, false, false, 'u' -> Int_u\n    | false,  true, false, 'd' -> Int_Cd\n    | false,  true, false, 'i' -> Int_Ci\n    | false,  true, false, 'u' -> Int_Cu\n    | _, true, _, 'x' when legacy_behavior -> Int_Cx\n    | _, true, _, 'X' when legacy_behavior -> Int_CX\n    | _, true, _, 'o' when legacy_behavior -> Int_Co\n    | _, true, _, ('d' | 'i' | 'u') ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus false space symb\n      else incompatible_flag pct_ind str_ind symb \"'#'\"\n    | true, _, true, _ ->\n      if legacy_behavior then\n        (* plus and space: legacy implementation prefers plus *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\"\n    | false, _, true, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind symb \"' '\"\n    | true, _, false, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind false hash space symb\n      else incompatible_flag pct_ind str_ind symb \"'+'\"\n    | false, _, false, _ -> assert false\n\n  (* Convert (plus, space, symb) to its associated float_conv. *)\n  and compute_float_conv pct_ind str_ind plus hash space symb =\n    let flag = match plus, space with\n    | false, false -> Float_flag_\n    | false,  true -> Float_flag_s\n    |  true, false -> Float_flag_p\n    |  true,  true ->\n      (* plus and space: legacy implementation prefers plus *)\n      if legacy_behavior then Float_flag_p\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\" in\n    let kind = match hash, symb with\n    | _, 'f' -> Float_f\n    | _, 'e' -> Float_e\n    | _, 'E' -> Float_E\n    | _, 'g' -> Float_g\n    | _, 'G' -> Float_G\n    | _, 'h' -> Float_h\n    | _, 'H' -> Float_H\n    | false, 'F' -> Float_F\n    | true, 'F' -> Float_CF\n    | _ -> assert false in\n    flag, kind\n\n  (* Raise [Failure] with a friendly error message about incompatible options.*)\n  and incompatible_flag : type a . int -> int -> char -> string -> a =\n    fun pct_ind str_ind symb option ->\n      let subfmt = String.sub str pct_ind (str_ind - pct_ind) in\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         %s is incompatible with '%c' in sub-format %S\"\n        str pct_ind option symb subfmt\n\n  in parse 0 (String.length str)\n\n(******************************************************************************)\n                  (* Guarded string to format conversions *)\n\n(* Convert a string to a format according to an fmtty. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet format_of_string_fmtty str fmtty =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt fmtty, str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\"\n      str (string_of_fmtty fmtty)\n\n(* Convert a string to a format compatible with an other format. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet format_of_string_format str (Format (fmt', str')) =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt (fmtty_of_fmt fmt'), str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\" str str'\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Hash tables *)\n\n(* We do dynamic hashing, and resize the table and rehash the elements\n   when buckets become too long. *)\n\ntype ('a, 'b) t =\n  { mutable size: int;                        (* number of entries *)\n    mutable data: ('a, 'b) bucketlist array;  (* the buckets *)\n    seed: int;                        (* for randomization *)\n    mutable initial_size: int;                (* initial array size *)\n  }\n\nand ('a, 'b) bucketlist =\n    Empty\n  | Cons of { mutable key: 'a;\n              mutable data: 'b;\n              mutable next: ('a, 'b) bucketlist }\n\n(* The sign of initial_size encodes the fact that a traversal is\n   ongoing or not.\n\n   This disables the efficient in place implementation of resizing.\n*)\n\nlet ongoing_traversal h =\n  Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n  || h.initial_size < 0\n\nlet flip_ongoing_traversal h =\n  h.initial_size <- - h.initial_size\n\n(* To pick random seeds if requested *)\n\nlet randomized_default =\n  let params =\n    try Sys.getenv \"OCAMLRUNPARAM\" with Not_found ->\n    try Sys.getenv \"CAMLRUNPARAM\" with Not_found -> \"\" in\n  String.contains params 'R'\n\nlet randomized = ref randomized_default\n\nlet randomize () = randomized := true\nlet is_randomized () = !randomized\n\nlet prng = lazy (Random.State.make_self_init())\n\n(* Functions which appear before the functorial interface must either be\n   independent of the hash function or take it as a parameter (see #2202 and\n   code below the functor definitions. *)\n\n(* Creating a fresh, empty table *)\n\nlet rec power_2_above x n =\n  if x >= n then x\n  else if x * 2 > Sys.max_array_length then x\n  else power_2_above (x * 2) n\n\nlet create ?(random = !randomized) initial_size =\n  let s = power_2_above 16 initial_size in\n  let seed = if random then Random.State.bits (Lazy.force prng) else 0 in\n  { initial_size = s; size = 0; seed = seed; data = Array.make s Empty }\n\nlet clear h =\n  if h.size > 0 then begin\n    h.size <- 0;\n    Array.fill h.data 0 (Array.length h.data) Empty\n  end\n\nlet reset h =\n  let len = Array.length h.data in\n  if Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n    || len = abs h.initial_size then\n    clear h\n  else begin\n    h.size <- 0;\n    h.data <- Array.make (abs h.initial_size) Empty\n  end\n\nlet copy_bucketlist = function\n  | Empty -> Empty\n  | Cons {key; data; next} ->\n      let rec loop prec = function\n        | Empty -> ()\n        | Cons {key; data; next} ->\n            let r = Cons {key; data; next} in\n            begin match prec with\n            | Empty -> assert false\n            | Cons prec ->  prec.next <- r\n            end;\n            loop r next\n      in\n      let r = Cons {key; data; next} in\n      loop r next;\n      r\n\nlet copy h = { h with data = Array.map copy_bucketlist h.data }\n\nlet length h = h.size\n\nlet insert_all_buckets indexfun inplace odata ndata =\n  let nsize = Array.length ndata in\n  let ndata_tail = Array.make nsize Empty in\n  let rec insert_bucket = function\n    | Empty -> ()\n    | Cons {key; data; next} as cell ->\n        let cell =\n          if inplace then cell\n          else Cons {key; data; next = Empty}\n        in\n        let nidx = indexfun key in\n        begin match ndata_tail.(nidx) with\n        | Empty -> ndata.(nidx) <- cell;\n        | Cons tail -> tail.next <- cell;\n        end;\n        ndata_tail.(nidx) <- cell;\n        insert_bucket next\n  in\n  for i = 0 to Array.length odata - 1 do\n    insert_bucket odata.(i)\n  done;\n  if inplace then\n    for i = 0 to nsize - 1 do\n      match ndata_tail.(i) with\n      | Empty -> ()\n      | Cons tail -> tail.next <- Empty\n    done\n\nlet resize indexfun h =\n  let odata = h.data in\n  let osize = Array.length odata in\n  let nsize = osize * 2 in\n  if nsize < Sys.max_array_length then begin\n    let ndata = Array.make nsize Empty in\n    let inplace = not (ongoing_traversal h) in\n    h.data <- ndata;          (* so that indexfun sees the new bucket count *)\n    insert_all_buckets (indexfun h) inplace odata ndata\n  end\n\nlet iter f h =\n  let rec do_bucket = function\n    | Empty ->\n        ()\n    | Cons{key; data; next} ->\n        f key data; do_bucket next in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    for i = 0 to Array.length d - 1 do\n      do_bucket d.(i)\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet rec filter_map_inplace_bucket f h i prec = function\n  | Empty ->\n      begin match prec with\n      | Empty -> h.data.(i) <- Empty\n      | Cons c -> c.next <- Empty\n      end\n  | (Cons ({key; data; next} as c)) as slot ->\n      begin match f key data with\n      | None ->\n          h.size <- h.size - 1;\n          filter_map_inplace_bucket f h i prec next\n      | Some data ->\n          begin match prec with\n          | Empty -> h.data.(i) <- slot\n          | Cons c -> c.next <- slot\n          end;\n          c.data <- data;\n          filter_map_inplace_bucket f h i slot next\n      end\n\nlet filter_map_inplace f h =\n  let d = h.data in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    for i = 0 to Array.length d - 1 do\n      filter_map_inplace_bucket f h i Empty h.data.(i)\n    done;\n    if not old_trav then flip_ongoing_traversal h\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet fold f h init =\n  let rec do_bucket b accu =\n    match b with\n      Empty ->\n        accu\n    | Cons{key; data; next} ->\n        do_bucket next (f key data accu) in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    let accu = ref init in\n    for i = 0 to Array.length d - 1 do\n      accu := do_bucket d.(i) !accu\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n    !accu\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\ntype statistics = {\n  num_bindings: int;\n  num_buckets: int;\n  max_bucket_length: int;\n  bucket_histogram: int array\n}\n\nlet rec bucket_length accu = function\n  | Empty -> accu\n  | Cons{next} -> bucket_length (accu + 1) next\n\nlet stats h =\n  let mbl =\n    Array.fold_left (fun m b -> Int.max m (bucket_length 0 b)) 0 h.data in\n  let histo = Array.make (mbl + 1) 0 in\n  Array.iter\n    (fun b ->\n      let l = bucket_length 0 b in\n      histo.(l) <- histo.(l) + 1)\n    h.data;\n  { num_bindings = h.size;\n    num_buckets = Array.length h.data;\n    max_bucket_length = mbl;\n    bucket_histogram = histo }\n\n(** {1 Iterators} *)\n\nlet to_seq tbl =\n  (* capture current array, so that even if the table is resized we\n     keep iterating on the same array *)\n  let tbl_data = tbl.data in\n  (* state: index * next bucket to traverse *)\n  let rec aux i buck () = match buck with\n    | Empty ->\n        if i = Array.length tbl_data\n        then Seq.Nil\n        else aux(i+1) tbl_data.(i) ()\n    | Cons {key; data; next} ->\n        Seq.Cons ((key, data), aux i next)\n  in\n  aux 0 Empty\n\nlet to_seq_keys m = Seq.map fst (to_seq m)\n\nlet to_seq_values m = Seq.map snd (to_seq m)\n\n(* Functorial interface *)\n\nmodule type HashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: t -> int\n  end\n\nmodule type SeededHashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: int -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type !'a t\n    val create: int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy: 'a t -> 'a t\n    val add: 'a t -> key -> 'a -> unit\n    val remove: 'a t -> key -> unit\n    val find: 'a t -> key -> 'a\n    val find_opt: 'a t -> key -> 'a option\n    val find_all: 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length: 'a t -> int\n    val stats: 'a t -> statistics\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_keys : _ t -> key Seq.t\n    val to_seq_values : 'a t -> 'a Seq.t\n    val add_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val replace_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule type SeededS =\n  sig\n    type key\n    type !'a t\n    val create : ?random:bool -> int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy : 'a t -> 'a t\n    val add : 'a t -> key -> 'a -> unit\n    val remove : 'a t -> key -> unit\n    val find : 'a t -> key -> 'a\n    val find_opt: 'a t -> key -> 'a option\n    val find_all : 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter : (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length : 'a t -> int\n    val stats: 'a t -> statistics\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_keys : _ t -> key Seq.t\n    val to_seq_values : 'a t -> 'a Seq.t\n    val add_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val replace_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule MakeSeeded(H: SeededHashedType): (SeededS with type key = H.t) =\n  struct\n    type key = H.t\n    type 'a hashtbl = (key, 'a) t\n    type 'a t = 'a hashtbl\n    let create = create\n    let clear = clear\n    let reset = reset\n    let copy = copy\n\n    let key_index h key =\n      (H.hash h.seed key) land (Array.length h.data - 1)\n\n    let add h key data =\n      let i = key_index h key in\n      let bucket = Cons{key; data; next=h.data.(i)} in\n      h.data.(i) <- bucket;\n      h.size <- h.size + 1;\n      if h.size > Array.length h.data lsl 1 then resize key_index h\n\n    let rec remove_bucket h i key prec = function\n      | Empty ->\n          ()\n      | (Cons {key=k; next}) as c ->\n          if H.equal k key\n          then begin\n            h.size <- h.size - 1;\n            match prec with\n            | Empty -> h.data.(i) <- next\n            | Cons c -> c.next <- next\n          end\n          else remove_bucket h i key c next\n\n    let remove h key =\n      let i = key_index h key in\n      remove_bucket h i key Empty h.data.(i)\n\n    let rec find_rec key = function\n      | Empty ->\n          raise Not_found\n      | Cons{key=k; data; next} ->\n          if H.equal key k then data else find_rec key next\n\n    let find h key =\n      match h.data.(key_index h key) with\n      | Empty -> raise Not_found\n      | Cons{key=k1; data=d1; next=next1} ->\n          if H.equal key k1 then d1 else\n          match next1 with\n          | Empty -> raise Not_found\n          | Cons{key=k2; data=d2; next=next2} ->\n              if H.equal key k2 then d2 else\n              match next2 with\n              | Empty -> raise Not_found\n              | Cons{key=k3; data=d3; next=next3} ->\n                  if H.equal key k3 then d3 else find_rec key next3\n\n    let rec find_rec_opt key = function\n      | Empty ->\n          None\n      | Cons{key=k; data; next} ->\n          if H.equal key k then Some data else find_rec_opt key next\n\n    let find_opt h key =\n      match h.data.(key_index h key) with\n      | Empty -> None\n      | Cons{key=k1; data=d1; next=next1} ->\n          if H.equal key k1 then Some d1 else\n          match next1 with\n          | Empty -> None\n          | Cons{key=k2; data=d2; next=next2} ->\n              if H.equal key k2 then Some d2 else\n              match next2 with\n              | Empty -> None\n              | Cons{key=k3; data=d3; next=next3} ->\n                  if H.equal key k3 then Some d3 else find_rec_opt key next3\n\n    let find_all h key =\n      let rec find_in_bucket = function\n      | Empty ->\n          []\n      | Cons{key=k; data=d; next} ->\n          if H.equal k key\n          then d :: find_in_bucket next\n          else find_in_bucket next in\n      find_in_bucket h.data.(key_index h key)\n\n    let rec replace_bucket key data = function\n      | Empty ->\n          true\n      | Cons ({key=k; next} as slot) ->\n          if H.equal k key\n          then (slot.key <- key; slot.data <- data; false)\n          else replace_bucket key data next\n\n    let replace h key data =\n      let i = key_index h key in\n      let l = h.data.(i) in\n      if replace_bucket key data l then begin\n        h.data.(i) <- Cons{key; data; next=l};\n        h.size <- h.size + 1;\n        if h.size > Array.length h.data lsl 1 then resize key_index h\n      end\n\n    let mem h key =\n      let rec mem_in_bucket = function\n      | Empty ->\n          false\n      | Cons{key=k; next} ->\n          H.equal k key || mem_in_bucket next in\n      mem_in_bucket h.data.(key_index h key)\n\n    let add_seq tbl i =\n      Seq.iter (fun (k,v) -> add tbl k v) i\n\n    let replace_seq tbl i =\n      Seq.iter (fun (k,v) -> replace tbl k v) i\n\n    let of_seq i =\n      let tbl = create 16 in\n      replace_seq tbl i;\n      tbl\n\n    let iter = iter\n    let filter_map_inplace = filter_map_inplace\n    let fold = fold\n    let length = length\n    let stats = stats\n    let to_seq = to_seq\n    let to_seq_keys = to_seq_keys\n    let to_seq_values = to_seq_values\n  end\n\nmodule Make(H: HashedType): (S with type key = H.t) =\n  struct\n    include MakeSeeded(struct\n        type t = H.t\n        let equal = H.equal\n        let hash (_seed: int) x = H.hash x\n      end)\n    let create sz = create ~random:false sz\n    let of_seq i =\n      let tbl = create 16 in\n      replace_seq tbl i;\n      tbl\n  end\n\n(* Polymorphic hash function-based tables *)\n(* Code included below the functorial interface to guard against accidental\n   use - see #2202 *)\n\nexternal seeded_hash_param :\n  int -> int -> int -> 'a -> int = \"caml_hash\" [@@noalloc]\n\nlet hash x = seeded_hash_param 10 100 0 x\nlet hash_param n1 n2 x = seeded_hash_param n1 n2 0 x\nlet seeded_hash seed x = seeded_hash_param 10 100 seed x\n\nlet key_index h key =\n  if Obj.size (Obj.repr h) >= 4\n  then (seeded_hash_param 10 100 h.seed key) land (Array.length h.data - 1)\n  else invalid_arg \"Hashtbl: unsupported hash table format\"\n\nlet add h key data =\n  let i = key_index h key in\n  let bucket = Cons{key; data; next=h.data.(i)} in\n  h.data.(i) <- bucket;\n  h.size <- h.size + 1;\n  if h.size > Array.length h.data lsl 1 then resize key_index h\n\nlet rec remove_bucket h i key prec = function\n  | Empty ->\n      ()\n  | (Cons {key=k; next}) as c ->\n      if compare k key = 0\n      then begin\n        h.size <- h.size - 1;\n        match prec with\n        | Empty -> h.data.(i) <- next\n        | Cons c -> c.next <- next\n      end\n      else remove_bucket h i key c next\n\nlet remove h key =\n  let i = key_index h key in\n  remove_bucket h i key Empty h.data.(i)\n\nlet rec find_rec key = function\n  | Empty ->\n      raise Not_found\n  | Cons{key=k; data; next} ->\n      if compare key k = 0 then data else find_rec key next\n\nlet find h key =\n  match h.data.(key_index h key) with\n  | Empty -> raise Not_found\n  | Cons{key=k1; data=d1; next=next1} ->\n      if compare key k1 = 0 then d1 else\n      match next1 with\n      | Empty -> raise Not_found\n      | Cons{key=k2; data=d2; next=next2} ->\n          if compare key k2 = 0 then d2 else\n          match next2 with\n          | Empty -> raise Not_found\n          | Cons{key=k3; data=d3; next=next3} ->\n              if compare key k3 = 0 then d3 else find_rec key next3\n\nlet rec find_rec_opt key = function\n  | Empty ->\n      None\n  | Cons{key=k; data; next} ->\n      if compare key k = 0 then Some data else find_rec_opt key next\n\nlet find_opt h key =\n  match h.data.(key_index h key) with\n  | Empty -> None\n  | Cons{key=k1; data=d1; next=next1} ->\n      if compare key k1 = 0 then Some d1 else\n      match next1 with\n      | Empty -> None\n      | Cons{key=k2; data=d2; next=next2} ->\n          if compare key k2 = 0 then Some d2 else\n          match next2 with\n          | Empty -> None\n          | Cons{key=k3; data=d3; next=next3} ->\n              if compare key k3 = 0 then Some d3 else find_rec_opt key next3\n\nlet find_all h key =\n  let rec find_in_bucket = function\n  | Empty ->\n      []\n  | Cons{key=k; data; next} ->\n      if compare k key = 0\n      then data :: find_in_bucket next\n      else find_in_bucket next in\n  find_in_bucket h.data.(key_index h key)\n\nlet rec replace_bucket key data = function\n  | Empty ->\n      true\n  | Cons ({key=k; next} as slot) ->\n      if compare k key = 0\n      then (slot.key <- key; slot.data <- data; false)\n      else replace_bucket key data next\n\nlet replace h key data =\n  let i = key_index h key in\n  let l = h.data.(i) in\n  if replace_bucket key data l then begin\n    h.data.(i) <- Cons{key; data; next=l};\n    h.size <- h.size + 1;\n    if h.size > Array.length h.data lsl 1 then resize key_index h\n  end\n\nlet mem h key =\n  let rec mem_in_bucket = function\n  | Empty ->\n      false\n  | Cons{key=k; next} ->\n      compare k key = 0 || mem_in_bucket next in\n  mem_in_bucket h.data.(key_index h key)\n\nlet add_seq tbl i =\n  Seq.iter (fun (k,v) -> add tbl k v) i\n\nlet replace_seq tbl i =\n  Seq.iter (fun (k,v) -> replace tbl k v) i\n\nlet of_seq i =\n  let tbl = create 16 in\n  replace_seq tbl i;\n  tbl\n\nlet rebuild ?(random = !randomized) h =\n  let s = power_2_above 16 (Array.length h.data) in\n  let seed =\n    if random then Random.State.bits (Lazy.force prng)\n    else if Obj.size (Obj.repr h) >= 4 then h.seed\n    else 0 in\n  let h' = {\n    size = h.size;\n    data = Array.make s Empty;\n    seed = seed;\n    initial_size = if Obj.size (Obj.repr h) >= 4 then h.initial_size else s\n  } in\n  insert_all_buckets (key_index h') false h.data h'.data;\n  h'\n","(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *         Copyright INRIA, CNRS and contributors             *)\n(* <O___,, * (see version control and CREDITS file for authors & dates) *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\ntype t = Int64.t\n\nlet _ = assert (Sys.word_size = 32)\n\nlet uint_size = 63\n\nlet maxuint63 = 0x7FFF_FFFF_FFFF_FFFFL\nlet maxuint31 = 0x7FFF_FFFFL\n\nlet zero = Int64.zero\nlet one = Int64.one\n\n    (* conversion from an int *)\nlet mask63 i = Int64.logand i maxuint63\nlet of_int i = mask63 (Int64.of_int i)\nlet to_int2 i = (Int64.to_int (Int64.shift_right_logical i 31), Int64.to_int i)\nlet of_int64 = mask63\nlet to_int64 i = i\n\nlet to_int_min n m =\n  if Int64.(compare n (of_int m)) < 0 then Int64.to_int n else m\n\nlet of_float f = mask63 (Int64.of_float f)\nlet to_float = Int64.to_float\n\nlet hash i =\n  let (h,l) = to_int2 i in\n  (*Hashset.combine h l*)\n  h * 65599 + l\n\n    (* conversion of an uint63 to a string *)\nlet to_string i = Int64.to_string i\n\n(* Compiles an unsigned int to OCaml code *)\nlet compile i = Printf.sprintf \"Uint63.of_int64 (%LiL)\" i\n\n    (* comparison *)\nlet lt x y =\n  Int64.compare x y < 0\n\nlet le x y =\n  Int64.compare x y <= 0\n\n    (* signed comparison *)\n(* We shift the arguments by 1 to the left so that the top-most bit is interpreted as a sign *)\n(* The zero at the end doesn't change the order (it is stable by multiplication by 2) *)\nlet lts x y =\n  Int64.(compare (shift_left x 1) (shift_left y 1)) < 0\n\nlet les x y =\n  Int64.(compare (shift_left x 1) (shift_left y 1)) <= 0\n\n    (* logical shift *)\nlet l_sl x y =\n  if le 0L y && lt y 63L then mask63 (Int64.shift_left x (Int64.to_int y)) else 0L\n\nlet l_sr x y =\n  if le 0L y && lt y 63L then Int64.shift_right x (Int64.to_int y) else 0L\n\n    (* arithmetic shift (for sint63) *)\nlet a_sr x y =\n  if les 0L y && lts y 63L then\n    mask63 (Int64.shift_right (Int64.shift_left x 1) ((Int64.to_int y) + 1))\n  else 0L\n\nlet l_and x y = Int64.logand x y\nlet l_or x y = Int64.logor x y\nlet l_xor x y = Int64.logxor x y\n\n    (* addition of int63 *)\nlet add x y = mask63 (Int64.add x y)\n\nlet addcarry x y = mask63 Int64.(add (add x y) one)\n\n    (* subtraction *)\nlet sub x y = mask63 (Int64.sub x y)\n\nlet subcarry x y = mask63 Int64.(sub (sub x y) one)\n\n    (* multiplication *)\nlet mul x y = mask63 (Int64.mul x y)\n\n    (* division *)\nlet div x y =\n  if y = 0L then 0L else Int64.div x y\n\n    (* modulo *)\nlet rem x y =\n  if y = 0L then x else Int64.rem x y\n\nlet diveucl x y = (div x y, rem x y)\n\n    (* signed division *)\nlet divs x y =\n  if y = 0L then 0L else mask63 Int64.(div (shift_left x 1) (shift_left y 1))\n\n    (* signed modulo *)\nlet rems x y =\n  if y = 0L then x else\n    Int64.shift_right_logical (Int64.(rem (shift_left x 1) (shift_left y 1))) 1\n\nlet addmuldiv p x y =\n  l_or (l_sl x p) (l_sr y Int64.(sub (of_int uint_size) p))\n\n    (* division of two numbers by one *)\n(* precondition: xh < y *)\n(* outputs: q, r s.t. x = q * y + r, r < y *)\nlet div21 xh xl y =\n  let nh = ref xh in\n  let nl = ref xl in\n  let q = ref 0L in\n  for _i = 0 to 62 do\n    (* invariants: 0 <= nh < y, nl = (xl*2^i) % 2^64,\n       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)\n    nl := Int64.shift_left !nl 1;\n    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.shift_right_logical !nl 63);\n    q := Int64.shift_left !q 1;\n    if Int64.unsigned_compare !nh y >= 0 then\n      begin q := Int64.logor !q 1L; nh := Int64.sub !nh y; end\n  done;\n  !q, !nh\n\nlet div21 xh xl y =\n  if Int64.compare y xh <= 0 then zero, zero else div21 xh xl y\n\n(* exact multiplication *)\nlet mulc x y =\n  let lx = Int64.logand x maxuint31 in\n  let ly = Int64.logand y maxuint31 in\n  let hx = Int64.shift_right x 31 in\n  let hy = Int64.shift_right y 31 in\n  (* compute the median products *)\n  let s = Int64.add (Int64.mul lx hy) (Int64.mul hx ly) in\n  (* s fits on 64 bits, split it into a 33-bit high part and a 31-bit low part *)\n  let lr = Int64.shift_left (Int64.logand s maxuint31) 31 in\n  let hr = Int64.shift_right_logical s 31 in\n  (* add the outer products *)\n  let lr = Int64.add (Int64.mul lx ly) lr in\n  let hr = Int64.add (Int64.mul hx hy) hr in\n  (* hr fits on 64 bits, since the final result fits on 126 bits *)\n  (* now x * y = hr * 2^62 + lr and lr < 2^63 *)\n  let lr = Int64.add lr (Int64.shift_left (Int64.logand hr 1L) 62) in\n  let hr = Int64.shift_right_logical hr 1 in\n  (* now x * y = hr * 2^63 + lr, but lr might be too large *)\n  if Int64.logand lr Int64.min_int <> 0L\n  then Int64.add hr 1L, mask63 lr\n  else hr, lr\n\nlet equal (x : t) y = x = y\n\nlet compare x y = Int64.compare x y\n\nlet compares x y = Int64.(compare (shift_left x 1) (shift_left y 1))\n\n(* Number of leading zeroes *)\nlet head0 x =\n  let r = ref 0 in\n  let x = ref x in\n  if Int64.logand !x 0x7FFFFFFF00000000L = 0L then r := !r + 31\n  else x := Int64.shift_right !x 31;\n  if Int64.logand !x 0xFFFF0000L = 0L then (x := Int64.shift_left !x 16; r := !r + 16);\n  if Int64.logand !x 0xFF000000L = 0L then (x := Int64.shift_left !x 8; r := !r + 8);\n  if Int64.logand !x 0xF0000000L = 0L then (x := Int64.shift_left !x 4; r := !r + 4);\n  if Int64.logand !x 0xC0000000L = 0L then (x := Int64.shift_left !x 2; r := !r + 2);\n  if Int64.logand !x 0x80000000L = 0L then (x := Int64.shift_left !x 1; r := !r + 1);\n  if Int64.logand !x 0x80000000L = 0L then (r := !r + 1);\n  Int64.of_int !r\n\n(* Number of trailing zeroes *)\nlet tail0 x =\n  let r = ref 0 in\n  let x = ref x in\n  if Int64.logand !x 0xFFFFFFFFL = 0L then (x := Int64.shift_right !x 32; r := !r + 32);\n  if Int64.logand !x 0xFFFFL = 0L then (x := Int64.shift_right !x 16; r := !r + 16);\n  if Int64.logand !x 0xFFL = 0L then (x := Int64.shift_right !x 8; r := !r + 8);\n  if Int64.logand !x 0xFL = 0L then (x := Int64.shift_right !x 4; r := !r + 4);\n  if Int64.logand !x 0x3L = 0L then (x := Int64.shift_right !x 2; r := !r + 2);\n  if Int64.logand !x 0x1L = 0L then (r := !r + 1);\n  Int64.of_int !r\n\n(* May an object be safely cast into an Uint63.t ? *)\nlet is_uint63 t =\n  Obj.is_block t && Int.equal (Obj.tag t) Obj.custom_tag\n  && le (Obj.magic t) maxuint63\n\n(* Arithmetic with explicit carries *)\n\n(* Analog of Numbers.Abstract.Cyclic.carry *)\ntype 'a carry = C0 of 'a | C1 of 'a\n\nlet addc x y =\n  let r = add x y in\n  if lt r x then C1 r else C0 r\n\nlet addcarryc x y =\n  let r = addcarry x y in\n  if le r x then C1 r else C0 r\n\nlet subc x y =\n  let r = sub x y in\n  if le y x then C0 r else C1 r\n\nlet subcarryc x y =\n  let r = subcarry x y in\n  if lt y x then C0 r else C1 r\n","open BearGame\nopen Game\nopen Graph\nopen OCamlTB\nopen OMap\nopen Player\nopen RomanWheel\nopen Show\nopen Sort\nopen Strategy\n\n(** val make_BG_State :\n    coq_Graph -> coq_Player -> coq_Vert -> coq_Vert -> coq_Vert -> coq_Vert\n    -> coq_BG_State option **)\n\nlet make_BG_State g pl b h1 h2 h3 =\n  let s =\n    coq_NoDup_dec (coq_Graph_Vert_disc g) (b :: (h1 :: (h2 :: (h3 :: []))))\n  in\n  if s\n  then Some { BearGame.to_play = pl; bear = b; hunters =\n         (insertion_sort\n           (subcount_Ord (coq_Graph_Vert_disc g) (coq_Graph_Vert_enum g))\n           (h1 :: (h2 :: (h3 :: [])))) }\n  else None\n\n(** val make_RW_State :\n    coq_Player -> coq_RWVert -> coq_RWVert -> coq_RWVert -> coq_RWVert ->\n    coq_BG_State option **)\n\nlet make_RW_State pl b h1 h2 h3 =\n  make_BG_State coq_RomanWheel pl (Obj.magic b) (Obj.magic h1) (Obj.magic h2)\n    (Obj.magic h3)\n\n(** val init_RW_State : coq_BG_State **)\n\nlet init_RW_State =\n  { BearGame.to_play = White; bear = (Obj.magic Center); hunters =\n    ((Obj.magic (SpokeVert (S1, Mid))) :: ((Obj.magic (SpokeVert (S1, L))) :: (\n    (Obj.magic (SpokeVert (S1, R))) :: []))) }\n\n(** val strC : string **)\n\nlet strC =\n  \"C\"\n\n(** val str1L : string **)\n\nlet str1L =\n  \"1L\"\n\n(** val str1M : string **)\n\nlet str1M =\n  \"1M\"\n\n(** val str1R : string **)\n\nlet str1R =\n  \"1R\"\n\n(** val str2L : string **)\n\nlet str2L =\n  \"2L\"\n\n(** val str2M : string **)\n\nlet str2M =\n  \"2M\"\n\n(** val str2R : string **)\n\nlet str2R =\n  \"2R\"\n\n(** val str3L : string **)\n\nlet str3L =\n  \"3L\"\n\n(** val str3M : string **)\n\nlet str3M =\n  \"3M\"\n\n(** val str3R : string **)\n\nlet str3R =\n  \"3R\"\n\n(** val str4L : string **)\n\nlet str4L =\n  \"4L\"\n\n(** val str4M : string **)\n\nlet str4M =\n  \"4M\"\n\n(** val str4R : string **)\n\nlet str4R =\n  \"4R\"\n\n(** val str5L : string **)\n\nlet str5L =\n  \"5L\"\n\n(** val str5M : string **)\n\nlet str5M =\n  \"5M\"\n\n(** val str5R : string **)\n\nlet str5R =\n  \"5R\"\n\n(** val str6L : string **)\n\nlet str6L =\n  \"6L\"\n\n(** val str6M : string **)\n\nlet str6M =\n  \"6M\"\n\n(** val str6R : string **)\n\nlet str6R =\n  \"6R\"\n\n(** val str7L : string **)\n\nlet str7L =\n  \"7L\"\n\n(** val str7M : string **)\n\nlet str7M =\n  \"7M\"\n\n(** val str7R : string **)\n\nlet str7R =\n  \"7R\"\n\n(** val str8L : string **)\n\nlet str8L =\n  \"8L\"\n\n(** val str8M : string **)\n\nlet str8M =\n  \"8M\"\n\n(** val str8R : string **)\n\nlet str8R =\n  \"8R\"\n\n(** val show_RWVert : coq_RWVert -> string **)\n\nlet show_RWVert = function\n| Center -> strC\n| SpokeVert (s, l) ->\n  (match s with\n   | S1 -> (match l with\n            | Mid -> str1M\n            | L -> str1L\n            | R -> str1R)\n   | S2 -> (match l with\n            | Mid -> str2M\n            | L -> str2L\n            | R -> str2R)\n   | S3 -> (match l with\n            | Mid -> str3M\n            | L -> str3L\n            | R -> str3R)\n   | S4 -> (match l with\n            | Mid -> str4M\n            | L -> str4L\n            | R -> str4R)\n   | S5 -> (match l with\n            | Mid -> str5M\n            | L -> str5L\n            | R -> str5R)\n   | S6 -> (match l with\n            | Mid -> str6M\n            | L -> str6L\n            | R -> str6R)\n   | S7 -> (match l with\n            | Mid -> str7M\n            | L -> str7L\n            | R -> str7R)\n   | S8 -> (match l with\n            | Mid -> str8M\n            | L -> str8L\n            | R -> str8R))\n\n(** val coq_Show_RWVert : coq_RWVert coq_Show **)\n\nlet coq_Show_RWVert =\n  show_RWVert\n\n(** val print_RW_move : coq_BG_State -> coq_BG_Move -> string **)\n\nlet print_RW_move _ = function\n| BearMove b -> (^) \"B\" (Obj.magic coq_Show_RWVert b)\n| HunterMove h ->\n  let { h_orig = h_orig0; h_dest = h_dest0 } = h in\n  (^) \"H\"\n    ((^) (Obj.magic coq_Show_RWVert h_orig0)\n      (Obj.magic coq_Show_RWVert h_dest0))\n\n(** val coq_RW_exec_move : coq_BG_State -> coq_BG_Move -> coq_BG_State **)\n\nlet coq_RW_exec_move s =\n  BearGame.exec_move coq_RomanWheel s\n\n(** val query_RW_TB :\n    coq_OCamlTablebase -> coq_BG_State -> (coq_Player * int) option **)\n\nlet query_RW_TB =\n  Obj.magic query_TB (coq_BearGame coq_RomanWheel) coq_IntHash_RW\n\n(** val rw_tb_strat :\n    coq_Player -> coq_GameState -> coq_OCamlTablebase -> strategy **)\n\nlet rw_tb_strat pl s tb =\n  tb_strat (coq_BearGame coq_RomanWheel) s pl coq_OMap coq_IntHash_RW tb\n","(* TyXML\n * http://www.ocsigen.org/tyxml\n * Copyright (C) 2010 by Simon Castellan\n * Copyright (C) 2010 by Cecile Herbelin\n * Copyright (C) 2010 by Vincent Balat\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1301, USA.\n*)\n\n(** Type instantiations for SVG *)\n\n(** This module defines basic data types for data, attributes\n    and element occurring in SVG documents.\n    It is based on the specification available at http://www.w3.org/TR/SVG/.\n\n    This module is experimental, it may lack of some attributes,\n    and the interface is very low level and do not take deeply into account\n    the needs of SVG elements. *)\n\nopen Svg_types\n\nopen Unit\n\nlet string_of_iri x = Printf.sprintf \"url(%s)\" x\n\nmodule Unit = struct\n\n  (* let rel x     = (x, None) *)\n  (* let deg x     = (x, Some `Deg) *)\n  (* let grad x    = (x, Some `Grad) *)\n  (* let rad x     = (x, Some `Rad) *)\n  (* let ms x      = (x, Some `Ms) *)\n  (* let s x       = (x, Some `S) *)\n  (* let em x      = (x, Some `Em) *)\n  (* let ex x      = (x, Some `Ex) *)\n  (* let px x      = (x, Some `Px) *)\n  (* let in_ x     = (x, Some `In) *)\n  (* let cm x      = (x, Some `Cm) *)\n  (* let mm x      = (x, Some `Mm) *)\n  (* let pt x      = (x, Some `Pt) *)\n  (* let pc x      = (x, Some `Pc) *)\n  (* let percent x = (x, Some `Percent) *)\n  (* let hz x      = (x, Some `Hz) *)\n  (* let khz x     = (x, Some `KHz) *)\n\n  let to_string f (n, unit) = Printf.sprintf \"%g%s\" n begin\n    match unit with\n    | Some unit -> f unit\n    | None -> \"\"\n  end\n\n  let angle_names = function `Deg -> \"deg\" | `Grad -> \"grad\" | `Rad -> \"rad\"\n  let string_of_angle a = to_string angle_names a\n\n  (* let time_names = function `Ms -> \"ms\" | `S -> \"s\" *)\n  (* let string_of_time a = to_string time_names a *)\n\n  let length_names = function\n    | `Em -> \"em\" | `Ex -> \"ex\" | `Px -> \"px\" | `In -> \"in\" | `Cm -> \"cm\"\n    | `Mm -> \"mm\" | `Pt -> \"pt\" | `Pc -> \"pc\" | `Percent -> \"%\"\n  let string_of_length (a: length) = to_string length_names a\n\n  (* let freq_names = function `Hz -> \"Hz\" | `KHz -> \"kHz\" *)\n  (* let string_of_freq a = to_string freq_names a *)\n\nend\n\nopen Unit\n\nlet opt_concat ?(sep=\" \") s f = function\n  | Some x -> s ^ sep ^ (f x)\n  | None -> s\n\nlet list ?(sep=\" \") f l = String.concat sep (List.map f l)\n\nlet string_of_color s = s\n(* For now just string, we may want something better in the future. *)\n\nlet string_of_icccolor s = s\n\nlet string_of_paint_whitout_icc = function\n  | `None -> \"none\"\n  | `CurrentColor -> \"currentColor\"\n  | `Color (c, icc) -> opt_concat (string_of_color c) string_of_icccolor icc\n\nlet string_of_paint = function\n  | `Icc (iri, None) -> string_of_iri iri\n  | `Icc (iri, Some b) ->\n    (string_of_iri iri) ^\" \"^ (string_of_paint_whitout_icc b)\n  | #paint_whitout_icc as c -> string_of_paint_whitout_icc c\n\nlet string_of_fill_rule = function\n  | `Nonzero -> \"nonzero\"\n  | `Evenodd -> \"evenodd\"\n\nmodule Make_with_wrapped_functions\n\n    (Xml : Xml_sigs.T)\n    (C : Svg_sigs.Wrapped_functions with module Xml = Xml) =\n\nstruct\n\n  module Xml = Xml\n  module W = Xml.W\n\n  module Info = struct\n    let content_type = \"image/svg+xml\"\n    let alternative_content_types = []\n    let emptytags = []\n    let version = \"SVG 1.1\"\n    let standard = \"http://www.w3.org/TR/svg11/\"\n    let namespace = \"http://www.w3.org/2000/svg\"\n    let doctype =\n      Xml_print.compose_doctype\"svg\"\n        [\"-//W3C//DTD SVG 1.1//EN\";\n         \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"]\n  end\n\n  type uri = Xml.uri\n  let string_of_uri = Xml.string_of_uri\n  let uri_of_string = Xml.uri_of_string\n\n\n  (* Mandatory XML stuff. *)\n\n  type 'a attrib = Xml.attrib\n\n  type +'a elt = Xml.elt\n\n  type 'a wrap = 'a W.t\n  type 'a list_wrap = 'a W.tlist\n\n  type ('a, 'b) nullary = ?a: (('a attrib) list) -> unit -> 'b elt\n\n  type ('a, 'b, 'c) unary = ?a: (('a attrib) list) -> 'b elt wrap -> 'c elt\n\n  type ('a, 'b, 'c) star =\n    ?a: (('a attrib) list) -> ('b elt) list_wrap -> 'c elt\n\n  let tot x = x\n\n  let totl x = x\n\n  let toelt x = x\n\n  let toeltl x = x\n\n  let to_attrib x = x\n\n  let nullary tag ?a () =\n    Xml.node ?a tag (W.nil ())\n\n  let unary tag ?a elt =\n    Xml.node ?a tag (W.singleton elt)\n\n  let star tag ?a elts = Xml.node ?a tag elts\n\n  type altglyphdef_content =\n    [ `Ref of (glyphref elt) list\n    | `Item of (altglyphitem elt) list\n    ]\n\n  let to_xmlattribs x = x\n\n  let float_attrib = Xml.float_attrib\n\n  let string_attrib = Xml.string_attrib\n\n  (* wrap C module functions *)\n\n  let string_of_coord = C.string_of_length\n\n  let string_of_length = C.string_of_length\n\n  let string_of_lengths = C.string_of_lengths\n\n  (* Custom XML attributes *)\n\n  let user_attrib f name v =\n    Xml.string_attrib name (W.fmap f v)\n\n  let number_attrib = float_attrib\n\n  (* for now string_attrib, we may want something better in the\n     future. *)\n  let color_attrib = Xml.string_attrib\n\n  (* SVG attributes *)\n\n  let metadata ?a children = Xml.node ?a \"metadata\" children\n\n  let foreignObject ?a children = Xml.node ?a \"foreignObject\" children\n\n  let txt s = Xml.pcdata s\n  let pcdata = txt\n\n  (* generated *)\n  let a_version = string_attrib \"version\"\n\n  let a_baseProfile = string_attrib \"baseProfile\"\n\n  let a_x = user_attrib string_of_coord \"x\"\n\n  let a_y = user_attrib string_of_coord \"y\"\n\n  let a_width = user_attrib string_of_length \"width\"\n\n  let a_height = user_attrib string_of_length \"height\"\n\n  let a_preserveAspectRatio =\n    string_attrib \"preserveAspectRatio\"\n\n  let a_contentScriptType =\n    string_attrib \"contentScriptType\"\n\n  let a_contentStyleType = string_attrib \"contentStyleType\"\n\n  let a_zoomAndPan x =\n    user_attrib C.string_of_big_variant \"zoomAndSpan\" x\n\n  let a_href = string_attrib \"href\"\n\n  let a_xlink_href = string_attrib \"xlink:href\"\n\n  let a_requiredFeatures =\n    Xml.space_sep_attrib \"requiredFeatures\"\n\n  let a_requiredExtensions =\n    Xml.space_sep_attrib \"requiredExtension\"\n\n  let a_systemLanguage =\n    Xml.comma_sep_attrib \"systemLanguage\"\n\n  let a_externalRessourcesRequired =\n    user_attrib C.string_of_bool \"externalRessourcesRequired\"\n\n  let a_id = string_attrib \"id\"\n\n  let a_user_data name = string_attrib (\"data-\" ^ name)\n\n  let a_xml_base = string_attrib \"xml:base\"\n\n  let a_xml_lang = string_attrib \"xml:lang\"\n\n  let a_xml_space x =\n    user_attrib C.string_of_big_variant \"xml:space\" x\n\n  let a_type = string_attrib \"type\"\n\n  let a_media = Xml.comma_sep_attrib \"media\"\n\n  let a_xlink_title = string_attrib \"xlink:title\"\n\n  let a_class = Xml.space_sep_attrib \"class\"\n\n  let a_style = string_attrib \"style\"\n\n  let a_transform = user_attrib C.string_of_transforms \"transform\"\n\n  let a_viewBox = user_attrib C.string_of_fourfloats \"viewBox\"\n\n  let a_d = string_attrib \"d\"\n\n  let a_pathLength = number_attrib \"pathLength\"\n\n  let a_rx = user_attrib string_of_length \"rx\"\n\n  let a_ry = user_attrib string_of_length \"ry\"\n\n  let a_cx = user_attrib string_of_length \"cx\"\n\n  let a_cy = user_attrib string_of_length \"cy\"\n\n  let a_r = user_attrib string_of_length \"r\"\n\n  let a_x1 = user_attrib string_of_coord \"x1\"\n\n  let a_y1 = user_attrib string_of_coord \"y1\"\n\n  let a_x2 = user_attrib string_of_coord \"x2\"\n\n  let a_y2 = user_attrib string_of_coord \"y2\"\n\n  let a_points = user_attrib C.string_of_coords \"points\"\n\n  let a_x_list = user_attrib string_of_lengths \"x\"\n\n  let a_y_list = user_attrib string_of_lengths \"y\"\n\n  let a_dx = user_attrib C.string_of_number \"dx\"\n\n  let a_dy = user_attrib C.string_of_number \"dy\"\n\n  let a_dx_list = user_attrib string_of_lengths \"dx\"\n\n  let a_dy_list = user_attrib string_of_lengths \"dy\"\n\n  let a_lengthAdjust x =\n    user_attrib C.string_of_big_variant \"lengthAdjust\" x\n\n  let a_textLength = user_attrib string_of_length \"textLength\"\n\n  let a_text_anchor x =\n    user_attrib C.string_of_big_variant \"text-anchor\" x\n\n  let a_text_decoration x =\n    user_attrib C.string_of_big_variant \"text-decoration\" x\n\n  let a_text_rendering x =\n    user_attrib C.string_of_big_variant \"text-rendering\" x\n\n  let a_rotate = user_attrib C.string_of_numbers \"rotate\"\n\n  let a_startOffset = user_attrib string_of_length \"startOffset\"\n\n  let a_method x =\n    user_attrib C.string_of_big_variant \"method\" x\n\n  let a_spacing x =\n    user_attrib C.string_of_big_variant \"spacing\" x\n\n  let a_glyphRef = string_attrib \"glyphRef\"\n\n  let a_format = string_attrib \"format\"\n\n  let a_markerUnits x =\n    user_attrib C.string_of_big_variant \"markerUnits\" x\n\n  let a_refX = user_attrib string_of_coord \"refX\"\n\n  let a_refY = user_attrib string_of_coord \"refY\"\n\n  let a_markerWidth = user_attrib string_of_length \"markerWidth\"\n\n  let a_markerHeight = user_attrib string_of_length \"markerHeight\"\n\n  let a_orient x =\n    user_attrib C.string_of_orient \"orient\" x\n\n  let a_local = string_attrib \"local\"\n\n  let a_rendering_intent x =\n    user_attrib C.string_of_big_variant \"rendering-intent\" x\n\n  let a_gradientUnits x =\n    user_attrib C.string_of_big_variant \"gradientUnits\" x\n\n  let a_gradientTransform =\n    user_attrib C.string_of_transforms \"gradientTransform\"\n\n  let a_spreadMethod x =\n    user_attrib C.string_of_big_variant \"spreadMethod\" x\n\n  let a_fx = user_attrib string_of_coord \"fx\"\n\n  let a_fy = user_attrib string_of_coord \"fy\"\n\n  let a_offset x =\n    user_attrib C.string_of_offset \"offset\" x\n\n  let a_patternUnits x =\n    user_attrib C.string_of_big_variant \"patternUnits\" x\n\n  let a_patternContentUnits x =\n    user_attrib C.string_of_big_variant \"patternContentUnits\" x\n\n  let a_patternTransform x =\n    user_attrib C.string_of_transforms \"patternTransform\" x\n\n  let a_clipPathUnits x =\n    user_attrib C.string_of_big_variant \"clipPathUnits\" x\n\n  let a_maskUnits x =\n    user_attrib C.string_of_big_variant \"maskUnits\" x\n\n  let a_maskContentUnits x =\n    user_attrib C.string_of_big_variant \"maskContentUnits\" x\n\n  let a_primitiveUnits x =\n    user_attrib C.string_of_big_variant \"primitiveUnits\" x\n\n  let a_filterRes =\n    user_attrib C.string_of_number_optional_number \"filterResUnits\"\n\n  let a_result = string_attrib \"result\"\n\n  let a_in x =\n    user_attrib C.string_of_in_value \"in\" x\n\n  let a_in2 x =\n    user_attrib C.string_of_in_value \"in2\" x\n\n  let a_azimuth = number_attrib \"azimuth\"\n\n  let a_elevation = number_attrib \"elevation\"\n\n  let a_pointsAtX = number_attrib \"pointsAtX\"\n\n  let a_pointsAtY = number_attrib \"pointsAtY\"\n\n  let a_pointsAtZ = number_attrib \"pointsAtZ\"\n\n  let a_specularExponent = number_attrib \"specularExponent\"\n\n  let a_specularConstant = number_attrib \"specularConstant\"\n\n  let a_limitingConeAngle = number_attrib \"limitingConeAngle\"\n\n  let a_mode x =\n    user_attrib C.string_of_big_variant \"mode\" x\n\n  let a_feColorMatrix_type x =\n    user_attrib C.string_of_big_variant \"type\" x\n\n  let a_values = user_attrib C.string_of_numbers \"values\"\n\n  let a_transfer_type x =\n    user_attrib C.string_of_big_variant \"type\" x\n\n  let a_tableValues = user_attrib C.string_of_numbers \"tableValues\"\n\n  let a_intercept = user_attrib C.string_of_number \"intercept\"\n\n  let a_amplitude = user_attrib C.string_of_number \"amplitude\"\n\n  let a_exponent = user_attrib C.string_of_number \"exponent\"\n\n  let a_transfer_offset = user_attrib C.string_of_number \"offset\"\n\n  let a_feComposite_operator x =\n    user_attrib C.string_of_big_variant \"operator\" x\n\n  let a_k1 = user_attrib C.string_of_number \"k1\"\n\n  let a_k2 = user_attrib C.string_of_number \"k2\"\n\n  let a_k3 = user_attrib C.string_of_number \"k3\"\n\n  let a_k4 = user_attrib C.string_of_number \"k4\"\n\n  let a_order = user_attrib C.string_of_number_optional_number \"order\"\n\n  let a_kernelMatrix = user_attrib C.string_of_numbers \"kernelMatrix\"\n\n  let a_divisor = user_attrib C.string_of_number \"divisor\"\n\n  let a_bias = user_attrib C.string_of_number \"bias\"\n\n  let a_kernelUnitLength =\n    user_attrib C.string_of_number_optional_number \"kernelUnitLength\"\n\n  let a_targetX = user_attrib C.string_of_int \"targetX\"\n\n  let a_targetY = user_attrib C.string_of_int \"targetY\"\n\n  let a_edgeMode x =\n    user_attrib C.string_of_big_variant \"targetY\" x\n\n  let a_preserveAlpha = user_attrib C.string_of_bool \"preserveAlpha\"\n\n  let a_surfaceScale = user_attrib C.string_of_number \"surfaceScale\"\n\n  let a_diffuseConstant =\n    user_attrib C.string_of_number \"diffuseConstant\"\n\n  let a_scale = user_attrib C.string_of_number \"scale\"\n\n  let a_xChannelSelector x =\n    user_attrib C.string_of_big_variant \"xChannelSelector\" x\n\n  let a_yChannelSelector x =\n    user_attrib C.string_of_big_variant \"yChannelSelector\" x\n\n  let a_stdDeviation =\n    user_attrib C.string_of_number_optional_number \"stdDeviation\"\n\n  let a_feMorphology_operator x =\n    user_attrib C.string_of_big_variant \"operator\" x\n\n  let a_radius = user_attrib C.string_of_number_optional_number \"radius\"\n\n  let a_baseFrenquency =\n    user_attrib C.string_of_number_optional_number \"baseFrequency\"\n\n  let a_numOctaves = user_attrib C.string_of_int \"numOctaves\"\n\n  let a_seed = user_attrib C.string_of_number \"seed\"\n\n  let a_stitchTiles x =\n    user_attrib C.string_of_big_variant \"stitchTiles\" x\n\n  let a_feTurbulence_type x =\n    user_attrib C.string_of_big_variant \"type\" x\n\n  let a_xlink_show x =\n    user_attrib C.string_of_big_variant \"xlink:show\" x\n\n  let a_xlink_actuate x =\n    user_attrib C.string_of_big_variant \"xlink:actuate\" x\n\n  let a_target = string_attrib \"xlink:target\"\n\n  let a_viewTarget = string_attrib \"viewTarget\"\n\n  let a_attributeName = string_attrib \"attributeName\"\n\n  let a_attributeType x =\n    user_attrib C.string_of_big_variant \"attributeType\" x\n\n  let a_begin = string_attrib \"begin\"\n\n  let a_dur = string_attrib \"dur\"\n\n  let a_min = string_attrib \"min\"\n\n  let a_max = string_attrib \"max\"\n\n  let a_restart x =\n    user_attrib C.string_of_big_variant \"restart\" x\n\n  let a_repeatCount = string_attrib \"repeatCount\"\n\n  let a_repeatDur = string_attrib \"repeatDur\"\n\n  let a_fill = user_attrib C.string_of_paint \"fill\"\n\n  let a_animation_fill x =\n    user_attrib C.string_of_big_variant \"fill\" x\n\n  let a_fill_rule = user_attrib C.string_of_fill_rule \"fill-rule\"\n\n  let a_calcMode x =\n    user_attrib C.string_of_big_variant \"calcMode\" x\n\n  let a_animation_values = Xml.comma_sep_attrib \"values\"\n\n  let a_keyTimes = Xml.comma_sep_attrib \"keyTimes\"\n\n  let a_keySplines = Xml.comma_sep_attrib \"keySplines\"\n\n  let a_from = string_attrib \"from\"\n\n  let a_to = string_attrib \"to\"\n\n  let a_by = string_attrib \"by\"\n\n  let a_additive x =\n    user_attrib C.string_of_big_variant \"additive\" x\n\n  let a_accumulate x =\n    user_attrib C.string_of_big_variant \"accumulate\" x\n\n  let a_keyPoints = user_attrib C.string_of_numbers_semicolon \"keyPoints\"\n\n  let a_path = string_attrib \"path\"\n\n  let a_animateTransform_type =\n    user_attrib C.string_of_big_variant \"type\"\n\n  let a_horiz_origin_x = user_attrib C.string_of_number \"horiz-origin-x\"\n\n  let a_horiz_origin_y = user_attrib C.string_of_number \"horiz-origin-y\"\n\n  let a_horiz_adv_x = user_attrib C.string_of_number \"horiz-adv-x\"\n\n  let a_vert_origin_x = user_attrib C.string_of_number \"vert-origin-x\"\n\n  let a_vert_origin_y = user_attrib C.string_of_number \"vert-origin-y\"\n\n  let a_vert_adv_y = user_attrib C.string_of_number \"vert-adv-y\"\n\n  let a_unicode = string_attrib \"unicode\"\n\n  let a_glyph_name = string_attrib \"glyphname\"\n\n  let a_orientation x =\n    user_attrib C.string_of_big_variant \"orientation\" x\n\n  let a_arabic_form x =\n    user_attrib C.string_of_big_variant \"arabic-form\" x\n\n  let a_lang = string_attrib \"lang\"\n\n  let a_u1 = string_attrib \"u1\"\n\n  let a_u2 = string_attrib \"u2\"\n\n  let a_g1 = string_attrib \"g1\"\n\n  let a_g2 = string_attrib \"g2\"\n\n  let a_k = string_attrib \"k\"\n\n  let a_font_family = string_attrib \"font-family\"\n\n  let a_font_style = string_attrib \"font-style\"\n\n  let a_font_variant = string_attrib \"font-variant\"\n\n  let a_font_weight = string_attrib \"font-weight\"\n\n  let a_font_stretch = string_attrib \"font-stretch\"\n\n  let a_font_size = string_attrib \"font-size\"\n\n  let a_unicode_range = string_attrib \"unicode-range\"\n\n  let a_units_per_em = string_attrib \"units-per-em\"\n\n  let a_stemv = user_attrib C.string_of_number \"stemv\"\n\n  let a_stemh = user_attrib C.string_of_number \"stemh\"\n\n  let a_slope = user_attrib C.string_of_number \"slope\"\n\n  let a_cap_height = user_attrib C.string_of_number \"cap-height\"\n\n  let a_x_height = user_attrib C.string_of_number \"x-height\"\n\n  let a_accent_height = user_attrib C.string_of_number \"accent-height\"\n\n  let a_ascent = user_attrib C.string_of_number \"ascent\"\n\n  let a_widths = string_attrib \"widths\"\n\n  let a_bbox = string_attrib \"bbox\"\n\n  let a_ideographic = user_attrib C.string_of_number \"ideographic\"\n\n  let a_alphabetic = user_attrib C.string_of_number \"alphabetic\"\n\n  let a_mathematical = user_attrib C.string_of_number \"mathematical\"\n\n  let a_hanging = user_attrib C.string_of_number \"hanging\"\n\n  let a_videographic = user_attrib C.string_of_number \"v-ideographic\"\n\n  let a_v_alphabetic = user_attrib C.string_of_number \"v-alphabetic\"\n\n  let a_v_mathematical = user_attrib C.string_of_number \"v-mathematical\"\n\n  let a_v_hanging = user_attrib C.string_of_number \"v-hanging\"\n\n  let a_underline_position =\n    user_attrib C.string_of_number \"underline-position\"\n\n  let a_underline_thickness =\n    user_attrib C.string_of_number \"underline-thickness\"\n\n  let a_strikethrough_position =\n    user_attrib C.string_of_number \"strikethrough-position\"\n\n  let a_strikethrough_thickness =\n    user_attrib C.string_of_number \"strikethrough-thickness\"\n\n  let a_overline_position = user_attrib C.string_of_number \"overline-position\"\n\n  let a_overline_thickness =\n    user_attrib C.string_of_number \"overline-thickness\"\n\n  let a_string = string_attrib \"string\"\n\n  let a_name = string_attrib \"name\"\n\n  let a_alignment_baseline x =\n    user_attrib C.string_of_alignment_baseline \"alignment-baseline\" x\n\n  let a_dominant_baseline x =\n    user_attrib C.string_of_dominant_baseline \"dominant-baseline\" x\n\n  (** Javascript events *)\n\n  let a_onabort = Xml.event_handler_attrib \"onabort\"\n  let a_onactivate = Xml.event_handler_attrib \"onactivate\"\n  let a_onbegin = Xml.event_handler_attrib \"onbegin\"\n  let a_onend = Xml.event_handler_attrib \"onend\"\n  let a_onerror = Xml.event_handler_attrib \"onerror\"\n  let a_onfocusin = Xml.event_handler_attrib \"onfocusin\"\n  let a_onfocusout = Xml.event_handler_attrib \"onfocusout\"\n  let a_onload = Xml.event_handler_attrib \"onload\"\n  let a_onrepeat = Xml.event_handler_attrib \"onrepeat\"\n  let a_onresize = Xml.event_handler_attrib \"onresize\"\n  let a_onscroll = Xml.event_handler_attrib \"onscroll\"\n  let a_onunload = Xml.event_handler_attrib \"onunload\"\n  let a_onzoom = Xml.event_handler_attrib \"onzoom\"\n\n  (** Javascript mouse events *)\n\n  let a_onclick = Xml.mouse_event_handler_attrib \"onclick\"\n  let a_onmousedown = Xml.mouse_event_handler_attrib \"onmousedown\"\n  let a_onmouseup = Xml.mouse_event_handler_attrib \"onmouseup\"\n  let a_onmouseover = Xml.mouse_event_handler_attrib \"onmouseover\"\n  let a_onmouseout = Xml.mouse_event_handler_attrib \"onmouseout\"\n  let a_onmousemove = Xml.mouse_event_handler_attrib \"onmousemove\"\n\n  (** Javascript touch events *)\n  let a_ontouchstart = Xml.touch_event_handler_attrib \"ontouchstart\"\n  let a_ontouchend = Xml.touch_event_handler_attrib \"ontouchend\"\n  let a_ontouchmove = Xml.touch_event_handler_attrib \"ontouchmove\"\n  let a_ontouchcancel = Xml.touch_event_handler_attrib \"ontouchcancel\"\n\n  let a_stop_color = color_attrib \"stop-color\"\n\n  let a_stop_opacity = user_attrib C.string_of_number \"stop-opacity\"\n\n  let a_stroke = user_attrib C.string_of_paint \"stroke\"\n\n  let a_stroke_width = user_attrib C.string_of_length \"stroke-width\"\n\n  let a_stroke_linecap x =\n    user_attrib C.string_of_big_variant \"stroke-linecap\" x\n\n  let a_stroke_linejoin x =\n    user_attrib C.string_of_big_variant \"stroke-linejoin\" x\n\n  let a_stroke_miterlimit =\n    user_attrib C.string_of_number \"stroke-miterlimit\"\n\n  let a_stroke_dasharray x =\n    user_attrib C.string_of_strokedasharray \"stroke-dasharray\" x\n\n  let a_stroke_dashoffset =\n    user_attrib C.string_of_length \"stroke-dashoffset\"\n\n  let a_stroke_opacity =\n    user_attrib C.string_of_number \"stroke-opacity\"\n\n  (* xlink namespace given a nickname since some attributes mandated by\n     the svg standard such as xlink:href live in that namespace, and we\n     refer to them as \"xlink:whatever\" (see a_xlink_href or a_xlinkshow)\n  *)\n  let svg ?(a = []) children =\n    let attribs =\n      string_attrib \"xmlns\" (W.return \"http://www.w3.org/2000/svg\")\n      :: string_attrib \"xmlns:xlink\" (W.return \"http://www.w3.org/1999/xlink\")\n      :: to_xmlattribs a\n    in\n    star ~a:(attribs) \"svg\" children\n\n  (* also generated *)\n  let g = star \"g\"\n\n  let defs = star \"defs\"\n\n  let desc = unary \"desc\"\n\n  let title = unary \"title\"\n\n  let symbol = star \"symbol\"\n\n  let use = star \"use\"\n\n  let image = star \"image\"\n\n  let switch = star \"switch\"\n\n  let style = unary \"style\"\n\n  let path = star \"path\"\n\n  let rect = star \"rect\"\n\n  let circle = star \"circle\"\n\n  let ellipse = star \"ellipse\"\n\n  let line = star \"line\"\n\n  let polyline = star \"polyline\"\n\n  let polygon = star \"polygon\"\n\n  let text = star \"text\"\n\n  let tspan = star \"tspan\"\n\n  let tref = star \"tref\"\n\n  let textPath = star \"textPath\"\n\n  let altGlyph = unary \"altGlyph\"\n\n  let altGlyphDef = unary \"altGlyphDef\"\n\n  let altGlyphItem = star \"altGlyphItem\"\n\n  let glyphRef = nullary \"glyphRef\"\n\n  let marker = star \"marker\"\n\n  let color_profile = star \"color-profile\"\n\n  let linearGradient = star \"linearGradient\"\n\n  let radialGradient = star \"radialGradient\"\n\n  let stop = star \"stop\"\n\n  let pattern = star \"pattern\"\n\n  let clipPath = star \"clipPath\"\n\n  let filter = star \"filter\"\n\n  let feDistantLight = star \"feDistantLight\"\n\n  let fePointLight = star \"fePointLight\"\n\n  let feSpotLight = star \"feSpotLight\"\n\n  let feBlend = star \"feBlend\"\n\n  let feColorMatrix = star \"feColorMatrix\"\n\n  let feComponentTransfer = star \"feComponentTransfer\"\n\n  let feFuncA = star \"feFuncA\"\n\n  let feFuncG = star \"feFuncG\"\n\n  let feFuncB = star \"feFuncB\"\n\n  let feFuncR = star \"feFuncR\"\n\n  let feComposite = star \"feComposite\"\n\n  let feConvolveMatrix = star \"feConvolveMatrix\"\n\n  let feDiffuseLighting = star \"feDiffuseLighting\"\n\n  let feDisplacementMap = star \"feDisplacementMap\"\n\n  let feFlood = star \"feFlood\"\n\n  let feGaussianBlur = star \"feGaussianBlur\"\n\n  let feImage = star \"feImage\"\n\n  let feMerge = star \"feMerge\"\n\n  let feMorphology = star \"feMorphology\"\n\n  let feOffset = star \"feOffset\"\n\n  let feSpecularLighting = star \"feSpecularLighting\"\n\n  let feTile = star \"feTile\"\n\n  let feTurbulence = star \"feTurbulence\"\n\n  let cursor = star \"cursor\"\n\n  let a = star \"a\"\n\n  let view = star \"view\"\n\n  let script = unary \"script\"\n\n  let animate = star \"animate\"\n\n  let animation = animate\n\n  let set = star \"set\"\n\n  let animateMotion = star \"animateMotion\"\n\n  let mpath = star \"mpath\"\n\n  let animateColor = star \"animateColor\"\n\n  let animateTransform = star \"animateTransform\"\n\n  let font = star \"font\"\n\n  let glyph = star \"glyph\"\n\n  let missing_glyph = star \"missing-glyph\"\n\n  let hkern = nullary \"hkern\"\n\n  let vkern = nullary \"vkern\"\n\n  let font_face = nullary \"font-face\"\n\n  let font_face_src = star \"font-face-src\"\n\n  let font_face_uri = star \"font-face-uri\"\n\n  let font_face_format = nullary \"font-face-uri\"\n\n  let font_face_name = nullary \"font-face-name\"\n\n  type doc = [ `Svg ] elt\n  let doc_toelt x = x\n\n  module I = Xml_stream.Import(Xml)\n  let of_seq s = totl @@ I.of_seq s\n\n  module Unsafe = struct\n\n    let data s = Xml.encodedpcdata s\n\n    let leaf tag ?a () = Xml.leaf ?a tag\n\n    let node tag ?a elts = Xml.node ?a tag elts\n\n    let coerce_elt x = x\n\n    let float_attrib = Xml.float_attrib\n\n    let int_attrib = Xml.int_attrib\n\n    let string_attrib = Xml.string_attrib\n\n    let uri_attrib a s = Xml.uri_attrib a s\n\n    let space_sep_attrib = Xml.space_sep_attrib\n\n    let comma_sep_attrib = Xml.comma_sep_attrib\n\n  end\n\nend\n\nmodule Wrapped_functions\n    (Xml : Xml_sigs.T with type ('a,'b) W.ft = 'a -> 'b) =\nstruct\n\n  module Xml = Xml\n\n  let string_of_alignment_baseline = function\n    | `Auto -> \"auto\"\n    | `Baseline -> \"baseline\"\n    | `Before_edge -> \"before-edge\"\n    | `Text_before_edge -> \"text-before-edge\"\n    | `Middle -> \"middle\"\n    | `Central -> \"central\"\n    | `After_edge -> \"after-edge\"\n    | `Text_after_edge -> \"text-after-edge\"\n    | `Ideographic -> \"ideographic\"\n    | `Alphabetic -> \"alphabetic\"\n    | `Hanging-> \"hanging\"\n    | `Mathematical -> \"mathematical\"\n    | `Inherit -> \"inherit\"\n\n  let string_of_big_variant = function\n    | `A -> \"a\"\n    | `Absolute_colorimetric -> \"absolute_colorimetric\"\n    | `Align -> \"\"\n    | `Always -> \"always\"\n    | `Atop -> \"atop\"\n    | `Arithmetic -> \"arithmetic\"\n    | `Auto -> \"auto\"\n    | `B -> \"b\"\n    | `Bever -> \"bevel\"\n    | `Blink -> \"blink\"\n    | `Butt -> \"butt\"\n    | `CSS -> \"CSS\"\n    | `Darken -> \"darken\"\n    | `Default -> \"default\"\n    | `Dilate -> \"dilate\"\n    | `Disable -> \"disable\"\n    | `Discrete -> \"discrete\"\n    | `Duplicate -> \"duplicate\"\n    | `End -> \"end\"\n    | `Erode -> \"erode\"\n    | `Exact -> \"exact\"\n    | `FractalNoise -> \"fractalNoise\"\n    | `Freeze -> \"freeze\"\n    | `HueRotate -> \"hueRotate\"\n    | `G -> \"g\"\n    | `Gamma -> \"gamma\"\n    | `GeometricPrecision -> \"geometricPrecision\"\n    | `H -> \"h\"\n    | `Identity -> \"identity\"\n    | `In -> \"in\"\n    | `Inherit -> \"inherit\"\n    | `Initial -> \"initial\"\n    | `Isolated -> \"isolated\"\n    | `Lighten -> \"lighten\"\n    | `Line_through -> \"line-through\"\n    | `Linear -> \"linear\"\n    | `LuminanceToAlpha -> \"luminanceToAlpha\"\n    | `Magnify -> \"magnify\"\n    | `Matrix -> \"matrix\"\n    | `Medial -> \"medial\"\n    | `Middle -> \"middle\"\n    | `Miter -> \"miter\"\n    | `Multiply -> \"multiply\"\n    | `Never -> \"never\"\n    | `New -> \"new\"\n    | `None -> \"none\"\n    | `Normal -> \"normal\"\n    | `NoStitch -> \"noStitch\"\n    | `ObjectBoundingBox -> \"objectBoundingBox\"\n    | `OnLoad -> \"onLoad\"\n    | `OnRequest -> \"onRequest\"\n    | `OptimizeLegibility -> \"optimizeLegibility\"\n    | `OptimizeSpeed -> \"optimizeSpeed\"\n    | `Other -> \"other\"\n    | `Out -> \"out\"\n    | `Over -> \"over\"\n    | `Overline -> \"overline\"\n    | `Paced -> \"paced\"\n    | `Pad -> \"pad\"\n    | `Perceptual -> \"perceptual\"\n    | `Preserve -> \"preserve\"\n    | `R -> \"r\"\n    | `Reflect -> \"reflect\"\n    | `Remove -> \"remove\"\n    | `Repeat -> \"repeat\"\n    | `Replace -> \"replace\"\n    | `Relative_colorimetric -> \"relative_colorimetric\"\n    | `Rotate -> \"rotate\"\n    | `Round -> \"round\"\n    | `Saturate -> \"saturate\"\n    | `Saturation -> \"saturation\"\n    | `Scale -> \"scale\"\n    | `Screen -> \"screen\"\n    | `SkewX -> \"skewX\"\n    | `SkewY -> \"skewY\"\n    | `Spacing -> \"spacing\"\n    | `SpacingAndGlyphs -> \"spacingAndGlyphs\"\n    | `Spline -> \"spline\"\n    | `Square -> \"square\"\n    | `Start -> \"start\"\n    | `Stitch -> \"stitch\"\n    | `Stretch -> \"stretch\"\n    | `StrokeWidth -> \"stroke-width\"\n    | `Sum -> \"sum\"\n    | `Table -> \"table\"\n    | `Terminal -> \"terminal\"\n    | `Translate -> \"translate\"\n    | `Turbulence -> \"turbulence\"\n    | `Underline -> \"underline\"\n    | `UserSpaceOnUse -> \"userSpaceOnUse\"\n    | `V -> \"v\"\n    | `WhenNotActive -> \"whenNotActive\"\n    | `Wrap -> \"wrap\"\n    | `XML -> \"XML\"\n    | `Xor -> \"xor\"\n\n  let string_of_bool = string_of_bool\n\n  let string_of_coords =\n    list (fun (a, b) -> Printf.sprintf \"%g, %g\" a b)\n\n  let string_of_dominant_baseline = function\n    | `Auto -> \"auto\"\n    | `Use_script -> \"usescript\"\n    | `No_change -> \"nochange\"\n    | `Reset_size -> \"resetsize\"\n    | `Ideographic -> \"ideographic\"\n    | `Alphabetic -> \"alphabetic\"\n    | `Hanging -> \"hanging\"\n    | `Mathematical -> \"mathematical\"\n    | `Central -> \"central\"\n    | `Middle -> \"middle\"\n    | `Text_after_edge -> \"textafteredge\"\n    | `Text_before_edge -> \"textbeforeedge\"\n    | `Inherit -> \"inherit\"\n\n\n  let string_of_in_value = function\n    | `SourceGraphic -> \"sourceGraphic\"\n    | `SourceAlpha -> \"sourceAlpha\"\n    | `BackgroundImage -> \"backgroundImage\"\n    | `BackgroundAlpha -> \"backgroundAlpha\"\n    | `FillPaint -> \"fillPaint\"\n    | `StrokePaint -> \"strokePaint\"\n    | `Ref _svg -> _svg\n\n  let string_of_int = string_of_int\n\n  let string_of_length = Unit.string_of_length\n\n  let string_of_lengths = list string_of_length\n\n  let string_of_number = Xml_print.string_of_number\n\n  let string_of_percentage x = (string_of_number x) ^ \"%\"\n\n  let string_of_fourfloats (a, b, c, d) =\n    Printf.sprintf \"%s %s %s %s\"\n      (string_of_number a) (string_of_number b) (string_of_number c) (string_of_number d)\n\n  let string_of_number_optional_number = function\n    | x, Some y -> Printf.sprintf \"%g, %g\" x y\n    | x, None -> Printf.sprintf \"%g\" x\n\n  let string_of_numbers = list string_of_number\n\n  let string_of_numbers_semicolon = list ~sep:\"; \" string_of_number\n\n  let string_of_offset = function\n    | `Number x -> string_of_number x\n    | `Percentage x -> string_of_percentage x\n\n  let string_of_orient = function\n    | None -> \"auto\"\n    | Some __svg -> string_of_angle __svg\n\n  let string_of_paint = string_of_paint\n\n  let string_of_fill_rule = string_of_fill_rule\n\n  let string_of_strokedasharray = function\n    | [] -> \"none\"\n    | l -> list string_of_length l\n\n  let string_of_transform = function\n    | `Matrix (a, b, c, d, e, f) ->\n      Printf.sprintf \"matrix(%g %g %g %g %g %g)\" a b c d e f\n    | `Translate x ->\n      Printf.sprintf \"translate(%s)\"\n        (string_of_number_optional_number x)\n    | `Scale x ->\n      Printf.sprintf \"scale(%s)\" (string_of_number_optional_number x)\n    | `Rotate ((angle, x)) ->\n      Printf.sprintf \"rotate(%s %s)\" (string_of_angle angle)\n        (match x with\n         | Some ((x, y)) -> Printf.sprintf \"%g %g\" x y\n         | None -> \"\")\n    | `SkewX angle ->\n      Printf.sprintf \"skewX(%s)\" (string_of_angle angle)\n    | `SkewY angle ->\n      Printf.sprintf \"skewY(%s)\" (string_of_angle angle)\n\n  let string_of_transforms l =\n    String.concat \" \" (List.map string_of_transform l)\n\nend\n\nmodule Make\n    (Xml : Xml_sigs.T with type ('a, 'b) W.ft = ('a -> 'b)) =\n  Make_with_wrapped_functions(Xml)(Wrapped_functions(Xml))\n","open Lwt.Infix\nopen Js_of_ocaml\nopen Js_of_ocaml_tyxml\n\nopen Query\nopen BearGame\nopen ExtractQuery\nopen Read_file\nopen Draw\nopen Strategy\n\nmodule Model = struct\n\n  type pre_play_state =\n    { curr_state : coq_BG_State;\n    }\n\n  type play_state = \n    { curr_state : coq_BG_State;\n      curr_tb_strategy : strategy;\n      tb_player : Player.coq_Player;\n      curr_selected : Graph.coq_Vert option;\n    }\n\n  type piece = H1 | H2 | H3 | B\n\n  type edit_state =\n    { bear : Graph.coq_Vert;\n      hunter1 : Graph.coq_Vert;\n      hunter2 : Graph.coq_Vert;\n      hunter3 : Graph.coq_Vert;\n      to_play : Player.coq_Player;\n      curr_selected : piece option;\n    }\n\n  type query_state = \n    { curr_state : coq_BG_State;\n      curr_selected : Graph.coq_Vert option;\n    }\n\n  let piece_of_vertex st v =\n    if v = st.bear\n    then Some B\n    else if v = st.hunter1\n    then Some H1\n    else if v = st.hunter2\n    then Some H2\n    else if v = st.hunter3\n    then Some H3\n    else None\n\n  let vertex_of_piece st = function\n    | H1 -> st.hunter1\n    | H2 -> st.hunter2\n    | H3 -> st.hunter3\n    | B -> st.bear\n\n  let update_piece st p v =\n    match p with\n    | H1 -> { st with hunter1 = v; curr_selected = None }\n    | H2 -> { st with hunter2 = v; curr_selected = None }\n    | H3 -> { st with hunter3 = v; curr_selected = None }\n    | B -> { st with bear = v; curr_selected = None }\n\n  type t =\n    | PrePlay of pre_play_state\n    | Play of play_state\n    | Edit of edit_state\n    | Query of query_state\n\n  let init = Edit RomanWheel.\n    { bear = Obj.magic Center;\n      hunter1 = Obj.magic (SpokeVert(S1,L));\n      hunter2 = Obj.magic (SpokeVert(S1,Mid));\n      hunter3 = Obj.magic (SpokeVert(S1,R));\n      to_play = Obj.magic Player.White;\n      curr_selected = None;\n    }\n\nend\n\ntype rs = Model.t React.signal\ntype rf = ?step:React.step -> Model.t -> unit\ntype rp = rs * rf\n\nmodule Action = struct\n  type t =\n    | ClickMove of coq_BG_Move\n    | ClickPlayAsBlack\n    | ClickPlayAsWhite\n    | ClickToPlayBlack\n    | ClickToPlayWhite\n    | ClickPiece of Graph.coq_Vert\n    | ClickEdit\n    | ClickPlay\n    | ClickQuery \nend\n\nmodule Controller = struct\n  open Action\n\n  let tb_step (m : Model.play_state) : Model.play_state =\n    let Model.{ curr_state; curr_tb_strategy; tb_player; _ } = m in\n    let strat = Lazy.force curr_tb_strategy in\n    match strat with\n    | Coq_eloise_strategy(_,m,str) ->\n      let s = exec_move RomanWheel.coq_RomanWheel curr_state (Obj.magic m) in\n      Model.\n        { curr_state = s;\n          curr_tb_strategy = str;\n          tb_player = tb_player;\n          curr_selected = None;\n        }\n    | Coq_atom_strategy(s,res) ->\n      Model.\n        { curr_state = curr_state;\n          curr_tb_strategy = lazy (Coq_atom_strategy(s,res));\n          tb_player = tb_player;\n          curr_selected = None;\n        }\n    | _ -> failwith \"Error: tb_step called with Abelard strategy.\"\n\n  let click_move mv = function\n    | Model.Query { curr_state; _ } ->\n      let s = exec_move RomanWheel.coq_RomanWheel curr_state mv in\n      Model.Query\n        { curr_state = s;\n          curr_selected = None;\n        }\n    | _ -> failwith \"Error: click_move only triggerable in query mode.\"\n\n  let step m =\n    let strat = Lazy.force m.Model.curr_tb_strategy in\n    match strat with\n    | Coq_eloise_strategy(_,mv,str) ->\n      let s = exec_move RomanWheel.coq_RomanWheel m.curr_state (Obj.magic mv) in\n      Model.\n        { curr_state = s;\n          curr_tb_strategy = str;\n          tb_player = m.tb_player;\n          curr_selected = None;\n        }\n    | Coq_atom_strategy(s,res) ->\n      Model.\n        { curr_state = m.curr_state;\n          curr_tb_strategy = lazy (Coq_atom_strategy(s,res));\n          tb_player = m.tb_player;\n          curr_selected = None;\n        }\n    | _ -> failwith \"Error: Cannot step with Abelard strategy.\"\n\n  let click_black tb = function\n    | Model.Play { curr_state; _ } ->\n      Model.Play\n        { curr_state = curr_state;\n          curr_tb_strategy = rw_tb_strat Player.White (Obj.magic curr_state) tb;\n          tb_player = White;\n          curr_selected = None;\n        }\n    | Model.Edit { bear; hunter1; hunter2; hunter3; to_play; curr_selected; _ } ->\n      Model.Edit\n        { bear = bear;\n          hunter1 = hunter1;\n          hunter2 = hunter2;\n          hunter3 = hunter3;\n          to_play = to_play;\n          curr_selected = curr_selected\n        }\n    | Model.Query _ -> failwith \"Error: click_black should not be triggerable in query mode.\"\n    | Model.PrePlay { curr_state } ->\n      let m =\n        Model.{\n          curr_state = curr_state;\n          curr_tb_strategy = rw_tb_strat Player.White (Obj.magic curr_state) tb;\n          tb_player = White;\n          curr_selected = None\n        } in\n      Model.Play (if curr_state.to_play = White then step m else m)\n\n  let click_white tb = function\n    | Model.Play { curr_state; _ } ->\n      Model.Play\n        { curr_state = curr_state;\n          curr_tb_strategy = rw_tb_strat Player.Black (Obj.magic curr_state) tb;\n          tb_player = Black;\n          curr_selected = None;\n        }\n    | Model.Edit { bear; hunter1; hunter2; hunter3; to_play; curr_selected; _ } ->\n      Model.Edit\n        { bear = bear;\n          hunter1 = hunter1;\n          hunter2 = hunter2;\n          hunter3 = hunter3;\n          to_play = to_play;\n          curr_selected = curr_selected\n        }\n    | Model.Query _ -> failwith \"Error: click_white should not be triggerable in query mode.\"\n    | Model.PrePlay { curr_state } ->\n      let m =\n        Model.{\n          curr_state = curr_state;\n          curr_tb_strategy = rw_tb_strat Player.Black (Obj.magic curr_state) tb;\n          tb_player = Black;\n          curr_selected = None\n        } in\n      Model.Play (if curr_state.to_play = Black then step m else m)\n\n  (* a fake update to satisfy the react signal stuff *)\n  let strat_id strat =\n    let str = Lazy.force strat in\n    match str with\n    | Coq_eloise_strategy(s,m,str) -> lazy (Coq_eloise_strategy(s,m,str))\n    | Coq_abelard_strategy(s,strs) -> lazy (Coq_abelard_strategy(s,strs))\n    | Coq_atom_strategy(s,r) -> lazy (Coq_atom_strategy(s,r))\n\n  let click_piece v = function\n    | Model.Play { curr_state; curr_tb_strategy; tb_player; curr_selected } ->\n      begin match curr_selected with\n      | None ->\n        begin match tb_player with\n        | Player.White ->\n          if BearGame.is_bear RomanWheel.coq_RomanWheel curr_state v\n            then Model.Play\n              { curr_state = curr_state;\n                curr_tb_strategy = strat_id curr_tb_strategy;\n                tb_player = tb_player;\n                curr_selected = Some v;\n              }\n            else Model.Play\n              { curr_state = curr_state;\n                curr_tb_strategy = strat_id curr_tb_strategy;\n                tb_player = tb_player;\n                curr_selected = None;\n              }\n        | Player.Black ->\n          if BearGame.is_hunter RomanWheel.coq_RomanWheel curr_state v\n            then Model.Play\n              { curr_state = curr_state;\n                curr_tb_strategy = strat_id curr_tb_strategy;\n                tb_player = tb_player;\n                curr_selected = Some v;\n              }\n            else Model.Play\n              { curr_state = curr_state;\n                curr_tb_strategy = strat_id curr_tb_strategy;\n                tb_player = tb_player;\n                curr_selected = None;\n              }\n        end\n      | Some v' ->\n        let omv = BearGame.create_Move RomanWheel.coq_RomanWheel curr_state v' v in\n        begin match omv with\n        | Some mv ->\n          let strat = Lazy.force curr_tb_strategy in\n            begin match strat with\n            | Coq_abelard_strategy(_,strats) ->\n              let s = exec_move RomanWheel.coq_RomanWheel curr_state mv in\n              let str' = strats (Obj.magic mv) in Model.Play (tb_step (\n                { curr_state = s;\n                  curr_tb_strategy = str';\n                  tb_player = tb_player;\n                  curr_selected = None;\n                }))\n            | _ -> failwith \"Error: Abelard strategy expected when clicking piece.\"\n            end\n        | None -> Model.Play\n            { curr_state = curr_state;\n              curr_tb_strategy = strat_id curr_tb_strategy;\n              tb_player = tb_player;\n              curr_selected = None;\n            }\n        end\n      end\n    | Model.Edit st ->\n      begin match st.curr_selected with\n      | None ->\n        begin match Model.piece_of_vertex st v with\n        | Some p -> Model.Edit\n          { st with curr_selected = Some p }\n        | _ -> Model.Edit\n          { st with curr_selected = None }\n        end\n      | Some p ->\n        begin match Model.piece_of_vertex st v with\n        | None -> Model.Edit (Model.update_piece st p v)\n        | _ -> Model.Edit\n          { st with curr_selected = None }\n        end\n      end\n    | Model.Query { curr_state; curr_selected } ->\n      begin match curr_selected with\n      | None ->\n        begin match curr_state.to_play with\n        | Player.White ->\n          if List.mem v curr_state.hunters\n          then Model.Query\n            { curr_state = curr_state;\n              curr_selected = Some v;\n            }\n          else Model.Query\n            { curr_state = curr_state;\n              curr_selected = None;\n            }\n        | Player.Black ->\n          if v = curr_state.bear\n          then Model.Query\n            { curr_state = curr_state;\n              curr_selected = Some v;\n            }\n          else Model.Query\n            { curr_state = curr_state;\n              curr_selected = None;\n            }\n        end\n      | Some v' ->\n        let omv = BearGame.create_Move RomanWheel.coq_RomanWheel curr_state v' v in\n        begin match omv with\n        | Some mv ->\n          let s = exec_move RomanWheel.coq_RomanWheel curr_state mv in\n          Model.Query\n          { curr_state = s;\n            curr_selected = None;\n          }\n        | None -> Model.Query\n          { curr_state = curr_state;\n            curr_selected = None;\n          }\n        end\n      end\n  | Model.PrePlay st -> Model.PrePlay st\n\n  let click_edit = function\n    | Model.PrePlay st ->\n      let (h1,h2,h3) =\n        begin match st.curr_state.hunters with\n        | [h1;h2;h3] -> (h1,h2,h3)\n        | _ -> failwith \"Error: there should be exactly three hunters.\"\n        end in\n      Model.Edit {\n        bear = st.curr_state.bear;\n        hunter1 = h1;\n        hunter2 = h2;\n        hunter3 = h3;\n        to_play = st.curr_state.to_play;\n        curr_selected = None;\n      }\n    | Model.Play st ->\n      let (h1,h2,h3) =\n        begin match st.curr_state.hunters with\n        | [h1;h2;h3] -> (h1,h2,h3)\n        | _ -> failwith \"Error: there should be exactly three hunters.\"\n        end in\n      Model.Edit {\n        bear = st.curr_state.bear;\n        hunter1 = h1;\n        hunter2 = h2;\n        hunter3 = h3;\n        to_play = st.curr_state.to_play;\n        curr_selected = None;\n      }\n    | Model.Edit st -> Model.Edit st\n    | Model.Query st ->\n      let (h1,h2,h3) =\n        begin match st.curr_state.hunters with\n        | [h1;h2;h3] -> (h1,h2,h3)\n        | _ -> failwith \"Error: there should be exactly three hunters.\"\n        end in\n      Model.Edit {\n        bear = st.curr_state.bear;\n        hunter1 = h1;\n        hunter2 = h2;\n        hunter3 = h3;\n        to_play = st.curr_state.to_play;\n        curr_selected = None;\n      }\n\n  let click_play _tb = function\n    | Model.Play st -> Model.PrePlay\n      { curr_state = st.curr_state\n      }\n    | Model.Edit st ->\n      begin match make_RW_State st.to_play (Obj.magic st.bear) (Obj.magic st.hunter1) (Obj.magic st.hunter2) (Obj.magic st.hunter3) with\n      | Some s ->\n        Model.PrePlay\n        { curr_state = s;\n        }\n      | None -> failwith \"Error: failed to construct state.\"\n      end\n    | Model.Query st -> Model.PrePlay\n      { curr_state = st.curr_state\n      }\n    | Model.PrePlay st -> Model.PrePlay st\n\n  let click_query = function\n    | Model.PrePlay st -> Model.Query\n      { curr_state = st.curr_state;\n        curr_selected = None      \n      }\n    | Model.Play st -> Model.Query\n      { curr_state = st.curr_state;\n        curr_selected = None\n      }\n    | Model.Edit st ->\n      begin match make_RW_State st.to_play (Obj.magic st.bear) (Obj.magic st.hunter1) (Obj.magic st.hunter2) (Obj.magic st.hunter3) with\n      | Some s ->\n        Model.Query\n        { curr_state = s;\n          curr_selected = None;\n        }\n      | None -> failwith \"Error: failed to construct state.\"\n      end\n    | Model.Query st -> Model.Query st\n\n  let click_to_play_black = function\n    | Model.Edit st -> Model.Edit { st with to_play = Player.Black }\n    | _ -> failwith \"Error: click_to_play_black should not be triggerable outside of Edit mode.\"\n\n  let click_to_play_white = function\n    | Model.Edit st -> Model.Edit { st with to_play = Player.White }\n    | _ -> failwith \"Error: click_to_play_white should not be triggerable outside of Edit mode.\"\n\n  let update_func tb = function\n    | ClickMove m -> click_move m\n    | ClickPlayAsBlack -> click_black tb\n    | ClickPlayAsWhite -> click_white tb\n    | ClickPiece v -> click_piece v\n    | ClickEdit -> click_edit\n    | ClickPlay -> click_play tb\n    | ClickQuery -> click_query\n    | ClickToPlayBlack -> click_to_play_black\n    | ClickToPlayWhite -> click_to_play_white\n\n  let update (a : Action.t) ((rs,rf) : rp) tb =\n    let m = React.S.value rs in\n    let t = update_func tb a m in\n      rf t\n\nend\n\nmodule View = struct\n  \n  let circ =\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n      circle ~a:[a_stroke (`Color (\"black\", None)); a_fill `None; a_cx (100., Some `Px); (a_cy (100.0, Some `Px)); (a_r (75., Some `Px))] []\n    )\n\n  let black_style is_selected =\n    if is_selected\n    then Js_of_ocaml_tyxml.Tyxml_js.Svg.[a_r (7.5, Some `Px); a_stroke (`Color (\"gray\", None)); a_stroke_width (3.,None); a_fill (`Color (\"black\", None)) ]\n    else Js_of_ocaml_tyxml.Tyxml_js.Svg.[a_r (7.5, Some `Px); a_stroke (`Color (\"black\", None)); a_fill (`Color (\"black\", None)) ]\n\n  let white_style is_selected =\n    if is_selected\n    then Js_of_ocaml_tyxml.Tyxml_js.Svg.[a_r (7.5, Some `Px); a_stroke (`Color (\"gray\", None)); a_stroke_width (3.,None); a_fill (`Color (\"white\", None)) ]\n    else Js_of_ocaml_tyxml.Tyxml_js.Svg.[a_r (7.5, Some `Px); a_stroke (`Color (\"black\", None)) ; a_fill (`Color (\"white\", None)) ]\n\n  let transparent_style =\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.[a_r (7.5, Some `Px); a_stroke (`Color (\"transparent\", None)); a_fill (`Color (\"transparent\", None)) ]\n\n  let pos_style (x,y)  =\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.[ a_cx (x, Some `Px); a_cy (y, Some `Px) ]\n\n  let pure_pieces (rs,rf) tb x =\n    match x with\n    | Model.Play { curr_state; curr_selected; _ } ->\n      List.map (fun v ->\n        let pos = coords (Obj.magic v) in\n        let is_selected = Some v = curr_selected in\n        let click_piece _ = Controller.update (ClickPiece v) (rs, rf) tb; true in\n        let (click, circ_style) =\n          if v = curr_state.BearGame.bear\n            then (click_piece,black_style is_selected) else \n            if List.mem v (curr_state.BearGame.hunters)\n              then (click_piece,white_style is_selected)\n              else (click_piece,transparent_style) in\n        Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n          circle ~a:(a_onclick click :: circ_style @ pos_style pos) [])\n        ) (Graph.coq_Graph_Vert_enum RomanWheel.coq_RomanWheel)\n    | Model.Edit st ->\n      List.map (fun v ->\n        let pos = coords (Obj.magic v) in\n        let is_selected = Some v = Option.map (Model.vertex_of_piece st) st.curr_selected in\n        let click_piece _ = Controller.update (ClickPiece v) (rs, rf) tb; true in\n        let (click, circ_style) =\n          if v = st.bear\n            then (click_piece,black_style is_selected) else \n            if List.mem v [st.hunter1; st.hunter2; st.hunter3]\n              then (click_piece,white_style is_selected)\n              else (click_piece,transparent_style) in\n        Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n          circle ~a:(a_onclick click :: circ_style @ pos_style pos) [])\n        ) (Graph.coq_Graph_Vert_enum RomanWheel.coq_RomanWheel)\n    | Model.Query { curr_state; curr_selected } ->\n      List.map (fun v ->\n        let pos = coords (Obj.magic v) in\n        let is_selected = Some v = curr_selected in\n        let click_piece _ = Controller.update (ClickPiece v) (rs, rf) tb; true in\n        let (click, circ_style) =\n          if v = curr_state.BearGame.bear\n            then (click_piece,black_style is_selected) else \n            if List.mem v (curr_state.BearGame.hunters)\n              then (click_piece,white_style is_selected)\n              else (click_piece,transparent_style) in\n        Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n          circle ~a:(a_onclick click :: circ_style @ pos_style pos) [])\n        ) (Graph.coq_Graph_Vert_enum RomanWheel.coq_RomanWheel)\n    | Model.PrePlay { curr_state } ->\n      List.map (fun v ->\n        let pos = coords (Obj.magic v) in\n        let circ_style =\n          if v = curr_state.BearGame.bear\n            then black_style false else \n            if List.mem v (curr_state.BearGame.hunters)\n              then white_style false\n              else transparent_style in\n        Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n          circle ~a:(circ_style @ pos_style pos) [])\n        ) (Graph.coq_Graph_Vert_enum RomanWheel.coq_RomanWheel)\n\n  let pieces tb (rs,rf) =\n    let sig_pieces = ReactiveData.RList.from_signal (React.S.map (pure_pieces (rs,rf) tb) rs) in\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n      svg [Js_of_ocaml_tyxml.Tyxml_js.R.Svg.g sig_pieces]\n    )\n\n  let print_player pl =\n    match pl with\n    | Player.White -> \"White\"\n    | Player.Black -> \"Black\"\n\n  let pure_curr_res tb x =\n    match x with\n    | Model.Play { curr_state; _ } -> (\n      let text = (\n        match BearGame.atomic_res RomanWheel.coq_RomanWheel curr_state with\n        | Some res -> (\n          match res with\n          | Game.Win pl -> print_player pl ^ \" wins!\"\n          | Game.Draw -> \"Drawn.\"\n          )\n        | None -> \" \"\n        ) in\n      [Tyxml_js.Html.(a ~a:[a_class [\"currtext\"]] [txt text])]\n      )\n    | Model.Query s ->\n      let text = (\n        match ExtractQuery.query_RW_TB tb s.curr_state with\n        | Some (pl, n) -> (\n          match pl with\n          | Player.White -> \"White wins in \" ^ string_of_int n\n          | Player.Black -> \"Black wins in \" ^ string_of_int n\n          )\n        | None -> \"Drawn\"\n        ) in\n      [Tyxml_js.Html.(a ~a:[a_class [\"currtext\"]] [txt text])]\n    | _ -> []\n\n  let curr_res tb (rs,_) =\n    let sig_curr = ReactiveData.RList.from_signal (React.S.map (pure_curr_res tb) rs) in\n    Js_of_ocaml_tyxml.Tyxml_js.R.Html.p sig_curr\n\n  let pure_move_links (rs,rf) tb x =\n    match x with\n    | Model.Query { curr_state; _ } ->\n      let moves = enum_moves RomanWheel.coq_RomanWheel curr_state in\n      let move_tups = List.map (fun m ->\n        let s' = coq_RW_exec_move curr_state m in\n        (m, ExtractQuery.query_RW_TB tb s')\n      ) moves in\n      let move_tups_sorted = List.sort (fun (_,o1) (_,o2) ->\n        if OCamlTB.p_leb curr_state.to_play o1 o2 then 1 else -1\n        ) move_tups in\n      let clickmove m _ =\n        Controller.update (ClickMove m) (rs, rf) tb; true in\n      List.concat_map (fun (m,o) ->\n        let str =\n          begin match o with\n          | Some (pl, n) -> (\n            match pl with\n            | Player.White -> \"White wins in \" ^ string_of_int n\n            | Player.Black -> \"Black wins in \" ^ string_of_int n\n            )\n          | None -> \"Drawn\"\n          end in\n        let text = print_RW_move curr_state m ^ \": \" ^ str in\n        [Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick (clickmove m); a_class [\"whitewin\"]; a_style \"text-decoration: none\"] [txt text]);\n        Tyxml_js.Html.br ()\n        ]\n        ) move_tups_sorted\n    | _ -> []\n\n  let move_links (rs, rf) tb =\n    let vals = ReactiveData.RList.from_signal (React.S.map (pure_move_links (rs, rf) tb) rs) in\n    Js_of_ocaml_tyxml.Tyxml_js.R.Html.p vals\n\n  let normal_style = Tyxml_js.Html.a_class [\"normal\"]\n  let deselected = Tyxml_js.Html.a_class [\"deselected\"]\n  let selected = Tyxml_js.Html.a_class [\"selected\"]\n\n  let space () = Tyxml_js.Html.(a ~a:[] [txt \" \"])\n\n  let help_url = \"https://github.com/emarzion/coqtbgen/blob/master/bin/web/help.md\"\n  let help =\n    Tyxml_js.Html.(a ~a:[a_href help_url; a_target \"blank\"; a_class [\"normal-link\"]] [txt \"Help\"])  \n\n  let github_url = \"https://github.com/emarzion/coqtbgen\"\n  let github =\n    Tyxml_js.Html.(a ~a:[a_href github_url; a_target \"blank\"; a_class [\"normal-link\"]] [txt \"Github\"])  \n\n  let links =\n    Js_of_ocaml_tyxml.Tyxml_js.Html.p\n      [ help; space (); github ]\n\n  let pure_mode_toggles (rs,rf) tb x =\n    let (style_e, style_p, style_q) =\n      begin match x with\n      | Model.PrePlay _ -> (deselected, selected, deselected)\n      | Model.Play _ -> (deselected, selected, deselected)\n      | Model.Edit _ -> (selected, deselected, deselected)\n      | Model.Query _ -> (deselected, deselected, selected)\n      end in\n    let clickedit _ =\n      Controller.update ClickEdit (rs, rf) tb; true in\n    let clickplay _ =\n      Controller.update ClickPlay (rs, rf) tb; true in\n    let clickquery _ =\n      Controller.update ClickQuery (rs, rf) tb; true in\n    let edit = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick clickedit; style_e] [txt \"Edit\"]) in\n    let play = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick clickplay; style_p] [txt \"Play\"]) in\n    let query = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick clickquery; style_q] [txt \"Query\"]) in\n    let mode_text = Tyxml_js.Html.(a ~a:[normal_style] [txt \"Mode: \"]) in\n    [mode_text; space (); query; space (); edit; space (); play]\n\n  let mode_toggles (rs, rf) tb =\n    let vals = ReactiveData.RList.from_signal (React.S.map (pure_mode_toggles (rs, rf) tb) rs) in\n    Js_of_ocaml_tyxml.Tyxml_js.R.Html.p vals\n\n  let pure_player_toggles (rs,rf) tb x =\n    match x with\n    | Model.Play x ->\n      let tb_pl = Model.(x.tb_player) in\n      let pl_txt =\n        match tb_pl with\n        | Player.White -> \"Black\"\n        | Player.Black -> \"White\" in\n      let player_txt = Tyxml_js.Html.(a ~a:[normal_style] [txt pl_txt]) in\n      let playing_as_text = Tyxml_js.Html.(a ~a:[normal_style] [txt \"Playing as: \"]) in\n      [playing_as_text; player_txt]\n    | Model.Edit x ->\n      let curr_pl = Model.(x.to_play) in\n      let click_to_play_black _ =\n        Controller.update ClickToPlayBlack (rs, rf) tb; true in\n      let click_to_play_white _ =\n        Controller.update ClickToPlayWhite (rs, rf) tb; true in\n      let (curr_style_w, curr_style_b) =\n        match curr_pl with\n        | Player.White -> (selected, deselected)\n        | Player.Black -> (deselected, selected) in\n\n      let to_play_text = Tyxml_js.Html.(a ~a:[normal_style] [txt \"To play: \"]) in  \n      let to_play_black = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick click_to_play_black; curr_style_b] [txt \"black\"]) in\n      let to_play_white = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick click_to_play_white; curr_style_w] [txt \"white\"]) in\n\n      [ to_play_text; space (); to_play_black; space (); to_play_white ]\n    | Model.Query x ->\n      let pl = Model.((x.curr_state).to_play) in\n      let pl_txt =\n        match pl with\n        | Player.White -> \"White\"\n        | Player.Black -> \"Black\" in\n      let player_txt = Tyxml_js.Html.(a ~a:[normal_style] [txt pl_txt]) in\n      let to_play_text = Tyxml_js.Html.(a ~a:[normal_style] [txt \"To play: \"]) in\n      [to_play_text; player_txt]\n    | Model.PrePlay _ ->\n      let deselected = Tyxml_js.Html.a_class [\"deselected\"] in\n      let click_play_as_black _ =\n        Controller.update ClickPlayAsBlack (rs, rf) tb; true in\n      let click_play_as_white _ =\n        Controller.update ClickPlayAsWhite (rs, rf) tb; true in\n      let play_as_black = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick click_play_as_black; deselected] [txt \"black\"]) in\n      let play_as_white = Tyxml_js.Html.(a ~a:[a_href \"#\"; a_onclick click_play_as_white; deselected] [txt \"white\"]) in\n      let play_as_text = Tyxml_js.Html.(a ~a:[normal_style] [txt \"Play as: \"]) in\n      [ play_as_text; play_as_black; space (); play_as_white ]\n\n  let player_toggles (rs, rf) tb =\n    let vals = ReactiveData.RList.from_signal (React.S.map (pure_player_toggles (rs, rf) tb) rs) in\n    Js_of_ocaml_tyxml.Tyxml_js.R.Html.p vals\n\n  let board tb (rs,rf) =\n    Tyxml_js.(Html.svg\n      ~a:[Svg.a_viewBox(0.,0.,200.,200.); Svg.a_width (400., Some `Px); Svg.a_height (400., Some `Px)]\n      (circ :: lines @ arcs @ [pieces tb (rs,rf)])\n    )\n\n  let left_col (rs,rf) tb =\n    Tyxml_js.Html.div [\n      links;\n      mode_toggles (rs, rf) tb;\n      player_toggles (rs, rf) tb;\n      board tb (rs,rf);\n    ]\n\n  let right_col (rs,rf) tb =\n    Tyxml_js.Html.div [\n      curr_res tb (rs, rf);\n      move_links (rs,rf) tb;\n    ]\n\n  let draw_left tb rp node =\n    Dom.appendChild node (Tyxml_js.To_dom.of_node (left_col rp tb))\n\n  let draw_right tb rp node =\n    Dom.appendChild node (Tyxml_js.To_dom.of_node (right_col rp tb))\n\nend\n\nlet start tb rp node_l node_r =\n  View.draw_left tb rp node_l;\n  View.draw_right tb rp node_r;\n  Lwt.return ()\n   \nlet main mp _ =\n  let doc = Dom_html.document in\n  let parent_l =\n    Js.Opt.get (doc##getElementById(Js.string \"left-col\"))\n      (fun () -> assert false)\n    in\n  let parent_r =\n    Js.Opt.get (doc##getElementById(Js.string \"right-col\"))\n      (fun () -> assert false)\n    in\n  let rp = React.S.create Model.init in\n    start mp rp parent_l parent_r\n\nlet _ =\n  let mp = make_tb in\n  Js_of_ocaml_lwt.Lwt_js_events.onload () >>= (main (Obj.magic mp))\n\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Padding position. *)\ntype padty =\n  | Left   (* Text is left justified ('-' option).               *)\n  | Right  (* Text is right justified (no '-' option).           *)\n  | Zeros  (* Text is right justified by zeros (see '0' option). *)\n\n(***)\n\n(* Integer conversion. *)\ntype int_conv =\n  | Int_d | Int_pd | Int_sd        (*  %d | %+d | % d  *)\n  | Int_i | Int_pi | Int_si        (*  %i | %+i | % i  *)\n  | Int_x | Int_Cx                 (*  %x | %#x        *)\n  | Int_X | Int_CX                 (*  %X | %#X        *)\n  | Int_o | Int_Co                 (*  %o | %#o        *)\n  | Int_u                          (*  %u              *)\n  | Int_Cd | Int_Ci | Int_Cu       (*  %#d | %#i | %#u *)\n\n(* Float conversion. *)\ntype float_flag_conv =\n  | Float_flag_                    (* %[feEgGFhH] *)\n  | Float_flag_p                   (* %+[feEgGFhH] *)\n  | Float_flag_s                   (* % [feEgGFhH] *)\ntype float_kind_conv =\n  | Float_f                        (*  %f | %+f | % f  *)\n  | Float_e                        (*  %e | %+e | % e  *)\n  | Float_E                        (*  %E | %+E | % E  *)\n  | Float_g                        (*  %g | %+g | % g  *)\n  | Float_G                        (*  %G | %+G | % G  *)\n  | Float_F                        (*  %F | %+F | % F  *)\n  | Float_h                        (*  %h | %+h | % h  *)\n  | Float_H                        (*  %H | %+H | % H  *)\n  | Float_CF                       (*  %#F| %+#F| % #F *)\ntype float_conv = float_flag_conv * float_kind_conv\n\n(***)\n\n(* Char sets (see %[...]) are bitmaps implemented as 32-char strings. *)\ntype char_set = string\n\n(***)\n\n(* Counter used in Scanf. *)\ntype counter =\n  | Line_counter     (*  %l      *)\n  | Char_counter     (*  %n      *)\n  | Token_counter    (*  %N, %L  *)\n\n(***)\n\n(* Padding of strings and numbers. *)\ntype ('a, 'b) padding =\n  (* No padding (ex: \"%d\") *)\n  | No_padding  : ('a, 'a) padding\n  (* Literal padding (ex: \"%8d\") *)\n  | Lit_padding : padty * int -> ('a, 'a) padding\n  (* Padding as extra argument (ex: \"%*d\") *)\n  | Arg_padding : padty -> (int -> 'a, 'a) padding\n\n(* Some formats, such as %_d,\n   only accept an optional number as padding option (no extra argument) *)\ntype pad_option = int option\n\n(* Precision of floats and '0'-padding of integers. *)\ntype ('a, 'b) precision =\n  (* No precision (ex: \"%f\") *)\n  | No_precision : ('a, 'a) precision\n  (* Literal precision (ex: \"%.3f\") *)\n  | Lit_precision : int -> ('a, 'a) precision\n  (* Precision as extra argument (ex: \"%.*f\") *)\n  | Arg_precision : (int -> 'a, 'a) precision\n\n(* Some formats, such as %_f,\n   only accept an optional number as precision option (no extra argument) *)\ntype prec_option = int option\n\n(* see the Custom format combinator *)\ntype ('a, 'b, 'c) custom_arity =\n  | Custom_zero : ('a, string, 'a) custom_arity\n  | Custom_succ : ('a, 'b, 'c) custom_arity ->\n    ('a, 'x -> 'b, 'x -> 'c) custom_arity\n\n(***)\n\n(*        Relational format types\n\nIn the first format+gadts implementation, the type for %(..%) in the\nfmt GADT was as follows:\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option * ('d1, 'q1, 'd2, 'q2) reader_nb_unifier *\n    ('x, 'b, 'c, 'd1, 'q1, 'u) fmtty *\n    ('u, 'b, 'c, 'q1, 'e1, 'f) fmt ->\n      (('x, 'b, 'c, 'd2, 'q2, 'u) format6 -> 'x, 'b, 'c, 'd1, 'e1, 'f) fmt\n\nNotice that the 'u parameter in 'f position in the format argument\n(('x, .., 'u) format6 -> ..) is equal to the 'u parameter in 'a\nposition in the format tail (('u, .., 'f) fmt). This means that the\ntype of the expected format parameter depends of where the %(...%)\nare in the format string:\n\n  # Printf.printf \"%(%)\"\n  - : (unit, out_channel, unit, '_a, '_a, unit)\n      CamlinternalFormatBasics.format6 -> unit\n  = <fun>\n  # Printf.printf \"%(%)%d\"\n  - : (int -> unit, out_channel, unit, '_a, '_a, int -> unit)\n      CamlinternalFormatBasics.format6 -> int -> unit\n  = <fun>\n\nOn the contrary, the legacy typer gives a clever type that does not\ndepend on the position of %(..%) in the format string. For example,\n%(%) will have the polymorphic type ('a, 'b, 'c, 'd, 'd, 'a): it can\nbe concatenated to any format type, and only enforces the constraint\nthat its 'a and 'f parameters are equal (no format arguments) and 'd\nand 'e are equal (no reader argument).\n\nThe weakening of this parameter type in the GADT version broke user\ncode (in fact it essentially made %(...%) unusable except at the last\nposition of a format). In particular, the following would not work\nanymore:\n\n  fun sep ->\n    Format.printf \"foo%(%)bar%(%)baz\" sep sep\n\nAs the type-checker would require two *incompatible* types for the %(%)\nin different positions.\n\nThe solution to regain a general type for %(..%) is to generalize this\ntechnique, not only on the 'd, 'e parameters, but on all six\nparameters of a format: we introduce a \"relational\" type\n  ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n   'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\nwhose values are proofs that ('a1, .., 'f1) and ('a2, .., 'f2) morally\ncorrespond to the same format type: 'a1 is obtained from 'f1,'b1,'c1\nin the exact same way that 'a2 is obtained from 'f2,'b2,'c2, etc.\n\nFor example, the relation between two format types beginning with a Char\nparameter is as follows:\n\n| Char_ty :                                                 (* %c  *)\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\nIn the general case, the term structure of fmtty_rel is (almost[1])\nisomorphic to the fmtty of the previous implementation: every\nconstructor is re-read with a binary, relational type, instead of the\nprevious unary typing. fmtty can then be re-defined as the diagonal of\nfmtty_rel:\n\n  type ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n       ('a, 'b, 'c, 'd, 'e, 'f,\n        'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\n\nOnce we have this fmtty_rel type in place, we can give the more\ngeneral type to %(...%):\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n    ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\nWe accept any format (('g, 'h, 'i, 'j, 'k, 'l) format6) (this is\ncompletely unrelated to the type of the current format), but also\nrequire a proof that this format is in relation to another format that\nis concatenable to the format tail. When executing a %(...%) format\n(in camlinternalFormat.ml:make_printf or scanf.ml:make_scanf), we\ntranstype the format along this relation using the 'recast' function\nto transpose between related format types.\n\n  val recast :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1) fmt\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmt\n\nNOTE [1]: the typing of Format_subst_ty requires not one format type, but\ntwo, one to establish the link between the format argument and the\nfirst six parameters, and the other for the link between the format\nargument and the last six parameters.\n\n| Format_subst_ty :                                         (* %(...%) *)\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n     ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2) fmtty_rel\n\nWhen we generate a format AST, we generate exactly the same witness\nfor both relations, and the witness-conversion functions in\ncamlinternalFormat do rely on this invariant. For example, the\nfunction that proves that the relation is transitive\n\n  val trans :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n\ndoes assume that the two inputs have exactly the same term structure\n(and is only every used for argument witnesses of the\nFormat_subst_ty constructor).\n*)\n\n(* Type of a block used by the Format pretty-printer. *)\ntype block_type =\n  | Pp_hbox   (* Horizontal block no line breaking *)\n  | Pp_vbox   (* Vertical block each break leads to a new line *)\n  | Pp_hvbox  (* Horizontal-vertical block: same as vbox, except if this block\n                 is small enough to fit on a single line *)\n  | Pp_hovbox (* Horizontal or Vertical block: breaks lead to new line\n                 only when necessary to print the content of the block *)\n  | Pp_box    (* Horizontal or Indent block: breaks lead to new line\n                 only when necessary to print the content of the block, or\n                 when it leads to a new indentation of the current line *)\n  | Pp_fits   (* Internal usage: when a block fits on a single line *)\n\n(* Formatting element used by the Format pretty-printer. *)\ntype formatting_lit =\n  | Close_box                                           (* @]   *)\n  | Close_tag                                           (* @}   *)\n  | Break of string * int * int          (* @, | @  | @; | @;<> *)\n  | FFlush                                              (* @?   *)\n  | Force_newline                                       (* @\\n  *)\n  | Flush_newline                                       (* @.   *)\n  | Magic_size of string * int                          (* @<n> *)\n  | Escaped_at                                          (* @@   *)\n  | Escaped_percent                                     (* @%%  *)\n  | Scan_indic of char                                  (* @X   *)\n\n(* Formatting element used by the Format pretty-printer. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen =\n  | Open_tag : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @{   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n  | Open_box : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @[   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n\n(***)\n\n(* List of format type elements. *)\n(* In particular used to represent %(...%) and %{...%} contents. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n     ('a, 'b, 'c, 'd, 'e, 'f,\n      'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\nand ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel =\n  | Char_ty :                                                 (* %c  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | String_ty :                                               (* %s  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (string -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       string -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int_ty :                                                  (* %d  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int32_ty :                                                (* %ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int32 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int32 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Nativeint_ty :                                            (* %nd *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (nativeint -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       nativeint -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int64_ty :                                                (* %Ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int64 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int64 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Float_ty :                                                (* %f  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (float -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       float -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Bool_ty :                                                 (* %B  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (bool -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       bool -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  | Format_arg_ty :                                           (* %{...%} *)\n      ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n           fmtty_rel\n  | Format_subst_ty :                                         (* %(...%) *)\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2)\n           fmtty_rel\n\n  (* Printf and Format specific constructors. *)\n  | Alpha_ty :                                                (* %a  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'x -> 'c1) -> 'x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'x -> 'c2) -> 'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Theta_ty :                                                (* %t  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'c1) -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'c2) -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Any_ty :                                    (* Used for custom formats *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  (* Scanf specific constructor. *)\n  | Reader_ty :                                               (* %r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n  | Ignored_reader_ty :                                       (* %_r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n\n  | End_of_fmtty :\n      ('f1, 'b1, 'c1, 'd1, 'd1, 'f1,\n       'f2, 'b2, 'c2, 'd2, 'd2, 'f2) fmtty_rel\n\n(***)\n\n(* List of format elements. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmt =\n  | Char :                                                   (* %c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_char :                                              (* %C *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | String :                                                 (* %s *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_string :                                            (* %S *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int :                                                    (* %[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int32 :                                                  (* %l[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int32 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Nativeint :                                              (* %n[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, nativeint -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int64 :                                                  (* %L[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int64 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Float :                                                  (* %[feEgGFhH] *)\n      float_conv * ('x, 'y) padding * ('y, float -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Bool :                                                   (* %[bB] *)\n      ('x, bool -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Flush :                                                  (* %! *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | String_literal :                                         (* abc *)\n      string * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Char_literal :                                           (* x *)\n      char * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | Format_arg :                                             (* %{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Format_subst :                                           (* %(...%) *)\n      pad_option *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\n  (* Printf and Format specific constructor. *)\n  | Alpha :                                                  (* %a *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'x -> 'c) -> 'x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Theta :                                                  (* %t *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'c) -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Format specific constructor: *)\n  | Formatting_lit :                                         (* @_ *)\n      formatting_lit * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Formatting_gen :                                             (* @_ *)\n      ('a1, 'b, 'c, 'd1, 'e1, 'f1) formatting_gen *\n      ('f1, 'b, 'c, 'e1, 'e2, 'f2) fmt -> ('a1, 'b, 'c, 'd1, 'e2, 'f2) fmt\n\n  (* Scanf specific constructors: *)\n  | Reader :                                                 (* %r *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x -> 'a, 'b, 'c, ('b -> 'x) -> 'd, 'e, 'f) fmt\n  | Scan_char_set :                                          (* %[...] *)\n      pad_option * char_set * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (string -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_get_counter :                                       (* %[nlNL] *)\n      counter * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (int -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_next_char :                                         (* %0c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Ignored_param :                                          (* %_ *)\n      ('a, 'b, 'c, 'd, 'y, 'x) ignored * ('x, 'b, 'c, 'y, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Custom printing format (PR#6452, GPR#140)\n\n     We include a type Custom of \"custom converters\", where an\n     arbitrary function can be used to convert one or more\n     arguments. There is no syntax for custom converters, it is only\n     intended for custom processors that wish to rely on the\n     stdlib-defined format GADTs.\n\n     For instance a pre-processor could choose to interpret strings\n     prefixed with [\"!\"] as format strings where [%{{ ... }}] is\n     a special form to pass a to_string function, so that one could\n     write:\n\n     {[\n       type t = { x : int; y : int }\n\n       let string_of_t t = Printf.sprintf \"{ x = %d; y = %d }\" t.x t.y\n\n       Printf.printf !\"t = %{{string_of_t}}\" { x = 42; y = 42 }\n     ]}\n  *)\n  | Custom :\n      ('a, 'x, 'y) custom_arity * (unit -> 'x) * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      ('y, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* end of a format specification *)\n  | End_of_format :\n        ('f, 'b, 'c, 'e, 'e, 'f) fmt\n\n(***)\n\n(* Type for ignored parameters (see \"%_\"). *)\nand ('a, 'b, 'c, 'd, 'e, 'f) ignored =\n  | Ignored_char :                                           (* %_c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_char :                                      (* %_C *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_string :                                         (* %_s *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_string :                                    (* %_S *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int :                                            (* %_d *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int32 :                                          (* %_ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_nativeint :                                      (* %_nd *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int64 :                                          (* %_Ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_float :                                          (* %_f *)\n      pad_option * prec_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_bool :                                           (* %_B *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_arg :                                     (* %_{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty ->\n        ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_subst :                                   (* %_(...%) *)\n      pad_option * ('a, 'b, 'c, 'd, 'e, 'f) fmtty ->\n        ('a, 'b, 'c, 'd, 'e, 'f) ignored\n  | Ignored_reader :                                         (* %_r *)\n      ('a, 'b, 'c, ('b -> 'x) -> 'd, 'd, 'a) ignored\n  | Ignored_scan_char_set :                                  (* %_[...] *)\n      pad_option * char_set -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_get_counter :                               (* %_[nlNL] *)\n      counter -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_next_char :                                 (* %_0c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n\nand ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n  Format of ('a, 'b, 'c, 'd, 'e, 'f) fmt * string\n\nlet rec erase_rel : type a b c d e f g h i j k l .\n  (a, b, c, d, e, f,\n   g, h, i, j, k, l) fmtty_rel -> (a, b, c, d, e, f) fmtty\n= function\n  | Char_ty rest ->\n    Char_ty (erase_rel rest)\n  | String_ty rest ->\n    String_ty (erase_rel rest)\n  | Int_ty rest ->\n    Int_ty (erase_rel rest)\n  | Int32_ty rest ->\n    Int32_ty (erase_rel rest)\n  | Int64_ty rest ->\n    Int64_ty (erase_rel rest)\n  | Nativeint_ty rest ->\n    Nativeint_ty (erase_rel rest)\n  | Float_ty rest ->\n    Float_ty (erase_rel rest)\n  | Bool_ty rest ->\n    Bool_ty (erase_rel rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, erase_rel rest)\n  | Format_subst_ty (ty1, _ty2, rest) ->\n    Format_subst_ty (ty1, ty1, erase_rel rest)\n  | Alpha_ty rest ->\n    Alpha_ty (erase_rel rest)\n  | Theta_ty rest ->\n    Theta_ty (erase_rel rest)\n  | Any_ty rest ->\n    Any_ty (erase_rel rest)\n  | Reader_ty rest ->\n    Reader_ty (erase_rel rest)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (erase_rel rest)\n  | End_of_fmtty -> End_of_fmtty\n\n(******************************************************************************)\n                         (* Format type concatenation *)\n\n(* Concatenate two format types. *)\n(* Used by:\n   * reader_nb_unifier_of_fmtty to count readers in an fmtty,\n   * Scanf.take_fmtty_format_readers to extract readers inside %(...%),\n   * CamlinternalFormat.fmtty_of_ignored_format to extract format type. *)\n\n(*\nlet rec concat_fmtty : type a b c d e f g h .\n    (a, b, c, d, e, f) fmtty ->\n    (f, b, c, e, g, h) fmtty ->\n    (a, b, c, d, g, h) fmtty =\n*)\nlet rec concat_fmtty :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n       g1 j1 g2 j2\n  .\n    (g1, b1, c1, j1, d1, a1,\n     g2, b2, c2, j2, d2, a2) fmtty_rel ->\n    (a1, b1, c1, d1, e1, f1,\n     a2, b2, c2, d2, e2, f2) fmtty_rel ->\n    (g1, b1, c1, j1, e1, f1,\n     g2, b2, c2, j2, e2, f2) fmtty_rel =\nfun fmtty1 fmtty2 -> match fmtty1 with\n  | Char_ty rest ->\n    Char_ty (concat_fmtty rest fmtty2)\n  | String_ty rest ->\n    String_ty (concat_fmtty rest fmtty2)\n  | Int_ty rest ->\n    Int_ty (concat_fmtty rest fmtty2)\n  | Int32_ty rest ->\n    Int32_ty (concat_fmtty rest fmtty2)\n  | Nativeint_ty rest ->\n    Nativeint_ty (concat_fmtty rest fmtty2)\n  | Int64_ty rest ->\n    Int64_ty (concat_fmtty rest fmtty2)\n  | Float_ty rest ->\n    Float_ty (concat_fmtty rest fmtty2)\n  | Bool_ty rest ->\n    Bool_ty (concat_fmtty rest fmtty2)\n  | Alpha_ty rest ->\n    Alpha_ty (concat_fmtty rest fmtty2)\n  | Theta_ty rest ->\n    Theta_ty (concat_fmtty rest fmtty2)\n  | Any_ty rest ->\n    Any_ty (concat_fmtty rest fmtty2)\n  | Reader_ty rest ->\n    Reader_ty (concat_fmtty rest fmtty2)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (concat_fmtty rest fmtty2)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, concat_fmtty rest fmtty2)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty1, ty2, concat_fmtty rest fmtty2)\n  | End_of_fmtty -> fmtty2\n\n(******************************************************************************)\n                           (* Format concatenation *)\n\n(* Concatenate two formats. *)\nlet rec concat_fmt : type a b c d e f g h .\n    (a, b, c, d, e, f) fmt ->\n    (f, b, c, e, g, h) fmt ->\n    (a, b, c, d, g, h) fmt =\nfun fmt1 fmt2 -> match fmt1 with\n  | String (pad, rest) ->\n    String (pad, concat_fmt rest fmt2)\n  | Caml_string (pad, rest) ->\n    Caml_string (pad, concat_fmt rest fmt2)\n\n  | Int (iconv, pad, prec, rest) ->\n    Int (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int32 (iconv, pad, prec, rest) ->\n    Int32 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Nativeint (iconv, pad, prec, rest) ->\n    Nativeint (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int64 (iconv, pad, prec, rest) ->\n    Int64 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Float (fconv, pad, prec, rest) ->\n    Float (fconv, pad, prec, concat_fmt rest fmt2)\n\n  | Char (rest) ->\n    Char (concat_fmt rest fmt2)\n  | Caml_char rest ->\n    Caml_char (concat_fmt rest fmt2)\n  | Bool (pad, rest) ->\n    Bool (pad, concat_fmt rest fmt2)\n  | Alpha rest ->\n    Alpha (concat_fmt rest fmt2)\n  | Theta rest ->\n    Theta (concat_fmt rest fmt2)\n  | Custom (arity, f, rest) ->\n    Custom (arity, f, concat_fmt rest fmt2)\n  | Reader rest ->\n    Reader (concat_fmt rest fmt2)\n  | Flush rest ->\n    Flush (concat_fmt rest fmt2)\n\n  | String_literal (str, rest) ->\n    String_literal (str, concat_fmt rest fmt2)\n  | Char_literal (chr, rest) ->\n    Char_literal   (chr, concat_fmt rest fmt2)\n\n  | Format_arg (pad, fmtty, rest) ->\n    Format_arg   (pad, fmtty, concat_fmt rest fmt2)\n  | Format_subst (pad, fmtty, rest) ->\n    Format_subst (pad, fmtty, concat_fmt rest fmt2)\n\n  | Scan_char_set (width_opt, char_set, rest) ->\n    Scan_char_set (width_opt, char_set, concat_fmt rest fmt2)\n  | Scan_get_counter (counter, rest) ->\n    Scan_get_counter (counter, concat_fmt rest fmt2)\n  | Scan_next_char (rest) ->\n    Scan_next_char (concat_fmt rest fmt2)\n  | Ignored_param (ign, rest) ->\n    Ignored_param (ign, concat_fmt rest fmt2)\n\n  | Formatting_lit (fmting_lit, rest) ->\n    Formatting_lit (fmting_lit, concat_fmt rest fmt2)\n  | Formatting_gen (fmting_gen, rest) ->\n    Formatting_gen (fmting_gen, concat_fmt rest fmt2)\n\n  | End_of_format ->\n    fmt2\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Gabriel Scherer, projet Partout, INRIA Paris-Saclay        *)\n(*                                                                        *)\n(*   Copyright 2020 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* CamlinternalAtomic is a dependency of Stdlib, so it is compiled with\n   -nopervasives. *)\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* We are not reusing ('a ref) directly to make it easier to reason\n   about atomicity if we wish to: even in a sequential implementation,\n   signals and other asynchronous callbacks might break atomicity. *)\ntype 'a t = {mutable v: 'a}\n\nlet make v = {v}\nlet get r = r.v\nlet set r v = r.v <- v\n\n(* The following functions are set to never be inlined: Flambda is\n   allowed to move surrounding code inside the critical section,\n   including allocations. *)\n\nlet[@inline never] exchange r v =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  r.v <- v;\n  (* END ATOMIC *)\n  cur\n\nlet[@inline never] compare_and_set r seen v =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  if cur == seen then (\n    r.v <- v;\n    (* END ATOMIC *)\n    true\n  ) else\n    false\n\nlet[@inline never] fetch_and_add r n =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  r.v <- (cur + n);\n  (* END ATOMIC *)\n  cur\n\nlet incr r = ignore (fetch_and_add r 1)\nlet decr r = ignore (fetch_and_add r (-1))\n","(* TyXML\n * http://www.ocsigen.org/tyxml\n * Copyright (C) 2004 by Thorsten Ohl <ohl@physik.uni-wuerzburg.de>\n * Copyright (C) 2007 by Vincent Balat, Gabriel Kerneis\n * Copyright (C) 2010 by Cecile Herbelin\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1301, USA.\n*)\n\nmodule Make_with_wrapped_functions\n\n    (Xml : Xml_sigs.T)\n    (C : Html_sigs.Wrapped_functions with module Xml = Xml)\n    (Svg : Svg_sigs.T with module Xml := Xml) =\n\nstruct\n\n  module Xml = Xml\n\n  module W = Xml.W\n\n  module Info = struct\n    let content_type = \"text/html\"\n    let alternative_content_types = [\"application/xhtml+xml\";\"application/xml\";\"text/xml\"]\n    let version = \"HTML5-draft\"\n    let standard = \"http://www.w3.org/TR/html5/\"\n    let namespace = \"http://www.w3.org/1999/xhtml\"\n    let doctype =\n      Xml_print.compose_doctype \"html\" []\n    let emptytags =\n      [ \"area\"; \"base\"; \"br\"; \"col\"; \"command\"; \"embed\"; \"hr\"; \"img\";\n        \"input\"; \"keygen\"; \"link\"; \"meta\"; \"param\"; \"source\"; \"wbr\" ]\n  end\n\n  type 'a wrap = 'a W.t\n  type 'a list_wrap = 'a W.tlist\n\n  type uri = Xml.uri\n  let string_of_uri = Xml.string_of_uri\n  let uri_of_string = Xml.uri_of_string\n\n  type image_candidate =\n    [ `Url of uri\n    | `Url_width of uri * Html_types.number\n    | `Url_pixel of uri * Html_types.float_number ]\n\n  type 'a attrib = Xml.attrib\n\n  let to_xmlattribs x = x\n  let to_attrib x = x\n\n  (* VB *)\n  let float_attrib = Xml.float_attrib\n\n  let int_attrib = Xml.int_attrib\n\n  let string_attrib = Xml.string_attrib\n\n  let uri_attrib a s = Xml.uri_attrib a s\n\n  let space_sep_attrib = Xml.space_sep_attrib\n\n  let comma_sep_attrib = Xml.comma_sep_attrib\n\n  let user_attrib f name v = Xml.string_attrib name (W.fmap f v)\n\n  let bool_attrib = user_attrib C.string_of_bool\n\n  let constant_attrib a () =\n    string_attrib a (W.return a)\n\n  let linktypes_attrib name x =\n    user_attrib C.string_of_linktypes name x\n\n  let mediadesc_attrib name x =\n    user_attrib C.string_of_mediadesc name x\n\n  let srcset_attrib name x =\n    user_attrib C.string_of_srcset name x\n\n  (* Core: *)\n  let a_class = space_sep_attrib \"class\"\n\n  let a_id = string_attrib \"id\"\n\n  let a_user_data name = string_attrib (\"data-\" ^ name)\n\n  let a_title = string_attrib \"title\"\n\n  (* I18N: *)\n  let a_xml_lang = string_attrib \"xml:lang\"\n  let a_lang = string_attrib \"lang\"\n\n  (* Style: *)\n  let a_style = string_attrib \"style\"\n\n  let a_property = string_attrib \"property\"\n\n  (* Events: *)\n  let a_onabort = Xml.event_handler_attrib \"onabort\"\n  let a_onafterprint = Xml.event_handler_attrib \"onafterprint\"\n  let a_onbeforeprint = Xml.event_handler_attrib \"onbeforeprint\"\n  let a_onbeforeunload = Xml.event_handler_attrib \"onbeforeunload\"\n  let a_onblur = Xml.event_handler_attrib \"onblur\"\n  let a_oncanplay = Xml.event_handler_attrib \"oncanplay\"\n  let a_oncanplaythrough = Xml.event_handler_attrib \"oncanplaythrough\"\n  let a_onchange = Xml.event_handler_attrib \"onchange\"\n  let a_onclose = Xml.event_handler_attrib \"onclose\"\n  let a_ondurationchange = Xml.event_handler_attrib \"ondurationchange\"\n  let a_onemptied = Xml.event_handler_attrib \"onemptied\"\n  let a_onended = Xml.event_handler_attrib \"onended\"\n  let a_onerror = Xml.event_handler_attrib \"onerror\"\n  let a_onfocus = Xml.event_handler_attrib \"onfocus\"\n  let a_onformchange = Xml.event_handler_attrib \"onformchange\"\n  let a_onforminput = Xml.event_handler_attrib \"onforminput\"\n  let a_onhashchange = Xml.event_handler_attrib \"onhashchange\"\n  let a_oninput = Xml.event_handler_attrib \"oninput\"\n  let a_oninvalid = Xml.event_handler_attrib \"oninvalid\"\n  let a_onoffline = Xml.event_handler_attrib \"onoffline\"\n  let a_ononline = Xml.event_handler_attrib \"ononline\"\n  let a_onpause = Xml.event_handler_attrib \"onpause\"\n  let a_onplay = Xml.event_handler_attrib \"onplay\"\n  let a_onplaying = Xml.event_handler_attrib \"onplaying\"\n  let a_onpagehide = Xml.event_handler_attrib \"onpagehide\"\n  let a_onpageshow = Xml.event_handler_attrib \"onpageshow\"\n  let a_onpopstate = Xml.event_handler_attrib \"onpopstate\"\n  let a_onprogress = Xml.event_handler_attrib \"onprogress\"\n  let a_onratechange = Xml.event_handler_attrib \"onratechange\"\n  let a_onreadystatechange = Xml.event_handler_attrib \"onreadystatechange\"\n  let a_onredo = Xml.event_handler_attrib \"onredo\"\n  let a_onresize = Xml.event_handler_attrib \"onresize\"\n  let a_onscroll = Xml.event_handler_attrib \"onscroll\"\n  let a_onseeked = Xml.event_handler_attrib \"onseeked\"\n  let a_onseeking = Xml.event_handler_attrib \"onseeking\"\n  let a_onselect = Xml.event_handler_attrib \"onselect\"\n  let a_onshow = Xml.event_handler_attrib \"onshow\"\n  let a_onstalled = Xml.event_handler_attrib \"onstalled\"\n  let a_onstorage = Xml.event_handler_attrib \"onstorage\"\n  let a_onsubmit = Xml.event_handler_attrib \"onsubmit\"\n  let a_onsuspend = Xml.event_handler_attrib \"onsuspend\"\n  let a_ontimeupdate = Xml.event_handler_attrib \"ontimeupdate\"\n  let a_onundo = Xml.event_handler_attrib \"onundo\"\n  let a_onunload = Xml.event_handler_attrib \"onunload\"\n  let a_onvolumechange = Xml.event_handler_attrib \"onvolumechange\"\n  let a_onwaiting = Xml.event_handler_attrib \"onwaiting\"\n  let a_onload = Xml.event_handler_attrib \"onload\"\n  let a_onloadeddata = Xml.event_handler_attrib \"onloadeddata\"\n  let a_onloadedmetadata = Xml.event_handler_attrib \"onloadedmetadata\"\n  let a_onloadstart = Xml.event_handler_attrib \"onloadstart\"\n  let a_onmessage = Xml.event_handler_attrib \"onmessage\"\n  let a_onmousewheel = Xml.event_handler_attrib \"onmousewheel\"\n\n  (** Javascript mouse events *)\n  let a_onclick = Xml.mouse_event_handler_attrib \"onclick\"\n  let a_oncontextmenu = Xml.mouse_event_handler_attrib \"oncontextmenu\"\n  let a_ondblclick = Xml.mouse_event_handler_attrib \"ondblclick\"\n  let a_ondrag = Xml.mouse_event_handler_attrib \"ondrag\"\n  let a_ondragend = Xml.mouse_event_handler_attrib \"ondragend\"\n  let a_ondragenter = Xml.mouse_event_handler_attrib \"ondragenter\"\n  let a_ondragleave = Xml.mouse_event_handler_attrib \"ondragleave\"\n  let a_ondragover = Xml.mouse_event_handler_attrib \"ondragover\"\n  let a_ondragstart = Xml.mouse_event_handler_attrib \"ondragstart\"\n  let a_ondrop = Xml.mouse_event_handler_attrib \"ondrop\"\n  let a_onmousedown = Xml.mouse_event_handler_attrib \"onmousedown\"\n  let a_onmouseup = Xml.mouse_event_handler_attrib \"onmouseup\"\n  let a_onmouseover = Xml.mouse_event_handler_attrib \"onmouseover\"\n  let a_onmousemove = Xml.mouse_event_handler_attrib \"onmousemove\"\n  let a_onmouseout = Xml.mouse_event_handler_attrib \"onmouseout\"\n\n  (** Javascript touch events *)\n  let a_ontouchstart = Xml.touch_event_handler_attrib \"ontouchstart\"\n  let a_ontouchend = Xml.touch_event_handler_attrib \"ontouchend\"\n  let a_ontouchmove = Xml.touch_event_handler_attrib \"ontouchmove\"\n  let a_ontouchcancel = Xml.touch_event_handler_attrib \"ontouchcancel\"\n\n  (** Javascript keyboard events *)\n  let a_onkeypress = Xml.keyboard_event_handler_attrib \"onkeypress\"\n  let a_onkeydown = Xml.keyboard_event_handler_attrib \"onkeydown\"\n  let a_onkeyup = Xml.keyboard_event_handler_attrib \"onkeyup\"\n\n  (* Other Attributes *)\n  let a_version = string_attrib \"version\"\n\n  let a_xmlns x =\n    user_attrib C.string_of_big_variant \"xmlns\" x\n\n  let a_manifest = uri_attrib \"manifest\"\n\n  let a_cite = uri_attrib \"cite\"\n\n  let a_xml_space x =\n    user_attrib C.string_of_big_variant \"xml:space\" x\n\n  let a_accesskey c =\n    user_attrib C.string_of_character \"accesskey\" c\n\n  let a_charset = string_attrib \"charset\"\n\n  let a_accept_charset = space_sep_attrib \"accept-charset\"\n\n  let a_accept = comma_sep_attrib \"accept\"\n\n  let a_href = uri_attrib \"href\"\n\n  let a_hreflang = string_attrib \"hreflang\"\n\n  let a_download file =\n    user_attrib (C.unoption_string) \"download\" file\n\n  let a_rel = linktypes_attrib \"rel\"\n\n  let a_tabindex = int_attrib \"tabindex\"\n\n  let a_mime_type = string_attrib \"type\"\n\n  let a_alt = string_attrib \"alt\"\n\n  let a_height p = int_attrib \"height\" p\n\n  let a_src = uri_attrib \"src\"\n\n  let a_width p = int_attrib \"width\" p\n\n  let a_label_for = string_attrib \"for\"\n  let a_for = a_label_for\n\n  let a_output_for = space_sep_attrib \"for\"\n  let a_for_list = a_output_for\n\n  let a_selected =\n    constant_attrib \"selected\"\n\n  let a_text_value = string_attrib \"value\"\n\n  let a_int_value = int_attrib \"value\"\n\n  let a_value = string_attrib \"value\"\n\n  let a_float_value = float_attrib \"value\"\n\n  let a_action = uri_attrib \"action\"\n\n  let a_method x =\n    user_attrib C.string_of_big_variant \"method\" x\n\n  let a_formmethod x = user_attrib C.string_of_big_variant \"formmethod\" x\n\n  let a_enctype = string_attrib \"enctype\"\n\n  let a_checked =\n    constant_attrib \"checked\"\n\n  let a_disabled =\n    constant_attrib \"disabled\"\n\n  let a_readonly =\n    constant_attrib \"readonly\"\n\n  let a_maxlength = int_attrib \"maxlength\"\n\n  let a_minlength = int_attrib \"minlength\"\n\n  let a_name = string_attrib \"name\"\n\n  let a_allowfullscreen =\n    constant_attrib \"allowfullscreen\"\n\n  let a_allowpaymentrequest =\n    constant_attrib \"allowpaymentrequest\"\n\n  let a_referrerpolicy x =\n    user_attrib C.string_of_referrerpolicy \"referrerpolicy\" x\n\n  let a_autocomplete x =\n    user_attrib C.string_of_autocomplete \"autocomplete\" x\n\n  let a_async =\n    constant_attrib \"async\"\n\n  let a_autofocus =\n    constant_attrib \"autofocus\"\n\n  let a_autoplay =\n    constant_attrib \"autoplay\"\n\n  let a_muted =\n    constant_attrib \"muted\"\n\n  let a_crossorigin x =\n    user_attrib C.string_of_big_variant \"crossorigin\" x\n\n  let a_integrity = string_attrib \"integrity\"\n\n  let a_mediagroup = string_attrib \"mediagroup\"\n\n  let a_challenge = string_attrib \"challenge\"\n\n  let a_contenteditable ce =\n    bool_attrib \"contenteditable\" ce\n\n  let a_contextmenu = string_attrib \"contextmenu\"\n\n  let a_controls =\n    constant_attrib \"controls\"\n\n  let a_dir x =\n    user_attrib C.string_of_big_variant \"dir\" x\n\n  let a_draggable d =\n    bool_attrib \"draggable\" d\n\n  let a_form = string_attrib \"form\"\n\n  let a_formaction = uri_attrib \"formaction\"\n\n  let a_formenctype = string_attrib \"formenctype\"\n\n  let a_formnovalidate =\n    constant_attrib \"formnovalidate\"\n\n  let a_formtarget = string_attrib \"formtarget\"\n\n  let a_hidden =\n    constant_attrib \"hidden\"\n\n  let a_high = float_attrib \"high\"\n\n  let a_icon = uri_attrib \"icon\"\n\n  let a_ismap =\n    constant_attrib \"ismap\"\n\n  let a_keytype = string_attrib \"keytype\"\n\n  let a_list = string_attrib \"list\"\n\n  let a_loop =\n    constant_attrib \"loop\"\n\n  let a_low = float_attrib \"low\"\n\n  let a_max = float_attrib \"max\"\n\n  let a_input_max = user_attrib C.string_of_number_or_datetime \"max\"\n\n  let a_min = float_attrib \"min\"\n\n  let a_input_min = user_attrib C.string_of_number_or_datetime \"min\"\n\n  let a_inputmode x =\n    user_attrib C.string_of_big_variant \"inputmode\" x\n\n  let a_novalidate =\n    constant_attrib \"novalidate\"\n\n  let a_open =\n    constant_attrib \"open\"\n\n  let a_optimum = float_attrib \"optimum\"\n\n  let a_pattern = string_attrib \"pattern\"\n\n  let a_placeholder = string_attrib \"placeholder\"\n\n  let a_poster = uri_attrib \"poster\"\n\n  let a_preload x =\n    user_attrib C.string_of_big_variant \"preload\" x\n\n  let a_pubdate =\n    constant_attrib \"pubdate\"\n\n  let a_radiogroup = string_attrib \"radiogroup\"\n\n  let a_required =\n    constant_attrib \"required\"\n\n  let a_reversed =\n    constant_attrib \"reserved\"\n\n  let a_sandbox x =\n    user_attrib C.string_of_sandbox \"sandbox\" x\n\n  let a_spellcheck sc =\n    bool_attrib \"spellcheck\" sc\n\n  let a_scoped =\n    constant_attrib \"scoped\"\n\n  let a_seamless =\n    constant_attrib \"seamless\"\n\n  let a_sizes sizes =\n    user_attrib C.string_of_sizes \"sizes\" sizes\n\n  let a_span = int_attrib \"span\"\n\n  (*let a_srcdoc*)\n  let a_srclang = string_attrib \"xml:lang\"\n\n  let a_srcset = srcset_attrib \"srcset\"\n\n  let a_img_sizes = comma_sep_attrib \"sizes\"\n\n  let a_start = int_attrib \"start\"\n\n  let a_step step =\n    user_attrib C.string_of_step \"step\" step\n\n  let a_translate x =\n    user_attrib C.string_of_big_variant \"translate\" x\n  \n  let a_wrap x =\n    user_attrib C.string_of_big_variant \"wrap\" x\n\n  let a_size = int_attrib \"size\"\n\n  let a_input_type it =\n    user_attrib C.string_of_input_type \"type\" it\n\n  let a_menu_type x =\n    user_attrib C.string_of_big_variant \"type\" x\n\n  let a_command_type x =\n    user_attrib C.string_of_big_variant \"type\" x\n\n  let a_button_type bt =\n    user_attrib C.string_of_input_type \"type\" bt\n\n  let a_script_type sc = user_attrib C.string_of_script_type \"type\" sc\n\n  let a_multiple =\n    constant_attrib \"multiple\"\n\n  let a_cols = int_attrib \"cols\"\n\n  let a_rows = int_attrib \"rows\"\n\n  let a_summary = string_attrib \"summary\"\n\n  let a_align x =\n    user_attrib C.string_of_big_variant \"align\" x\n\n  let a_axis = string_attrib \"axis\"\n\n  let a_colspan = int_attrib \"colspan\"\n\n  let a_headers = space_sep_attrib \"headers\"\n\n  let a_rowspan = int_attrib \"rowspan\"\n\n  let a_scope x =\n    user_attrib C.string_of_big_variant \"scope\" x\n\n  let a_border = int_attrib \"border\"\n\n  let a_rules x =\n    user_attrib C.string_of_big_variant \"rules\" x\n\n  let a_char c =\n    user_attrib C.string_of_character \"char\" c\n\n  let a_data = uri_attrib \"data\"\n\n  let a_codetype = string_attrib \"codetype\"\n\n  let a_frameborder x =\n    user_attrib C.string_of_big_variant \"frameborder\" x\n\n  let a_marginheight = int_attrib \"marginheight\"\n\n  let a_marginwidth = int_attrib \"marginwidth\"\n\n  let a_scrolling x =\n    user_attrib C.string_of_big_variant \"scrolling\" x\n\n  let a_target = string_attrib \"target\"\n\n  let a_content = string_attrib \"content\"\n\n  let a_http_equiv = string_attrib \"http-equiv\"\n\n  let a_media = mediadesc_attrib \"media\"\n\n  (* ARIA *)\n\n  let a_role = space_sep_attrib \"role\"\n\n  let a_aria name = space_sep_attrib (\"aria-\" ^ name)\n\n  type 'a elt = Xml.elt\n\n  type ('a, 'b) nullary = ?a: (('a attrib) list) -> unit -> 'b elt\n\n  type ('a, 'b, 'c) unary = ?a: (('a attrib) list) -> 'b elt wrap -> 'c elt\n\n  type ('a, 'b, 'c) star =\n    ?a: (('a attrib) list) -> ('b elt) list_wrap -> 'c elt\n\n  let terminal tag ?a () = Xml.leaf ?a tag\n\n  let unary tag ?a elt =\n    Xml.node ?a tag (W.singleton elt)\n\n  let star tag ?a elts = Xml.node ?a tag elts\n\n  let plus tag ?a elt elts =\n    Xml.node ?a tag (W.cons elt elts)\n\n  let option_cons opt elts =\n    match opt with\n    | None -> elts\n    | Some x -> W.cons x elts\n\n  let body = star \"body\"\n\n  let head = plus \"head\"\n\n  let title = unary \"title\"\n\n  let html ?a head body =\n    let content = W.cons head (W.singleton body) in\n    Xml.node ?a \"html\" content\n\n  let footer = star \"footer\"\n\n  let header = star \"header\"\n\n  let section = star \"section\"\n\n  let nav = star \"nav\"\n\n  let txt s = Xml.pcdata s\n  let pcdata = txt\n\n  let entity = Xml.entity\n\n  let space () = entity \"nbsp\"\n\n  let cdata = Xml.cdata\n\n  let cdata_script = Xml.cdata_script\n\n  let cdata_style = Xml.cdata_style\n\n  let h1 = star \"h1\"\n\n  let h2 = star \"h2\"\n\n  let h3 = star \"h3\"\n\n  let h4 = star \"h4\"\n\n  let h5 = star \"h5\"\n\n  let h6 = star \"h6\"\n\n  let hgroup = star \"hgroup\"\n\n  let address = star \"address\"\n\n  let blockquote = star \"blockquote\"\n\n  let dialog = star \"dialog\"\n\n  let div = star \"div\"\n\n  let p = star \"p\"\n\n  let pre = star \"pre\"\n\n  let abbr = star \"abbr\"\n\n  let br = terminal \"br\"\n\n  let cite = star \"cite\"\n\n  let code = star \"code\"\n\n  let dfn = star \"dfn\"\n\n  let em = star \"em\"\n\n  let kbd = star \"kbd\"\n\n  let q = star \"q\"\n\n  let samp = star \"samp\"\n\n  let span = star \"span\"\n\n  let strong = star \"strong\"\n\n  let time = star \"time\"\n\n  let var = star \"var\"\n\n  let a = star \"a\"\n\n  let dl = star \"dl\"\n\n  let ol = star \"ol\"\n\n  let ul = star \"ul\"\n\n  let dd = star \"dd\"\n\n  let dt = star \"dt\"\n\n  let li = star \"li\"\n\n  let hr = terminal \"hr\"\n\n  let b = star \"b\"\n\n  let i = star \"i\"\n\n  let u = star \"u\"\n\n  let small = star \"small\"\n\n  let sub = star \"sub\"\n\n  let sup = star \"sup\"\n\n  let mark = star \"mark\"\n\n  let rp = star \"rp\"\n\n  let rt = star \"rt\"\n\n  let ruby = star \"ruby\"\n\n  let wbr = terminal \"wbr\"\n\n  (* VB *)\n  type shape = [ | `Rect | `Circle | `Poly | `Default ]\n\n  let bdo ~dir ?(a = []) elts = Xml.node ~a: ((a_dir dir) :: a) \"bdo\" elts\n\n  let a_datetime = string_attrib \"datetime\"\n\n  let a_shape x =\n    user_attrib C.string_of_big_variant \"shape\" x\n\n  let a_coords coords =\n    user_attrib C.string_of_numbers \"coords\" coords\n\n  let a_usemap = string_attrib \"usemap\"\n\n  let a_defer =\n    constant_attrib \"defer\"\n\n  let a_label = string_attrib \"label\"\n\n  let area ~alt ?(a = []) () = Xml.leaf ~a: ((a_alt alt) :: a) \"area\"\n\n  let map = star \"map\"\n\n  let del = star \"del\"\n\n  let ins = star \"ins\"\n\n  let script = unary \"script\"\n\n  let noscript = star \"noscript\"\n\n  let template = star \"template\"\n\n  let article = star \"article\"\n\n  let aside = star \"aside\"\n\n  let main = star \"main\"\n\n  let video_audio name ?src ?srcs ?(a = []) elts =\n    let a =\n      match src with\n      | None -> a\n      | Some uri -> (a_src uri) :: a\n    in\n    match srcs with\n    | None -> Xml.node name ~a elts\n    | Some srcs -> Xml.node name ~a (W.append srcs elts)\n\n  let audio = video_audio \"audio\"\n\n  let video = video_audio \"video\"\n\n  let canvas = star \"canvas\"\n\n  let command ~label ?(a = []) () =\n    Xml.leaf ~a: ((a_label label) :: a) \"command\"\n\n  let menu ?children ?a () =\n    let children = match children with\n      | None -> W.nil ()\n      | Some (`Lis l)\n      | Some (`Flows l) -> l in\n    Xml.node ?a \"menu\" children\n\n  let embed = terminal \"embed\"\n\n  let source = terminal \"source\"\n\n  let meter = star \"meter\"\n\n  let output_elt = star \"output\"\n\n  let form = star \"form\"\n\n  let svg ?(a = []) children =\n    Svg.toelt (Svg.svg ~a children)\n\n  let input = terminal \"input\"\n\n  let keygen = terminal \"keygen\"\n\n  let label = star \"label\"\n\n  let option = unary \"option\"\n\n  let select = star \"select\"\n\n  let textarea = unary \"textarea\"\n\n  let button = star \"button\"\n\n  let datalist ?children ?a () =\n    let children = match children with\n      | None -> W.nil ()\n      | Some (`Options x | `Phras x) -> x in\n    Xml.node ?a \"datalist\" children\n\n  let progress = star \"progress\"\n\n  let legend = star \"legend\"\n\n  let details summary ?a children =\n    plus \"details\" ?a summary children\n\n  let summary = star \"summary\"\n\n  let fieldset ?legend ?a elts =\n    Xml.node ?a \"fieldset\" (option_cons legend elts)\n\n  let optgroup ~label ?(a = []) elts =\n    Xml.node ~a: ((a_label label) :: a) \"optgroup\" elts\n\n  let figcaption = star \"figcaption\"\n  let figure ?figcaption ?a elts =\n    let content = match figcaption with\n      | None -> elts\n      | Some (`Top c) -> W.cons c elts\n      | Some (`Bottom c) -> W.append elts (W.singleton c)\n    in\n    Xml.node ?a \"figure\" content\n\n  let caption = star \"caption\"\n\n  let tablex ?caption ?columns ?thead ?tfoot ?a elts =\n    let content = option_cons thead (option_cons tfoot elts) in\n    let content = match columns with\n      | None -> content\n      | Some columns -> W.append columns content in\n    let content = option_cons caption content in\n    Xml.node ?a \"table\" content\n\n  let table = tablex\n\n  let td = star \"td\"\n\n  let th = star \"th\"\n\n  let tr = star \"tr\"\n\n  let colgroup = star \"colgroup\"\n\n  let col = terminal \"col\"\n\n  let thead = star \"thead\"\n\n  let tbody = star \"tbody\"\n\n  let tfoot = star \"tfoot\"\n\n  let iframe = star \"iframe\"\n\n  let object_ ?params ?(a = []) elts =\n    let elts = match params with\n      | None -> elts\n      | Some e -> W.append e elts in\n    Xml.node ~a \"object\" elts\n\n  let param = terminal \"param\"\n\n  let img ~src ~alt ?(a = []) () =\n    let a = (a_src src) :: (a_alt alt) :: a in\n    Xml.leaf ~a \"img\"\n\n  let picture ~img ?a elts =\n    let tail_node = W.cons img (W.nil ()) in\n    let content = W.append elts tail_node in\n    Xml.node ?a \"picture\" content\n\n  let meta = terminal \"meta\"\n\n  let style ?(a = []) elts = Xml.node ~a \"style\" elts\n\n  let link ~rel ~href ?(a = []) () =\n    Xml.leaf ~a: ((a_rel rel) :: (a_href href) :: a) \"link\"\n\n  let base = terminal \"base\"\n\n  (******************************************************************)\n  (* Conversion from and to Xml module *)\n  let tot x = x\n\n  let totl x = x\n\n  let toelt x = x\n\n  let toeltl x = x\n\n  type doc  = [ `Html ] elt\n  let doc_toelt x = x\n\n  module I = Xml_stream.Import(Xml)\n  let of_seq s = totl @@ I.of_seq s\n\n  module Unsafe = struct\n\n    let data s = Xml.encodedpcdata s\n\n    let leaf tag ?a () = Xml.leaf ?a tag\n\n    let node tag ?a elts = Xml.node ?a tag elts\n\n    let coerce_elt x = x\n\n    let float_attrib = Xml.float_attrib\n\n    let int_attrib = Xml.int_attrib\n\n    let string_attrib = Xml.string_attrib\n\n    let uri_attrib a s = Xml.uri_attrib a s\n\n    let space_sep_attrib = Xml.space_sep_attrib\n\n    let comma_sep_attrib = Xml.comma_sep_attrib\n\n  end\n\nend\n\nmodule Wrapped_functions\n    (Xml : Xml_sigs.T with type ('a,'b) W.ft = 'a -> 'b) =\nstruct\n\n  module Xml = Xml\n\n  let string_of_sandbox_token = function\n    | `Allow_forms -> \"allow-forms\"\n    | `Allow_pointer_lock -> \"allow-pointer-lock\"\n    | `Allow_popups -> \"allow-popups\"\n    | `Allow_top_navigation -> \"allow-top-navigation\"\n    | `Allow_same_origin -> \"allow-same-origin\"\n    | `Allow_script -> \"allow-script\"\n\n  let string_of_linktype = function\n    | `Alternate -> \"alternate\"\n    | `Archives -> \"archives\"\n    | `Author -> \"author\"\n    | `Bookmark -> \"bookmark\"\n    | `Canonical -> \"canonical\"\n    | `Dns_prefetch -> \"dns-prefetch\"\n    | `External -> \"external\"\n    | `First -> \"first\"\n    | `Help -> \"help\"\n    | `Icon -> \"icon\"\n    | `Index -> \"index\"\n    | `Last -> \"last\"\n    | `License -> \"license\"\n    | `Manifest -> \"manifest\"\n    | `Me -> \"me\"\n    | `Modulepreload -> \"modulepreload\"\n    | `Next -> \"next\"\n    | `Nofollow -> \"nofollow\"\n    | `Noopener -> \"noopener\"\n    | `Noreferrer -> \"noreferrer\"\n    | `Opener -> \"opener\"\n    | `Pingback -> \"pingback\"\n    | `Preconnect -> \"preconnect\"\n    | `Prefetch -> \"prefetch\"\n    | `Preload -> \"preload\"\n    | `Prerender -> \"prerender\"\n    | `Prev -> \"prev\"\n    | `Search -> \"search\"\n    | `Stylesheet -> \"stylesheet\"\n    | `Sidebar -> \"sidebar\"\n    | `Tag -> \"tag\"\n    | `Up -> \"up\"\n    | `Other s -> s\n\n  let string_of_mediadesc_token =\n    function\n    | `All -> \"all\"\n    | `Aural -> \"aural\"\n    | `Braille -> \"braille\"\n    | `Embossed -> \"embossed\"\n    | `Handheld -> \"handheld\"\n    | `Print -> \"print\"\n    | `Projection -> \"projection\"\n    | `Screen -> \"screen\"\n    | `Speech -> \"speech\"\n    | `Tty -> \"tty\"\n    | `Tv -> \"tv\"\n    | `Raw_mediadesc s -> s\n\n  let string_of_referrerpolicy = function\n    | `Empty -> \"\"\n    | `No_referrer -> \"no-referrer\"\n    | `No_referrer_when_downgrade -> \"no-referrer-when-downgrade\"\n    | `Origin -> \"origin\"\n    | `Origin_when_cross_origin -> \"origin-when-cross-origin\"\n    | `Same_origin -> \"same-origin\"\n    | `Strict_origin -> \"strict-origin\"\n    | `Strict_origin_when_cross_origin -> \"strict-origin-when-cross-origin\"\n    | `Unsafe_url -> \"unsafe-url\"\n\n  let string_of_big_variant = function\n    | `Anonymous -> \"anonymous\"\n    | `Async -> \"async\"\n    | `Autofocus -> \"autofocus\"\n    | `Autoplay -> \"autoplay\"\n    | `Checked -> \"checked\"\n    | `Defer -> \"defer\"\n    | `Disabled -> \"disabled\"\n    | `Muted -> \"muted\"\n    | `ReadOnly -> \"readonly\"\n    | `Rect -> \"rect\"\n    | `Selected -> \"selected\"\n    | `Use_credentials -> \"use-credentials\"\n    | `W3_org_1999_xhtml -> \"http://www.w3.org/1999/xhtml\"\n    | `All -> \"all\"\n    | `Preserve -> \"preserve\"\n    | `Default -> \"default\"\n    | `Controls -> \"controls\"\n    | `Ltr -> \"ltr\"\n    | `Rtl -> \"rtl\"\n    | `Get -> \"GET\"\n    | `Post -> \"POST\"\n    | `Formnovalidate -> \"formnovalidate\"\n    | `Hidden -> \"hidden\"\n    | `Ismap -> \"ismap\"\n    | `Loop -> \"loop\"\n    | `Novalidate -> \"novalidate\"\n    | `Open -> \"open\"\n    | `None -> \"none\"\n    | `Metadata -> \"metadata\"\n    | `Audio -> \"audio\"\n    | `Pubdate -> \"pubdate\"\n    | `Required -> \"required\"\n    | `Reversed -> \"reserved\"\n    | `Scoped -> \"scoped\"\n    | `Seamless -> \"seamless\"\n    | `Any -> \"any\"\n    | `Soft -> \"soft\"\n    | `Hard -> \"hard\"\n    | `Context -> \"context\"\n    | `Toolbar -> \"toolbar\"\n    | `Command -> \"command\"\n    | `Checkbox -> \"checkbox\"\n    | `Radio -> \"radio\"\n    | `Multiple -> \"multiple\"\n    | `Left -> \"left\"\n    | `Right -> \"right\"\n    | `Justify -> \"justify\"\n    | `Char -> \"char\"\n    | `Row -> \"row\"\n    | `Col -> \"col\"\n    | `Rowgroup -> \"rowgroup\"\n    | `Colgroup -> \"colgroup\"\n    | `Groups -> \"groups\"\n    | `Rows -> \"rows\"\n    | `Cols -> \"cols\"\n    | `Zero -> \"0\"\n    | `One -> \"1\"\n    | `Yes -> \"yes\"\n    | `No -> \"no\"\n    | `Auto -> \"auto\"\n    | `Circle -> \"circle\"\n    | `Poly -> \"poly\"\n    | `Alternate -> \"alternate\"\n    | `Archives -> \"archives\"\n    | `Author -> \"author\"\n    | `Bookmark -> \"bookmark\"\n    | `External -> \"external\"\n    | `First -> \"first\"\n    | `Help -> \"help\"\n    | `Icon -> \"icon\"\n    | `Index -> \"index\"\n    | `Last -> \"last\"\n    | `License -> \"license\"\n    | `Next -> \"next\"\n    | `Nofollow -> \"nofollow\"\n    | `Noreferrer -> \"noreferrer\"\n    | `Pingback -> \"pingback\"\n    | `Prefetch -> \"prefetch\"\n    | `Prev -> \"prev\"\n    | `Search -> \"search\"\n    | `Stylesheet -> \"stylesheet\"\n    | `Sidebar -> \"sidebar\"\n    | `Tag -> \"tag\"\n    | `Up -> \"up\"\n    | `Verbatim -> \"verbatim\"\n    | `Latin -> \"latin\"\n    | `Latin_name -> \"latin-name\"\n    | `Latin_prose -> \"latin-prose\"\n    | `Full_width_latin -> \"full-width-latin\"\n    | `Kana -> \"kana\"\n    | `Katakana -> \"katakana\"\n    | `Numeric -> \"numeric\"\n    | `Tel -> \"tel\"\n    | `Email -> \"email\"\n    | `Url -> \"url\"\n    | `Text -> \"text\"\n    | `Decimal -> \"decimal\"\n    | `Other s -> s\n\n  let string_of_input_type = function\n    | `Button -> \"button\"\n    | `Checkbox -> \"checkbox\"\n    | `Color -> \"color\"\n    | `Date -> \"date\"\n    | `Datetime -> \"datetime\"\n    | `Datetime_local -> \"datetime-local\"\n    | `Email -> \"email\"\n    | `File -> \"file\"\n    | `Hidden -> \"hidden\"\n    | `Image -> \"image\"\n    | `Month -> \"month\"\n    | `Number -> \"number\"\n    | `Password -> \"password\"\n    | `Radio -> \"radio\"\n    | `Range -> \"range\"\n    | `Readonly -> \"readonly\"\n    | `Reset -> \"reset\"\n    | `Search -> \"search\"\n    | `Submit -> \"submit\"\n    | `Tel -> \"tel\"\n    | `Text -> \"text\"\n    | `Time -> \"time\"\n    | `Url -> \"url\"\n    | `Week -> \"week\"\n\n  let string_of_script_type = function\n  | `Javascript -> \"application/javascript\"\n  | `Module -> \"module\"\n  | `Mime s -> s\n\n  let string_of_number_or_datetime = function\n    | `Number n -> string_of_int n\n    | `Datetime t -> t\n\n  let string_of_character = String.make 1\n\n  let string_of_number = string_of_int\n\n  let string_of_bool = string_of_bool\n\n  let onoff_of_bool = function\n    | false -> \"off\"\n    | true -> \"on\"\n\n  let unoption_string = function\n    | Some x -> x\n    | None -> \"\"\n\n  let string_of_step = function\n    | Some x -> Xml_print.string_of_number x\n    | None -> \"any\"\n\n  let string_of_sizes = function\n    | Some l ->\n      String.concat \" \"\n        (List.map (fun (x, y) -> Printf.sprintf \"%dx%d\" x y) l)\n    | None ->\n      \"any\"\n\n  let string_of_sandbox l =\n    String.concat \" \" (List.map string_of_sandbox_token l)\n\n  let string_of_numbers l =\n    String.concat \",\" (List.map string_of_number l)\n\n  let string_of_mediadesc l =\n    String.concat \", \" (List.map string_of_mediadesc_token l)\n\n  let string_of_linktypes l =\n    String.concat \" \" (List.map string_of_linktype l)\n\n  type image_candidate =\n    [ `Url of Xml.uri\n    | `Url_width of Xml.uri * Html_types.number\n    | `Url_pixel of Xml.uri * Html_types.float_number ]\n\n  let string_of_srcset (l : [< image_candidate] list) =\n    let f = function\n    | `Url url -> Xml.string_of_uri url\n    | `Url_width (url, v) ->\n      Printf.sprintf \"%s %sw\" (Xml.string_of_uri url) (string_of_number v)\n    | `Url_pixel (url, v) ->\n      Printf.sprintf \"%s %sx\" (Xml.string_of_uri url) (Xml_print.string_of_number v)\n    in\n    String.concat \", \" (List.map f l)\n\n  let string_of_autocomplete (l : Html_types.autocomplete_option) =\n    match l with\n    | `On | `Tokens [] -> \"on\"\n    | `Off -> \"off\"\n    | `Tokens strs -> String.concat \" \" strs\n\nend\n\nmodule Make\n    (Xml : Xml_sigs.T with type ('a, 'b) W.ft = 'a -> 'b)\n    (Svg : Svg_sigs.T with module Xml := Xml) =\n  Make_with_wrapped_functions(Xml)(Wrapped_functions(Xml))(Svg)\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* An alias for the type of lists. *)\ntype 'a t = 'a list = [] | (::) of 'a * 'a list\n\n(* List operations *)\n\nlet rec length_aux len = function\n    [] -> len\n  | _::l -> length_aux (len + 1) l\n\nlet length l = length_aux 0 l\n\nlet cons a l = a::l\n\nlet hd = function\n    [] -> failwith \"hd\"\n  | a::_ -> a\n\nlet tl = function\n    [] -> failwith \"tl\"\n  | _::l -> l\n\nlet nth l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> failwith \"nth\"\n    | a::l -> if n = 0 then a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet nth_opt l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> None\n    | a::l -> if n = 0 then Some a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet append = (@)\n\nlet rec rev_append l1 l2 =\n  match l1 with\n    [] -> l2\n  | a :: l -> rev_append l (a :: l2)\n\nlet rev l = rev_append l []\n\nlet rec init_tailrec_aux acc i n f =\n  if i >= n then acc\n  else init_tailrec_aux (f i :: acc) (i+1) n f\n\nlet rec init_aux i n f =\n  if i >= n then []\n  else\n    let r = f i in\n    r :: init_aux (i+1) n f\n\nlet rev_init_threshold =\n  match Sys.backend_type with\n  | Sys.Native | Sys.Bytecode -> 10_000\n  (* We don't know the size of the stack, better be safe and assume it's\n     small. *)\n  | Sys.Other _ -> 50\n\nlet init len f =\n  if len < 0 then invalid_arg \"List.init\" else\n  if len > rev_init_threshold then rev (init_tailrec_aux [] 0 len f)\n  else init_aux 0 len f\n\nlet rec flatten = function\n    [] -> []\n  | l::r -> l @ flatten r\n\nlet concat = flatten\n\nlet rec map f = function\n    [] -> []\n  | a::l -> let r = f a in r :: map f l\n\nlet rec mapi i f = function\n    [] -> []\n  | a::l -> let r = f i a in r :: mapi (i + 1) f l\n\nlet mapi f l = mapi 0 f l\n\nlet rev_map f l =\n  let rec rmap_f accu = function\n    | [] -> accu\n    | a::l -> rmap_f (f a :: accu) l\n  in\n  rmap_f [] l\n\n\nlet rec iter f = function\n    [] -> ()\n  | a::l -> f a; iter f l\n\nlet rec iteri i f = function\n    [] -> ()\n  | a::l -> f i a; iteri (i + 1) f l\n\nlet iteri f l = iteri 0 f l\n\nlet rec fold_left f accu l =\n  match l with\n    [] -> accu\n  | a::l -> fold_left f (f accu a) l\n\nlet rec fold_right f l accu =\n  match l with\n    [] -> accu\n  | a::l -> f a (fold_right f l accu)\n\nlet rec map2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> let r = f a1 a2 in r :: map2 f l1 l2\n  | (_, _) -> invalid_arg \"List.map2\"\n\nlet rev_map2 f l1 l2 =\n  let rec rmap2_f accu l1 l2 =\n    match (l1, l2) with\n    | ([], []) -> accu\n    | (a1::l1, a2::l2) -> rmap2_f (f a1 a2 :: accu) l1 l2\n    | (_, _) -> invalid_arg \"List.rev_map2\"\n  in\n  rmap2_f [] l1 l2\n\n\nlet rec iter2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> ()\n  | (a1::l1, a2::l2) -> f a1 a2; iter2 f l1 l2\n  | (_, _) -> invalid_arg \"List.iter2\"\n\nlet rec fold_left2 f accu l1 l2 =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> fold_left2 f (f accu a1 a2) l1 l2\n  | (_, _) -> invalid_arg \"List.fold_left2\"\n\nlet rec fold_right2 f l1 l2 accu =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> f a1 a2 (fold_right2 f l1 l2 accu)\n  | (_, _) -> invalid_arg \"List.fold_right2\"\n\nlet rec for_all p = function\n    [] -> true\n  | a::l -> p a && for_all p l\n\nlet rec exists p = function\n    [] -> false\n  | a::l -> p a || exists p l\n\nlet rec for_all2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> true\n  | (a1::l1, a2::l2) -> p a1 a2 && for_all2 p l1 l2\n  | (_, _) -> invalid_arg \"List.for_all2\"\n\nlet rec exists2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> false\n  | (a1::l1, a2::l2) -> p a1 a2 || exists2 p l1 l2\n  | (_, _) -> invalid_arg \"List.exists2\"\n\nlet rec mem x = function\n    [] -> false\n  | a::l -> compare a x = 0 || mem x l\n\nlet rec memq x = function\n    [] -> false\n  | a::l -> a == x || memq x l\n\nlet rec assoc x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if compare a x = 0 then b else assoc x l\n\nlet rec assoc_opt x = function\n    [] -> None\n  | (a,b)::l -> if compare a x = 0 then Some b else assoc_opt x l\n\nlet rec assq x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if a == x then b else assq x l\n\nlet rec assq_opt x = function\n    [] -> None\n  | (a,b)::l -> if a == x then Some b else assq_opt x l\n\nlet rec mem_assoc x = function\n  | [] -> false\n  | (a, _) :: l -> compare a x = 0 || mem_assoc x l\n\nlet rec mem_assq x = function\n  | [] -> false\n  | (a, _) :: l -> a == x || mem_assq x l\n\nlet rec remove_assoc x = function\n  | [] -> []\n  | (a, _ as pair) :: l ->\n      if compare a x = 0 then l else pair :: remove_assoc x l\n\nlet rec remove_assq x = function\n  | [] -> []\n  | (a, _ as pair) :: l -> if a == x then l else pair :: remove_assq x l\n\nlet rec find p = function\n  | [] -> raise Not_found\n  | x :: l -> if p x then x else find p l\n\nlet rec find_opt p = function\n  | [] -> None\n  | x :: l -> if p x then Some x else find_opt p l\n\nlet rec find_map f = function\n  | [] -> None\n  | x :: l ->\n     begin match f x with\n       | Some _ as result -> result\n       | None -> find_map f l\n     end\n\nlet find_all p =\n  let rec find accu = function\n  | [] -> rev accu\n  | x :: l -> if p x then find (x :: accu) l else find accu l in\n  find []\n\nlet filter = find_all\n\nlet filteri p l =\n  let rec aux i acc = function\n  | [] -> rev acc\n  | x::l -> aux (i + 1) (if p i x then x::acc else acc) l\n  in\n  aux 0 [] l\n\nlet filter_map f =\n  let rec aux accu = function\n    | [] -> rev accu\n    | x :: l ->\n        match f x with\n        | None -> aux accu l\n        | Some v -> aux (v :: accu) l\n  in\n  aux []\n\nlet concat_map f l =\n  let rec aux f acc = function\n    | [] -> rev acc\n    | x :: l ->\n       let xs = f x in\n       aux f (rev_append xs acc) l\n  in aux f [] l\n\nlet fold_left_map f accu l =\n  let rec aux accu l_accu = function\n    | [] -> accu, rev l_accu\n    | x :: l ->\n        let accu, x = f accu x in\n        aux accu (x :: l_accu) l in\n  aux accu [] l\n\nlet partition p l =\n  let rec part yes no = function\n  | [] -> (rev yes, rev no)\n  | x :: l -> if p x then part (x :: yes) no l else part yes (x :: no) l in\n  part [] [] l\n\nlet partition_map p l =\n  let rec part left right = function\n  | [] -> (rev left, rev right)\n  | x :: l ->\n     begin match p x with\n       | Either.Left v -> part (v :: left) right l\n       | Either.Right v -> part left (v :: right) l\n     end\n  in\n  part [] [] l\n\nlet rec split = function\n    [] -> ([], [])\n  | (x,y)::l ->\n      let (rx, ry) = split l in (x::rx, y::ry)\n\nlet rec combine l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> (a1, a2) :: combine l1 l2\n  | (_, _) -> invalid_arg \"List.combine\"\n\n(** sorting *)\n\nlet rec merge cmp l1 l2 =\n  match l1, l2 with\n  | [], l2 -> l2\n  | l1, [] -> l1\n  | h1 :: t1, h2 :: t2 ->\n      if cmp h1 h2 <= 0\n      then h1 :: merge cmp t1 l2\n      else h2 :: merge cmp l1 t2\n\n\nlet stable_sort cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 <= 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s = if cmp x1 x2 <= 0 then [x1; x2] else [x2; x1] in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          if cmp x1 x2 <= 0 then\n            if cmp x2 x3 <= 0 then [x1; x2; x3]\n            else if cmp x1 x3 <= 0 then [x1; x3; x2]\n            else [x3; x1; x2]\n          else if cmp x1 x3 <= 0 then [x2; x1; x3]\n          else if cmp x2 x3 <= 0 then [x2; x3; x1]\n          else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = rev_sort n1 l in\n        let s2, tl = rev_sort n2 l2 in\n        (rev_merge_rev s1 s2 [], tl)\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s = if cmp x1 x2 > 0 then [x1; x2] else [x2; x1] in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          if cmp x1 x2 > 0 then\n            if cmp x2 x3 > 0 then [x1; x2; x3]\n            else if cmp x1 x3 > 0 then [x1; x3; x2]\n            else [x3; x1; x2]\n          else if cmp x1 x3 > 0 then [x2; x1; x3]\n          else if cmp x2 x3 > 0 then [x2; x3; x1]\n          else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = sort n1 l in\n        let s2, tl = sort n2 l2 in\n        (rev_merge s1 s2 [], tl)\n  in\n  let len = length l in\n  if len < 2 then l else fst (sort len l)\n\n\nlet sort = stable_sort\nlet fast_sort = stable_sort\n\n(* Note: on a list of length between about 100000 (depending on the minor\n   heap size and the type of the list) and Sys.max_array_size, it is\n   actually faster to use the following, but it might also use more memory\n   because the argument list cannot be deallocated incrementally.\n\n   Also, there seems to be a bug in this code or in the\n   implementation of obj_truncate.\n\nexternal obj_truncate : 'a array -> int -> unit = \"caml_obj_truncate\"\n\nlet array_to_list_in_place a =\n  let l = Array.length a in\n  let rec loop accu n p =\n    if p <= 0 then accu else begin\n      if p = n then begin\n        obj_truncate a p;\n        loop (a.(p-1) :: accu) (n-1000) (p-1)\n      end else begin\n        loop (a.(p-1) :: accu) n (p-1)\n      end\n    end\n  in\n  loop [] (l-1000) l\n\n\nlet stable_sort cmp l =\n  let a = Array.of_list l in\n  Array.stable_sort cmp a;\n  array_to_list_in_place a\n\n*)\n\n\n(** sorting + removing duplicates *)\n\nlet sort_uniq cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge t1 t2 (h1::accu)\n        else if c < 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge_rev t1 t2 (h1::accu)\n        else if c > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then [x1] else if c < 0 then [x1; x2] else [x2; x1]\n        in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x2] else if c < 0 then [x2; x3] else [x3; x2]\n          else if c < 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x1; x2]\n            else if c < 0 then [x1; x2; x3]\n            else\n              let c = cmp x1 x3 in\n              if c = 0 then [x1; x2]\n              else if c < 0 then [x1; x3; x2]\n              else [x3; x1; x2]\n          else\n            let c = cmp x1 x3 in\n            if c = 0 then [x2; x1]\n            else if c < 0 then [x2; x1; x3]\n            else\n              let c = cmp x2 x3 in\n              if c = 0 then [x2; x1]\n              else if c < 0 then [x2; x3; x1]\n              else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = rev_sort n1 l in\n        let s2, tl = rev_sort n2 l2 in\n        (rev_merge_rev s1 s2 [], tl)\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then [x1] else if c > 0 then [x1; x2] else [x2; x1]\n        in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x2] else if c > 0 then [x2; x3] else [x3; x2]\n          else if c > 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x1; x2]\n            else if c > 0 then [x1; x2; x3]\n            else\n              let c = cmp x1 x3 in\n              if c = 0 then [x1; x2]\n              else if c > 0 then [x1; x3; x2]\n              else [x3; x1; x2]\n          else\n            let c = cmp x1 x3 in\n            if c = 0 then [x2; x1]\n            else if c > 0 then [x2; x1; x3]\n            else\n              let c = cmp x2 x3 in\n              if c = 0 then [x2; x1]\n              else if c > 0 then [x2; x3; x1]\n              else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = sort n1 l in\n        let s2, tl = sort n2 l2 in\n        (rev_merge s1 s2 [], tl)\n  in\n  let len = length l in\n  if len < 2 then l else fst (sort len l)\n\n\nlet rec compare_lengths l1 l2 =\n  match l1, l2 with\n  | [], [] -> 0\n  | [], _ -> -1\n  | _, [] -> 1\n  | _ :: l1, _ :: l2 -> compare_lengths l1 l2\n;;\n\nlet rec compare_length_with l n =\n  match l with\n  | [] ->\n    if n = 0 then 0 else\n      if n > 0 then -1 else 1\n  | _ :: l ->\n    if n <= 0 then 1 else\n      compare_length_with l (n-1)\n;;\n\n(** {1 Comparison} *)\n\n(* Note: we are *not* shortcutting the list by using\n   [List.compare_lengths] first; this may be slower on long lists\n   immediately start with distinct elements. It is also incorrect for\n   [compare] below, and it is better (principle of least surprise) to\n   use the same approach for both functions. *)\nlet rec equal eq l1 l2 =\n  match l1, l2 with\n  | [], [] -> true\n  | [], _::_ | _::_, [] -> false\n  | a1::l1, a2::l2 -> eq a1 a2 && equal eq l1 l2\n\nlet rec compare cmp l1 l2 =\n  match l1, l2 with\n  | [], [] -> 0\n  | [], _::_ -> -1\n  | _::_, [] -> 1\n  | a1::l1, a2::l2 ->\n    let c = cmp a1 a2 in\n    if c <> 0 then c\n    else compare cmp l1 l2\n\n(** {1 Iterators} *)\n\nlet to_seq l =\n  let rec aux l () = match l with\n    | [] -> Seq.Nil\n    | x :: tail -> Seq.Cons (x, aux tail)\n  in\n  aux l\n\nlet of_seq seq =\n  let rec direct depth seq : _ list =\n    if depth=0\n    then\n      Seq.fold_left (fun acc x -> x::acc) [] seq\n      |> rev (* tailrec *)\n    else match seq() with\n      | Seq.Nil -> []\n      | Seq.Cons (x, next) -> x :: direct (depth-1) next\n  in\n  direct 500 seq\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Damien Doligez, projet Para, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1997 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Internals of forcing lazy values. *)\n\ntype 'a t = 'a lazy_t\n\nexception Undefined\n\nlet raise_undefined = Obj.repr (fun () -> raise Undefined)\n\nexternal make_forward : Obj.t -> Obj.t -> unit = \"caml_obj_make_forward\"\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  try\n    let result = closure () in\n    make_forward (Obj.repr blk) (Obj.repr result);\n    result\n  with e ->\n    Obj.set_field (Obj.repr blk) 0 (Obj.repr (fun () -> raise e));\n    raise e\n\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_val_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  let result = closure () in\n  make_forward (Obj.repr blk) (Obj.repr result);\n  result\n\n\n(* [force] is not used, since [Lazy.force] is declared as a primitive\n   whose code inlines the tag tests of its argument, except when afl\n   instrumentation is turned on. *)\n\nlet force (lzv : 'arg lazy_t) =\n  (* Using [Sys.opaque_identity] prevents two potential problems:\n     - If the value is known to have Forward_tag, then its tag could have\n       changed during GC, so that information must be forgotten (see GPR#713\n       and issue #7301)\n     - If the value is known to be immutable, then if the compiler\n       cannot prove that the last branch is not taken it will issue a\n       warning 59 (modification of an immutable value) *)\n  let lzv = Sys.opaque_identity lzv in\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_lazy_block lzv\n\n\nlet force_val (lzv : 'arg lazy_t) =\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_val_lazy_block lzv\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Operations on internal representations of values *)\n\ntype t\n\ntype raw_data = nativeint\n\nexternal repr : 'a -> t = \"%identity\"\nexternal obj : t -> 'a = \"%identity\"\nexternal magic : 'a -> 'b = \"%identity\"\nexternal is_int : t -> bool = \"%obj_is_int\"\nlet [@inline always] is_block a = not (is_int a)\nexternal tag : t -> int = \"caml_obj_tag\" [@@noalloc]\nexternal set_tag : t -> int -> unit = \"caml_obj_set_tag\"\nexternal size : t -> int = \"%obj_size\"\nexternal reachable_words : t -> int = \"caml_obj_reachable_words\"\nexternal field : t -> int -> t = \"%obj_field\"\nexternal set_field : t -> int -> t -> unit = \"%obj_set_field\"\nexternal floatarray_get : floatarray -> int -> float = \"caml_floatarray_get\"\nexternal floatarray_set :\n    floatarray -> int -> float -> unit = \"caml_floatarray_set\"\nlet [@inline always] double_field x i = floatarray_get (obj x : floatarray) i\nlet [@inline always] set_double_field x i v =\n  floatarray_set (obj x : floatarray) i v\nexternal raw_field : t -> int -> raw_data = \"caml_obj_raw_field\"\nexternal set_raw_field : t -> int -> raw_data -> unit\n                                          = \"caml_obj_set_raw_field\"\n\nexternal new_block : int -> int -> t = \"caml_obj_block\"\nexternal dup : t -> t = \"caml_obj_dup\"\nexternal truncate : t -> int -> unit = \"caml_obj_truncate\"\nexternal add_offset : t -> Int32.t -> t = \"caml_obj_add_offset\"\nexternal with_tag : int -> t -> t = \"caml_obj_with_tag\"\n\nlet first_non_constant_constructor_tag = 0\nlet last_non_constant_constructor_tag = 245\n\nlet lazy_tag = 246\nlet closure_tag = 247\nlet object_tag = 248\nlet infix_tag = 249\nlet forward_tag = 250\n\nlet no_scan_tag = 251\n\nlet abstract_tag = 251\nlet string_tag = 252\nlet double_tag = 253\nlet double_array_tag = 254\nlet custom_tag = 255\nlet final_tag = custom_tag\n\n\nlet int_tag = 1000\nlet out_of_heap_tag = 1001\nlet unaligned_tag = 1002\n\nmodule Closure = struct\n  type info = {\n    arity: int;\n    start_env: int;\n  }\n\n  let info_of_raw (info : nativeint) =\n    let open Nativeint in\n    let arity =\n      (* signed: negative for tupled functions *)\n      if Sys.word_size = 64 then\n        to_int (shift_right info 56)\n      else\n        to_int (shift_right info 24)\n    in\n    let start_env =\n      (* start_env is unsigned, but we know it can always fit an OCaml\n         integer so we use [to_int] instead of [unsigned_to_int]. *)\n      to_int (shift_right_logical (shift_left info 8) 9) in\n    { arity; start_env }\n\n  (* note: we expect a closure, not an infix pointer *)\n  let info (obj : t) =\n    assert (tag obj = closure_tag);\n    info_of_raw (raw_field obj 1)\nend\n\nmodule Extension_constructor =\nstruct\n  type t = extension_constructor\n  let of_val x =\n    let x = repr x in\n    let slot =\n      if (is_block x) && (tag x) <> object_tag && (size x) >= 1 then field x 0\n      else x\n    in\n    let name =\n      if (is_block slot) && (tag slot) = object_tag then field slot 0\n      else invalid_arg \"Obj.extension_constructor\"\n    in\n      if (tag name) = string_tag then (obj slot : t)\n      else invalid_arg \"Obj.extension_constructor\"\n\n  let [@inline always] name (slot : t) =\n    (obj (field (repr slot) 0) : string)\n\n  let [@inline always] id (slot : t) =\n    (obj (field (repr slot) 1) : int)\nend\n\nlet extension_constructor = Extension_constructor.of_val\nlet extension_name = Extension_constructor.name\nlet extension_id = Extension_constructor.id\n\nmodule Ephemeron = struct\n  type obj_t = t\n\n  type t (** ephemeron *)\n\n   (** To change in sync with weak.h *)\n  let additional_values = 2\n  let max_ephe_length = Sys.max_array_length - additional_values\n\n  external create : int -> t = \"caml_ephe_create\";;\n  let create l =\n    if not (0 <= l && l <= max_ephe_length) then\n      invalid_arg \"Obj.Ephemeron.create\";\n    create l\n\n  let length x = size(repr x) - additional_values\n\n  let raise_if_invalid_offset e o msg =\n    if not (0 <= o && o < length e) then\n      invalid_arg msg\n\n  external get_key: t -> int -> obj_t option = \"caml_ephe_get_key\"\n  let get_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.get_key\";\n    get_key e o\n\n  external get_key_copy: t -> int -> obj_t option = \"caml_ephe_get_key_copy\"\n  let get_key_copy e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.get_key_copy\";\n    get_key_copy e o\n\n  external set_key: t -> int -> obj_t -> unit = \"caml_ephe_set_key\"\n  let set_key e o x =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.set_key\";\n    set_key e o x\n\n  external unset_key: t -> int -> unit = \"caml_ephe_unset_key\"\n  let unset_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.unset_key\";\n    unset_key e o\n\n  external check_key: t -> int -> bool = \"caml_ephe_check_key\"\n  let check_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.check_key\";\n    check_key e o\n\n  external blit_key : t -> int -> t -> int -> int -> unit\n    = \"caml_ephe_blit_key\"\n\n  let blit_key e1 o1 e2 o2 l =\n    if l < 0 || o1 < 0 || o1 > length e1 - l\n       || o2 < 0 || o2 > length e2 - l\n    then invalid_arg \"Obj.Ephemeron.blit_key\"\n    else if l <> 0 then blit_key e1 o1 e2 o2 l\n\n  external get_data: t -> obj_t option = \"caml_ephe_get_data\"\n  external get_data_copy: t -> obj_t option = \"caml_ephe_get_data_copy\"\n  external set_data: t -> obj_t -> unit = \"caml_ephe_set_data\"\n  external unset_data: t -> unit = \"caml_ephe_unset_data\"\n  external check_data: t -> bool = \"caml_ephe_check_data\"\n  external blit_data : t -> t -> unit = \"caml_ephe_blit_data\"\n\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Character operations *)\n\nexternal code: char -> int = \"%identity\"\nexternal unsafe_chr: int -> char = \"%identity\"\n\nlet chr n =\n  if n < 0 || n > 255 then invalid_arg \"Char.chr\" else unsafe_chr n\n\nexternal bytes_create: int -> bytes = \"caml_create_bytes\"\nexternal bytes_unsafe_set : bytes -> int -> char -> unit\n                           = \"%bytes_unsafe_set\"\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet escaped = function\n  | '\\'' -> \"\\\\'\"\n  | '\\\\' -> \"\\\\\\\\\"\n  | '\\n' -> \"\\\\n\"\n  | '\\t' -> \"\\\\t\"\n  | '\\r' -> \"\\\\r\"\n  | '\\b' -> \"\\\\b\"\n  | ' ' .. '~' as c ->\n      let s = bytes_create 1 in\n      bytes_unsafe_set s 0 c;\n      unsafe_to_string s\n  | c ->\n      let n = code c in\n      let s = bytes_create 4 in\n      bytes_unsafe_set s 0 '\\\\';\n      bytes_unsafe_set s 1 (unsafe_chr (48 + n / 100));\n      bytes_unsafe_set s 2 (unsafe_chr (48 + (n / 10) mod 10));\n      bytes_unsafe_set s 3 (unsafe_chr (48 + n mod 10));\n      unsafe_to_string s\n\nlet lowercase = function\n  | 'A' .. 'Z'\n  | '\\192' .. '\\214'\n  | '\\216' .. '\\222' as c ->\n    unsafe_chr(code c + 32)\n  | c -> c\n\nlet uppercase = function\n  | 'a' .. 'z'\n  | '\\224' .. '\\246'\n  | '\\248' .. '\\254' as c ->\n    unsafe_chr(code c - 32)\n  | c -> c\n\nlet lowercase_ascii = function\n  | 'A' .. 'Z' as c -> unsafe_chr(code c + 32)\n  | c -> c\n\nlet uppercase_ascii = function\n  | 'a' .. 'z' as c -> unsafe_chr(code c - 32)\n  | c -> c\n\ntype t = char\n\nlet compare c1 c2 = code c1 - code c2\nlet equal (c1: t) (c2: t) = compare c1 c2 = 0\n","(* ReactiveData\n * https://github.com/hhugo/reactiveData\n * Copyright (C) 2014 Hugo Heuzard\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nmodule type DATA = sig\n  type 'a data\n  type 'a patch\n  val merge : 'a patch -> 'a data -> 'a data\n  val map_patch : ('a -> 'b) -> 'a patch -> 'b patch\n  val map_data : ('a -> 'b) -> 'a data -> 'b data\n  val empty : 'a data\n  val equal : ('a -> 'a -> bool) -> 'a data -> 'a data -> bool\n  val diff : eq:('a -> 'a -> bool) -> 'a data -> 'a data -> 'a patch\nend\nmodule type S = sig\n  type 'a t\n  type 'a data\n  type 'a patch\n  type 'a msg = Patch of 'a patch | Set of 'a data\n  type 'a handle\n  val empty : 'a t\n  val create : 'a data -> 'a t * 'a handle\n  val from_event : 'a data -> 'a msg React.E.t -> 'a t\n  val from_signal : ?eq:('a -> 'a -> bool) -> 'a data React.S.t -> 'a t\n  val const : 'a data -> 'a t\n  val patch : 'a handle -> 'a patch -> unit\n  val set   : 'a handle -> 'a data -> unit\n  val map_msg : ('a -> 'b) -> 'a msg -> 'b msg\n  val map : ('a -> 'b) -> 'a t -> 'b t\n  val value : 'a t -> 'a data\n  val fold : ('a -> 'b msg -> 'a) -> 'b t -> 'a -> 'a React.signal\n  val signal : ?eq:('a -> 'a -> bool) -> 'a t -> 'a data React.S.t\n  val event : 'a t -> 'a msg React.E.t\nend\n\nmodule Make(D : DATA) :\n  S with type 'a data = 'a D.data\n     and type 'a patch = 'a D.patch = struct\n\n  type 'a data = 'a D.data\n  type 'a patch = 'a D.patch\n  let merge = D.merge\n  let map_patch = D.map_patch\n  let map_data = D.map_data\n\n  type 'a msg =\n    | Patch of 'a patch\n    | Set of 'a data\n\n  type 'a handle = ?step:React.step -> 'a msg -> unit\n\n  type 'a mut = {\n    current : 'a data ref;\n    event : 'a msg React.E.t;\n  }\n\n  type 'a t =\n    | Const of 'a data\n    | Mut of 'a mut\n\n  let empty = Const D.empty\n\n  let create l =\n    let initial_event,send = React.E.create () in\n    let current = ref l in\n    let event = React.E.map (fun msg ->\n        begin match msg with\n          | Set l -> current := l;\n          | Patch p -> current := merge p !current\n        end;\n        msg) initial_event in\n    Mut {current;event},send\n\n  let from_event l initial_event =\n    let current = ref l in\n    let event = React.E.map (fun msg ->\n        begin match msg with\n          | Set l -> current := l;\n          | Patch p -> current := merge p !current\n        end;\n        msg) initial_event in\n    Mut {current;event}\n\n  let const x = Const x\n\n  let map_msg (f : 'a -> 'b) : 'a msg -> 'b msg = function\n    | Set l -> Set (map_data f l)\n    | Patch p -> Patch (map_patch f p)\n\n  let map f s =\n    match s with\n    | Const x -> Const (map_data f x)\n    | Mut s ->\n      let current = ref (map_data f !(s.current)) in\n      let event = React.E.map (fun msg ->\n          let msg = map_msg f msg in\n          begin match msg with\n            | Set l -> current := l;\n            | Patch p -> current := merge p !current\n          end;\n          msg) s.event in\n      Mut {current ;event}\n\n  let value s = match s with\n    | Const c -> c\n    | Mut s -> !(s.current)\n\n  let event s = match s with\n    | Const _ -> React.E.never\n    | Mut s -> s.event\n\n  let patch (s : 'a handle) p = s (Patch p)\n\n  let set (s : 'a handle) p = s (Set p)\n\n  let fold f s acc =\n    match s with\n    | Const c -> React.S.const (f acc (Set c))\n    | Mut s ->\n      let acc = f acc (Set (!(s.current))) in\n      React.S.fold f acc s.event\n\n  let signal ?(eq = (=)) (s : 'a t) : 'a data React.S.t =\n    match s with\n    | Const c -> React.S.const c\n    | Mut s ->\n      React.S.fold ~eq:(D.equal eq) (fun l msg ->\n          match msg with\n          | Set l -> l\n          | Patch p -> merge p l) (!(s.current)) s.event\n\n  let from_signal ?(eq = (=)) s =\n    let f d' d = Patch (D.diff ~eq d d') in\n    from_event (React.S.value s) (React.S.diff f s)\n\nend\n\nmodule DataList = struct\n  type 'a data = 'a list\n  type 'a p =\n    | I of int * 'a\n    | R of int\n    | U of int * 'a\n    | X of int * int\n  type 'a patch = 'a p list\n  let empty = []\n  let map_data = List.map\n  let map_patch f = function\n    | I (i,x) -> I (i, f x)\n    | R i -> R i\n    | X (i,j) -> X (i,j)\n    | U (i,x) -> U (i,f x)\n  let map_patch f = List.map (map_patch f)\n\n  let merge_p op l =\n    match op with\n    | I (i',x) ->\n      let i = if i' < 0 then List.length l + 1 + i' else i' in\n      let rec aux acc n l = match n,l with\n        | 0,l -> List.rev_append acc (x::l)\n        | _,[] -> failwith \"ReactiveData.Rlist.merge\"\n        | n,x::xs -> aux (x::acc) (pred n) xs\n      in aux [] i l\n    | R i' ->\n      let i = if i' < 0 then List.length l + i' else i' in\n      let rec aux acc n l = match n,l with\n        | 0,_::l -> List.rev_append acc l\n        | _,[] -> failwith \"ReactiveData.Rlist.merge\"\n        | n,x::xs -> aux (x::acc) (pred n) xs\n      in aux [] i l\n    | U (i',x) ->\n      let i = if i' < 0 then List.length l + i' else i' in\n      let a = Array.of_list l in\n      a.(i) <- x;\n      Array.to_list a\n    | X (i',offset) ->\n      let a = Array.of_list l in\n      let len = Array.length a in\n      let i = if i' < 0 then len + i' else i' in\n      let v = a.(i) in\n      if offset > 0\n      then begin\n        if (i + offset >= len) then failwith \"ReactiveData.Rlist.merge\";\n        for j = i to i + offset - 1 do\n          a.(j) <- a.(j + 1)\n        done;\n        a.(i+offset) <- v\n      end\n      else begin\n        if (i + offset < 0) then failwith \"ReactiveData.Rlist.merge\";\n        for j = i downto i + offset + 1 do\n          a.(j) <- a.(j - 1)\n        done;\n        a.(i+offset) <- v\n      end;\n      Array.to_list a\n\n  (* accumulates into acc i unmodified elements from l *)\n  let rec linear_merge_fwd ~acc i l =\n    assert (i >= 0);\n    if i > 0 then\n      match l with\n      | h :: l ->\n        let acc = h :: acc in\n        linear_merge_fwd ~acc (i - 1) l\n      | [] ->\n        invalid_arg \"invalid index\"\n    else\n      l, acc\n\n  let rec linear_merge ~acc i0 p l =\n    let l, acc =\n      match p with\n      | (I (i, _) | R i | U (i, _)) :: _ when i > i0 ->\n        linear_merge_fwd ~acc (i - i0) l\n      | _ ->\n        l, acc\n    in\n    match p, l with\n    | I (i, x) :: p, _ ->\n      linear_merge ~acc i p (x :: l)\n    | R i :: p, _ :: l ->\n      linear_merge ~acc i p l\n    | R _ :: _, [] ->\n      invalid_arg \"merge: invalid index\"\n    | U (i, x) :: p, _ :: l ->\n      linear_merge ~acc i p (x :: l)\n    | U (_, _) :: _, [] ->\n      invalid_arg \"merge: invalid index\"\n    | [], l ->\n      List.rev_append acc l\n    | X (_, _) :: _, _ ->\n      failwith \"linear_merge: X not supported\"\n\n  let rec linear_mergeable ~n p =\n    assert (n >= 0);\n    match p with\n    | (I (i, _) | R i | U (i, _)) :: p when i >= n ->\n      (* negative i's ruled out (among others) *)\n      linear_mergeable ~n:i p\n    | _ :: _ ->\n      false\n    | [] ->\n      true\n\n  let merge p l =\n    if linear_mergeable ~n:0 p then\n      linear_merge ~acc:[] 0 p l\n    else\n      List.fold_left (fun l x -> merge_p x l) l p\n\n  let rec equal f l1 l2 =\n    match l1, l2 with\n    | x1 :: l1, x2 :: l2 when f x1 x2 ->\n      equal f l1 l2\n    | [], [] ->\n      true\n    | _ :: _ , _ :: _\n    | _ :: _ , []\n    | []     , _ :: _ ->\n      false\n\n  let mem (type u) l =\n    let module H =\n      Hashtbl.Make\n        (struct type t = u let hash = Hashtbl.hash let equal = (==) end) in\n    let h = H.create 16 in\n    List.iter (fun x -> H.add h x ()) l;\n    H.mem h\n\n  let fold_diff ?(eq = (=)) ~acc ~remove ~add lx ly =\n    let memx = mem lx\n    and memy = mem ly in\n    let rec f ~acc ~left lx ly n =\n      match lx, ly with\n      (* trailing elements to be removed *)\n      | _ :: lx, [] ->\n        let acc = remove acc n in\n        f ~acc ~left lx [] n\n      (* trailing elements to be added *)\n      | [], y :: ly ->\n        let acc = add acc n y in\n        f ~acc ~left [] ly (n + 1)\n      (* done! *)\n      | [], [] ->\n        acc\n      (* same *)\n      | x :: lx, y :: ly when eq x y ->\n        f ~acc ~left lx ly (n + 1)\n      (* x needs to be removed for sure *)\n      | x :: lx, _ :: _ when not (memy x) ->\n        let acc = remove acc n in\n        f ~acc ~left lx ly n\n      (* y needs to be added for sure *)\n      | _ :: _, y :: ly when not (memx y) ->\n        let acc = add acc n y in\n        f ~acc ~left lx ly (n + 1)\n      (* no more certainty, ~left decides what to recur on *)\n      | _ :: lx, _ :: _ when left ->\n        let acc = remove acc n in\n        f ~acc ~left:false lx ly n\n      | _ :: _, y :: ly ->\n        let acc = add acc n y in\n        f ~acc ~left:true lx ly (n + 1)\n    in\n    f ~acc ~left:true lx ly 0\n\n  let rec list_rev ?(acc = []) = function\n    | h :: t ->\n      let acc = h :: acc in\n      list_rev ~acc t\n    | [] ->\n      acc\n\n  let diff ~eq x y =\n    let add acc i v = I (i, v) :: acc\n    and remove acc i = R i :: acc\n    and acc = [] in\n    list_rev (fold_diff ~eq ~acc ~add ~remove x y)\n\nend\n\nmodule RList = struct\n  include Make (DataList)\n  module D = DataList\n  type 'a p = 'a D.p =\n    | I of int * 'a\n    | R of int\n    | U of int * 'a\n    | X of int * int\n\n  let cons x s = patch s [D.I (0,x)]\n  let snoc x s = patch s [D.I (-1,x)]\n  let insert x i s = patch s [D.I (i,x)]\n  let update x i s = patch s [D.U (i,x)]\n  let move i j s = patch s [D.X (i,j)]\n  let remove i s = patch s [D.R i]\n\n  let index ?(eq = (=)) l x =\n    let rec f n = function\n      | hd :: _ when eq hd x -> n\n      | _ :: tl -> f (n + 1) tl\n      | [] -> raise Not_found\n    in\n    f 0 l\n\n  let update_eq ?eq (data, handle) x y =\n    let i = index ?eq (value data) x in\n    update y i handle\n\n  let remove_last (data, handle) =\n    remove (List.length (value data) - 1) handle\n\n  let remove_eq ?eq (data, handle) x =\n    let i = index ?eq (value data) x in\n    remove i handle\n\n  let singleton x = const [x]\n\n  let singleton_s s =\n    let first = ref true in\n    let e,send = React.E.create () in\n    let result = from_event [] e in\n    let _ = React.S.map (fun x ->\n        if !first\n        then begin\n          first:=false;\n          send (Patch [I(0,x)])\n        end\n        else send (Patch [U(0,x)])) s in\n    result\n\n  let concat : 'a t -> 'a t -> 'a t = fun x y ->\n    let v1 = value x\n    and v2 = value y in\n    let size1 = ref 0\n    and size2 = ref 0 in\n    let size_with_patch sizex : 'a D.p -> unit = function\n      | (D.I _) -> incr sizex\n      | (D.R _) -> decr sizex\n      | (D.X _ | D.U _) -> () in\n    let size_with_set sizex l = sizex:=List.length l in\n\n    size_with_set size1 v1;\n    size_with_set size2 v2;\n\n    let update_patch1 = List.map (fun p ->\n        let m = match p with\n          | D.I (pos,x) ->\n            let i = if pos < 0 then pos - !size2 else pos in\n            D.I (i, x)\n          | D.R pos     -> D.R  (if pos < 0 then pos - !size2 else pos)\n          | D.U (pos,x) -> D.U ((if pos < 0 then pos - !size2 else pos), x)\n          | D.X (i,j) ->   D.X ((if i < 0 then i - !size2 else i),j)\n        in\n        size_with_patch size1 m;\n        m) in\n    let update_patch2 = List.map (fun p ->\n        let m = match p with\n          | D.I (pos,x) -> D.I ((if pos < 0 then pos else !size1 + pos), x)\n          | D.R pos     -> D.R  (if pos < 0 then pos else !size1 + pos)\n          | D.U (pos,x) -> D.U ((if pos < 0 then pos else !size1 + pos), x)\n          | D.X (i,j) ->   D.X ((if i < 0 then i else !size1 + i),j)\n        in\n        size_with_patch size2 m;\n        m) in\n    let tuple_ev =\n      React.E.merge (fun acc x ->\n          match acc,x with\n          | (None,p2),`E1 x -> Some x,p2\n          | (p1,None),`E2 x -> p1, Some x\n          | _ -> assert false)\n        (None,None)\n        [React.E.map (fun e -> `E1 e) (event x);\n         React.E.map (fun e -> `E2 e) (event y)] in\n    let merged_ev = React.E.map (fun p ->\n        match p with\n        | Some (Set p1), Some (Set p2) ->\n          size_with_set size1 p1;\n          size_with_set size2 p2;\n          Set (p1 @ p2)\n        | Some (Set p1), None ->\n          size_with_set size1 p1;\n          Set (p1 @ value y)\n        | None, Some (Set p2) ->\n          size_with_set size2 p2;\n          Set (value x @ p2 )\n        | Some (Patch p1), Some (Patch p2) ->\n          let p1 = update_patch1 p1 in\n          let p2 = update_patch2 p2 in\n          Patch (p1 @ p2)\n        | Some (Patch p1), None -> Patch (update_patch1 p1)\n        | None, Some (Patch p2) -> Patch (update_patch2 p2)\n        | Some (Patch _), Some (Set s2) ->\n          let s1 = value x in\n          size_with_set size1 s1;\n          size_with_set size2 s2;\n          Set(s1 @ s2)\n        | Some (Set s1), Some (Patch _) ->\n          size_with_set size1 s1;\n          let s2 = value y in\n          size_with_set size2 s2;\n          Set(s1 @ s2)\n        | None,None -> assert false\n      ) tuple_ev in\n    from_event (v1 @ v2) merged_ev\n\n  let inverse : 'a . 'a p -> 'a p = function\n    | I (i,x) -> I(-i-1, x)\n    | U (i,x) -> U(-i-1, x)\n    | R i -> R (-i-1)\n    | X (i,j) -> X (-i-1,-j)\n\n  let rev t =\n    let e = React.E.map (function\n        | Set l -> Set (List.rev l)\n        | Patch p -> Patch (List.map inverse p))  (event t)\n    in\n    from_event (List.rev (value t)) e\n\n  let filter pred l =\n    let module IntMap = Map.Make(Int) in\n\n    let index = ref IntMap.empty in\n    let size = ref 0 in\n\n    let filter_list l =\n      let rec aux (l: 'a list) res their_i my_i = match l with\n        | [] -> res\n        | x::xs ->\n           if pred x\n           then\n             begin\n               index := IntMap.add their_i (my_i + 1) !index;\n               aux xs (x::res) (their_i + 1) (my_i + 1)\n             end\n           else\n             begin\n               aux xs res (their_i + 1) my_i\n             end\n      in\n      size := List.length l;\n      index := IntMap.empty;\n      List.rev (aux l [] 0 (-1))\n    in\n\n    let normalise i = if i < 0 then !size + 1 + i else i in\n\n    let update_index_insert insert_pos_full_list visible =\n      let insert_pos_full_list = normalise insert_pos_full_list in\n      let left_alone, displaced, updatables = IntMap.split insert_pos_full_list !index in\n      let updatables = match displaced with\n        | None -> updatables\n        | Some displaced_in_filtered ->\n           IntMap.add insert_pos_full_list displaced_in_filtered updatables\n      in\n      let update_j j_full_list j_filtered_list =\n        let new_j_filtered = if visible then j_filtered_list + 1 else j_filtered_list in\n        index := IntMap.add (j_full_list + 1) new_j_filtered !index\n      in\n      let () = IntMap.iter update_j updatables in\n      let insert_pos_filtered = if IntMap.is_empty left_alone\n                                then 0\n                                else (snd (IntMap.max_binding left_alone)) + 1\n      in\n      if visible then index := IntMap.add insert_pos_full_list insert_pos_filtered !index;\n      incr size;\n      insert_pos_filtered\n    in\n\n    let update_index_remove remove_pos_full_list =\n      let was_visible = IntMap.mem remove_pos_full_list !index in\n      let _,_,updatables = IntMap.split remove_pos_full_list !index in\n      let update_j j_full_list j_filtered_list =\n        let new_j = if was_visible then j_filtered_list else j_filtered_list - 1 in\n        index := IntMap.add (j_full_list - 1) new_j !index\n      in\n      if not (IntMap.is_empty !index)\n      then\n        let last_i, _ = IntMap.max_binding !index in\n        index := IntMap.remove last_i !index\n      else ();\n      decr size;\n      IntMap.iter update_j updatables\n    in\n\n    let update_index_update_delete update_pos_full_list =\n      let _, _, updatables = IntMap.split update_pos_full_list !index in\n      let update_j j_full_list j_filtered_list =\n        index := IntMap.add j_full_list (j_filtered_list - 1) !index\n      in\n      index := IntMap.remove update_pos_full_list !index;\n      IntMap.iter update_j updatables\n    in\n\n    let update_index_update_insert update_pos_full_list =\n      let left_alone, none, updatables = IntMap.split update_pos_full_list !index in\n      assert (none = None);\n      let update_j j_full_list j_filtered_list =\n        index := IntMap.add j_full_list (j_filtered_list + 1) !index\n      in\n      let new_pos_filtered_list =\n        let previous_pos_filtered = try (snd (IntMap.max_binding left_alone)) with Not_found -> (-1) in\n        previous_pos_filtered + 1\n      in\n      index := IntMap.add update_pos_full_list new_pos_filtered_list !index;\n      IntMap.iter update_j updatables;\n      new_pos_filtered_list\n    in\n\n    let update_index_move from_full_list to_full_list to_filtered =\n      let was_visible = match to_filtered with | Some _ -> true | None -> false in\n      let forward = from_full_list < to_full_list in\n      if forward then\n        for i_full = from_full_list + 1 to to_full_list do\n          let delta = if was_visible then (-1) else 0 in\n          try\n            let i_filtered = IntMap.find i_full !index in\n            let new_val = i_filtered + delta in\n            index := IntMap.add (i_full - 1) new_val !index\n          with\n          | Not_found -> ()\n        done\n      else\n        for i_full = from_full_list - 1 downto to_full_list do\n          try\n            let delta = if was_visible then 1 else 0 in\n            let i_filtered = IntMap.find i_full !index in\n            let new_val = i_filtered + delta in\n            index := IntMap.add (i_full + 1) new_val !index\n          with\n          | Not_found -> ()\n        done;\n      match to_filtered with\n      | Some to_filtered ->\n         index := IntMap.add to_full_list to_filtered !index\n      | None ->\n         index := IntMap.remove to_full_list !index\n    in\n\n    let convert_p = function\n      | I (i, x) ->\n         if pred x\n         then\n           let my_i = update_index_insert i true in\n           [I (my_i, x)]\n         else\n           begin\n             ignore (update_index_insert i false);\n             []\n           end\n      | R i ->\n         let i = normalise i in\n         let ret = try let j = IntMap.find i !index in [R j] with | Not_found -> [] in\n         let () = update_index_remove i in\n         ret\n      | U (i, x) ->\n         let i = normalise i in\n         begin\n           try\n             let old_j = IntMap.find i !index in\n             if pred x\n             then [U (old_j, x)]\n             else (update_index_update_delete i; [R old_j])\n           with\n           | Not_found ->\n              if pred x\n              then\n                let new_j = update_index_update_insert i in\n                [I (new_j, x)]\n              else\n                []\n         end\n      | X (origin_full, offset_full) ->\n         let origin_full = normalise origin_full in\n         let dest_full = origin_full + offset_full in\n         try\n           let origin_filtered = IntMap.find origin_full !index in\n           let dest_filtered =\n             try IntMap.find dest_full !index\n             with\n             | Not_found ->\n                let small_ones, _, _ = IntMap.split origin_full !index in\n                if IntMap.is_empty small_ones\n                then 0\n                else snd (IntMap.max_binding small_ones) + 1\n           in\n           update_index_move origin_full dest_full (Some dest_filtered);\n           if dest_filtered != origin_filtered\n           then [X (origin_filtered, dest_filtered - origin_filtered)]\n           else []\n         with\n         | Not_found ->\n            (* moving an element that was filtered out *)\n            update_index_move origin_full dest_full None;\n            []\n    in\n\n    let filter_e = function\n      | Set l -> Set (filter_list l)\n      | Patch p ->\n         Patch (List.concat (List.map convert_p p))\n    in\n    let e = React.E.map filter_e (event l) in\n    from_event (filter_list (value l)) e\n\n  module IntSet = Set.Make (Int)\n\n  let for_all fn data =\n    let maybe_update acc i v = if fn v then acc else IntSet.add i acc in\n    let init =\n      let rec fold i acc = function\n        | v :: tl -> fold (i + 1) (maybe_update acc i v) tl\n        | [] -> acc\n      in\n      fold 0 IntSet.empty\n    in\n    let update_idx_after i f acc =\n      IntSet.map (fun i' -> if i' >= i then f i' 1 else i') acc\n    in\n    let f = fun acc -> function\n      | Set x -> init x\n      | Patch updates ->\n        List.fold_left\n          (fun acc -> function\n             | X (i, i') ->\n               if IntSet.mem i acc = IntSet.mem i' acc\n               then acc\n               else if IntSet.mem i acc\n               then IntSet.add i' (IntSet.remove i acc)\n               else IntSet.add i (IntSet.remove i' acc)\n             | R i ->\n               update_idx_after i (-) (IntSet.remove i acc)\n             | I (i, v) ->\n               let acc = update_idx_after i (+) acc in\n               maybe_update acc i v\n             | U (i, v) ->\n               maybe_update (IntSet.remove i acc) i v)\n          acc\n          updates\n    in\n    React.S.fold f (init (value data)) (event data)\n    |> React.S.map IntSet.is_empty\n\nend\n\nmodule RMap(M : Map.S) = struct\n\n  module Data = struct\n\n    type 'a data = 'a M.t\n\n    type 'a p = [`Add of (M.key * 'a) | `Del of M.key]\n\n    type 'a patch = 'a p list\n\n    let merge_p p s =\n      match p with\n      | `Add (k,a) -> M.add k a s\n      | `Del k -> M.remove k s\n\n    let merge p acc = List.fold_left (fun acc p -> merge_p p acc) acc p\n\n    let map_p f = function\n      | `Add (k,a) -> `Add (k,f a)\n      | `Del k -> `Del k\n\n    let map_patch f = List.map (map_p f)\n\n    let map_data f d = M.map f d\n\n    let empty = M.empty\n\n    let equal f = M.equal f\n\n    let diff ~eq x y =\n      let m =\n        let g _key v w =\n          match v, w with\n          | Some v, Some w when eq v w ->\n            None\n          | Some _, Some w ->\n            Some (`U w)\n          | Some _, None ->\n            Some `D\n          | None, Some v ->\n            Some (`A v)\n          | None, None ->\n            None\n        in\n        M.merge g x y\n      and g key x acc =\n        match x with\n        | `U v ->\n          `Del key :: `Add (key, v) :: acc\n        | `D ->\n          `Del key :: acc\n        | `A v ->\n          `Add (key, v) :: acc\n      and acc = [] in\n      List.rev (M.fold g m acc)\n\n  end\n\n  include Make(Data)\n\n  let filter pred m =\n\n    let convert_p = function\n      | `Add (k,v) ->\n         if pred k v\n         then [`Add (k,v)]\n         else []\n      | `Del k -> [`Del k]\n    in\n\n    let filter_e = function\n      | Set m -> Set (M.filter pred m)\n      | Patch p -> Patch (List.concat (List.map convert_p p))\n    in\n\n    let e = React.E.map filter_e (event m) in\n    from_event (M.filter pred (value m)) e\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                         The OCaml programmers                          *)\n(*                                                                        *)\n(*   Copyright 2018 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype t = int\n\nlet zero = 0\nlet one = 1\nlet minus_one = -1\nexternal neg : int -> int = \"%negint\"\nexternal add : int -> int -> int = \"%addint\"\nexternal sub : int -> int -> int = \"%subint\"\nexternal mul : int -> int -> int = \"%mulint\"\nexternal div : int -> int -> int = \"%divint\"\nexternal rem : int -> int -> int = \"%modint\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nlet abs x = if x >= 0 then x else -x\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\nexternal logand : int -> int -> int = \"%andint\"\nexternal logor : int -> int -> int = \"%orint\"\nexternal logxor : int -> int -> int = \"%xorint\"\nlet lognot x = logxor x (-1)\nexternal shift_left : int -> int -> int = \"%lslint\"\nexternal shift_right : int -> int -> int = \"%asrint\"\nexternal shift_right_logical : int -> int -> int = \"%lsrint\"\nlet equal : int -> int -> bool = ( = )\nlet compare : int -> int -> int = Stdlib.compare\nlet min x y : t = if x <= y then x else y\nlet max x y : t = if x >= y then x else y\nexternal to_float : int -> float = \"%floatofint\"\nexternal of_float : float -> int = \"%intoffloat\"\n\n(*\nexternal int_of_string : string -> int = \"caml_int_of_string\"\nlet of_string s = try Some (int_of_string s) with Failure _ -> None\n*)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nlet to_string x = format_int \"%d\" x\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in string.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in string.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : bytes -> int = \"%bytes_length\"\nexternal string_length : string -> int = \"%string_length\"\nexternal get : bytes -> int -> char = \"%bytes_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%bytes_safe_set\"\nexternal create : int -> bytes = \"caml_create_bytes\"\nexternal unsafe_get : bytes -> int -> char = \"%bytes_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_bytes\" [@@noalloc]\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\nexternal unsafe_of_string : string -> bytes = \"%bytes_of_string\"\n\nexternal unsafe_blit : bytes -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_bytes\" [@@noalloc]\nexternal unsafe_blit_string : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\n\nlet make n c =\n  let s = create n in\n  unsafe_fill s 0 n c;\n  s\n\nlet init n f =\n  let s = create n in\n  for i = 0 to n - 1 do\n    unsafe_set s i (f i)\n  done;\n  s\n\nlet empty = create 0\n\nlet copy s =\n  let len = length s in\n  let r = create len in\n  unsafe_blit s 0 r 0 len;\n  r\n\nlet to_string b = unsafe_to_string (copy b)\nlet of_string s = copy (unsafe_of_string s)\n\nlet sub s ofs len =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.sub / Bytes.sub\"\n  else begin\n    let r = create len in\n    unsafe_blit s ofs r 0 len;\n    r\n  end\n\nlet sub_string b ofs len = unsafe_to_string (sub b ofs len)\n\n(* addition with an overflow check *)\nlet (++) a b =\n  let c = a + b in\n  match a < 0, b < 0, c < 0 with\n  | true , true , false\n  | false, false, true  -> invalid_arg \"Bytes.extend\" (* overflow *)\n  | _ -> c\n\nlet extend s left right =\n  let len = length s ++ left ++ right in\n  let r = create len in\n  let (srcoff, dstoff) = if left < 0 then -left, 0 else 0, left in\n  let cpylen = Int.min (length s - srcoff) (len - dstoff) in\n  if cpylen > 0 then unsafe_blit s srcoff r dstoff cpylen;\n  r\n\nlet fill s ofs len c =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.fill / Bytes.fill\"\n  else unsafe_fill s ofs len c\n\nlet blit s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"Bytes.blit\"\n  else unsafe_blit s1 ofs1 s2 ofs2 len\n\nlet blit_string s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > string_length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"String.blit / Bytes.blit_string\"\n  else unsafe_blit_string s1 ofs1 s2 ofs2 len\n\n(* duplicated in string.ml *)\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\n(* duplicated in string.ml *)\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet ensure_ge (x:int) y = if x >= y then x else invalid_arg \"Bytes.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> empty\n  | l -> let seplen = length sep in\n          unsafe_blits\n            (create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\nlet cat s1 s2 =\n  let l1 = length s1 in\n  let l2 = length s2 in\n  let r = create (l1 + l2) in\n  unsafe_blit s1 0 r 0 l1;\n  unsafe_blit s2 0 r l1 l2;\n  r\n\n\nexternal char_code: char -> int = \"%identity\"\nexternal char_chr: int -> char = \"%identity\"\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  let len = length s in\n  let i = ref 0 in\n  while !i < len && is_space (unsafe_get s !i) do\n    incr i\n  done;\n  let j = ref (len - 1) in\n  while !j >= !i && is_space (unsafe_get s !j) do\n    decr j\n  done;\n  if !j >= !i then\n    sub s !i (!j - !i + 1)\n  else\n    empty\n\nlet escaped s =\n  let n = ref 0 in\n  for i = 0 to length s - 1 do\n    n := !n +\n      (match unsafe_get s i with\n       | '\\\"' | '\\\\' | '\\n' | '\\t' | '\\r' | '\\b' -> 2\n       | ' ' .. '~' -> 1\n       | _ -> 4)\n  done;\n  if !n = length s then copy s else begin\n    let s' = create !n in\n    n := 0;\n    for i = 0 to length s - 1 do\n      begin match unsafe_get s i with\n      | ('\\\"' | '\\\\') as c ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n c\n      | '\\n' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'n'\n      | '\\t' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 't'\n      | '\\r' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'r'\n      | '\\b' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'b'\n      | (' ' .. '~') as c -> unsafe_set s' !n c\n      | c ->\n          let a = char_code c in\n          unsafe_set s' !n '\\\\';\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a / 100));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + (a / 10) mod 10));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a mod 10));\n      end;\n      incr n\n    done;\n    s'\n  end\n\nlet map f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f (unsafe_get s i)) done;\n    r\n  end\n\nlet mapi f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f i (unsafe_get s i)) done;\n    r\n  end\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nlet exists p s =\n  let n = length s in\n  let rec loop i =\n    if i = n then false\n    else if p (unsafe_get s i) then true\n    else loop (succ i) in\n  loop 0\n\nlet for_all p s =\n  let n = length s in\n  let rec loop i =\n    if i = n then true\n    else if p (unsafe_get s i) then loop (succ i)\n    else false in\n  loop 0\n\nlet uppercase_ascii s = map Char.uppercase_ascii s\nlet lowercase_ascii s = map Char.lowercase_ascii s\n\nlet apply1 f s =\n  if length s = 0 then s else begin\n    let r = copy s in\n    unsafe_set r 0 (f(unsafe_get s 0));\n    r\n  end\n\nlet capitalize_ascii s = apply1 Char.uppercase_ascii s\nlet uncapitalize_ascii s = apply1 Char.lowercase_ascii s\n\n(* duplicated in string.ml *)\nlet starts_with ~prefix s =\n  let len_s = length s\n  and len_pre = length prefix in\n  let rec aux i =\n    if i = len_pre then true\n    else if unsafe_get s i <> unsafe_get prefix i then false\n    else aux (i + 1)\n  in len_s >= len_pre && aux 0\n\n(* duplicated in string.ml *)\nlet ends_with ~suffix s =\n  let len_s = length s\n  and len_suf = length suffix in\n  let diff = len_s - len_suf in\n  let rec aux i =\n    if i = len_suf then true\n    else if unsafe_get s (diff + i) <> unsafe_get suffix i then false\n    else aux (i + 1)\n  in diff >= 0 && aux 0\n\n(* duplicated in string.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in string.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in string.ml *)\nlet rec index_rec_opt s lim i c =\n  if i >= lim then None else\n  if unsafe_get s i = c then Some i else index_rec_opt s lim (i + 1) c\n\n(* duplicated in string.ml *)\nlet index_opt s c = index_rec_opt s (length s) 0 c\n\n(* duplicated in string.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n  index_rec s l i c\n\n(* duplicated in string.ml *)\nlet index_from_opt s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.index_from_opt / Bytes.index_from_opt\"\n  else\n    index_rec_opt s l i c\n\n(* duplicated in string.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in string.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n(* duplicated in string.ml *)\nlet rec rindex_rec_opt s i c =\n  if i < 0 then None else\n  if unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_opt s c = rindex_rec_opt s (length s - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_from_opt s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from_opt / Bytes.rindex_from_opt\"\n  else\n    rindex_rec_opt s i c\n\n\n(* duplicated in string.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n\n(* duplicated in string.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in string.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\n\ntype t = bytes\n\nlet compare (x: t) (y: t) = Stdlib.compare x y\nexternal equal : t -> t -> bool = \"caml_bytes_equal\" [@@noalloc]\n\n(* duplicated in string.ml *)\nlet split_on_char sep s =\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if unsafe_get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s = map Char.uppercase s\nlet lowercase s = map Char.lowercase s\n\nlet capitalize s = apply1 Char.uppercase s\nlet uncapitalize s = apply1 Char.lowercase s\n\n(** {1 Iterators} *)\n\nlet to_seq s =\n  let rec aux i () =\n    if i = length s then Seq.Nil\n    else\n      let x = get s i in\n      Seq.Cons (x, aux (i+1))\n  in\n  aux 0\n\nlet to_seqi s =\n  let rec aux i () =\n    if i = length s then Seq.Nil\n    else\n      let x = get s i in\n      Seq.Cons ((i,x), aux (i+1))\n  in\n  aux 0\n\nlet of_seq i =\n  let n = ref 0 in\n  let buf = ref (make 256 '\\000') in\n  let resize () =\n    (* resize *)\n    let new_len = Int.min (2 * length !buf) Sys.max_string_length in\n    if length !buf = new_len then failwith \"Bytes.of_seq: cannot grow bytes\";\n    let new_buf = make new_len '\\000' in\n    blit !buf 0 new_buf 0 !n;\n    buf := new_buf\n  in\n  Seq.iter\n    (fun c ->\n       if !n = length !buf then resize();\n       set !buf !n c;\n       incr n)\n    i;\n  sub !buf 0 !n\n\n(** {6 Binary encoding/decoding of integers} *)\n\n(* The get_ functions are all duplicated in string.ml *)\n\nexternal unsafe_get_uint8 : bytes -> int -> int = \"%bytes_unsafe_get\"\nexternal unsafe_get_uint16_ne : bytes -> int -> int = \"%caml_bytes_get16u\"\nexternal get_uint8 : bytes -> int -> int = \"%bytes_safe_get\"\nexternal get_uint16_ne : bytes -> int -> int = \"%caml_bytes_get16\"\nexternal get_int32_ne : bytes -> int -> int32 = \"%caml_bytes_get32\"\nexternal get_int64_ne : bytes -> int -> int64 = \"%caml_bytes_get64\"\n\nexternal unsafe_set_uint8 : bytes -> int -> int -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_set_uint16_ne : bytes -> int -> int -> unit\n                              = \"%caml_bytes_set16u\"\nexternal set_int8 : bytes -> int -> int -> unit = \"%bytes_safe_set\"\nexternal set_int16_ne : bytes -> int -> int -> unit = \"%caml_bytes_set16\"\nexternal set_int32_ne : bytes -> int -> int32 -> unit = \"%caml_bytes_set32\"\nexternal set_int64_ne : bytes -> int -> int64 -> unit = \"%caml_bytes_set64\"\nexternal swap16 : int -> int = \"%bswap16\"\nexternal swap32 : int32 -> int32 = \"%bswap_int32\"\nexternal swap64 : int64 -> int64 = \"%bswap_int64\"\n\nlet unsafe_get_uint16_le b i =\n  if Sys.big_endian\n  then swap16 (unsafe_get_uint16_ne b i)\n  else unsafe_get_uint16_ne b i\n\nlet unsafe_get_uint16_be b i =\n  if Sys.big_endian\n  then unsafe_get_uint16_ne b i\n  else swap16 (unsafe_get_uint16_ne b i)\n\nlet get_int8 b i =\n  ((get_uint8 b i) lsl (Sys.int_size - 8)) asr (Sys.int_size - 8)\n\nlet get_uint16_le b i =\n  if Sys.big_endian then swap16 (get_uint16_ne b i)\n  else get_uint16_ne b i\n\nlet get_uint16_be b i =\n  if not Sys.big_endian then swap16 (get_uint16_ne b i)\n  else get_uint16_ne b i\n\nlet get_int16_ne b i =\n  ((get_uint16_ne b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int16_le b i =\n  ((get_uint16_le b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int16_be b i =\n  ((get_uint16_be b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int32_le b i =\n  if Sys.big_endian then swap32 (get_int32_ne b i)\n  else get_int32_ne b i\n\nlet get_int32_be b i =\n  if not Sys.big_endian then swap32 (get_int32_ne b i)\n  else get_int32_ne b i\n\nlet get_int64_le b i =\n  if Sys.big_endian then swap64 (get_int64_ne b i)\n  else get_int64_ne b i\n\nlet get_int64_be b i =\n  if not Sys.big_endian then swap64 (get_int64_ne b i)\n  else get_int64_ne b i\n\nlet unsafe_set_uint16_le b i x =\n  if Sys.big_endian\n  then unsafe_set_uint16_ne b i (swap16 x)\n  else unsafe_set_uint16_ne b i x\n\nlet unsafe_set_uint16_be b i x =\n  if Sys.big_endian\n  then unsafe_set_uint16_ne b i x else\n  unsafe_set_uint16_ne b i (swap16 x)\n\nlet set_int16_le b i x =\n  if Sys.big_endian then set_int16_ne b i (swap16 x)\n  else set_int16_ne b i x\n\nlet set_int16_be b i x =\n  if not Sys.big_endian then set_int16_ne b i (swap16 x)\n  else set_int16_ne b i x\n\nlet set_int32_le b i x =\n  if Sys.big_endian then set_int32_ne b i (swap32 x)\n  else set_int32_ne b i x\n\nlet set_int32_be b i x =\n  if not Sys.big_endian then set_int32_ne b i (swap32 x)\n  else set_int32_ne b i x\n\nlet set_int64_le b i x =\n  if Sys.big_endian then set_int64_ne b i (swap64 x)\n  else set_int64_ne b i x\n\nlet set_int64_be b i x =\n  if not Sys.big_endian then set_int64_ne b i (swap64 x)\n  else set_int64_ne b i x\n\nlet set_uint8 = set_int8\nlet set_uint16_ne = set_int16_ne\nlet set_uint16_be = set_int16_be\nlet set_uint16_le = set_int16_le\n\n(* UTF codecs and validations *)\n\nlet dec_invalid = Uchar.utf_decode_invalid\nlet[@inline] dec_ret n u = Uchar.utf_decode n (Uchar.unsafe_of_int u)\n\n(* In case of decoding error, if we error on the first byte, we\n   consume the byte, otherwise we consume the [n] bytes preceeding\n   the erroring byte.\n\n   This means that if a client uses decodes without caring about\n   validity it naturally replace bogus data with Uchar.rep according\n   to the WHATWG Encoding standard. Other schemes are possible by\n   consulting the number of used bytes on invalid decodes. For more\n   details see https://hsivonen.fi/broken-utf-8/\n\n   For this reason in [get_utf_8_uchar] we gradually check the next\n   byte is available rather than doing it immediately after the\n   first byte. Contrast with [is_valid_utf_8]. *)\n\n(* UTF-8 *)\n\nlet[@inline] not_in_x80_to_xBF b = b lsr 6 <> 0b10\nlet[@inline] not_in_xA0_to_xBF b = b lsr 5 <> 0b101\nlet[@inline] not_in_x80_to_x9F b = b lsr 5 <> 0b100\nlet[@inline] not_in_x90_to_xBF b = b < 0x90 || 0xBF < b\nlet[@inline] not_in_x80_to_x8F b = b lsr 4 <> 0x8\n\nlet[@inline] utf_8_uchar_2 b0 b1 =\n  ((b0 land 0x1F) lsl 6) lor\n  ((b1 land 0x3F))\n\nlet[@inline] utf_8_uchar_3 b0 b1 b2 =\n  ((b0 land 0x0F) lsl 12) lor\n  ((b1 land 0x3F) lsl 6) lor\n  ((b2 land 0x3F))\n\nlet[@inline] utf_8_uchar_4 b0 b1 b2 b3 =\n  ((b0 land 0x07) lsl 18) lor\n  ((b1 land 0x3F) lsl 12) lor\n  ((b2 land 0x3F) lsl 6) lor\n  ((b3 land 0x3F))\n\nlet get_utf_8_uchar b i =\n  let b0 = get_uint8 b i in (* raises if [i] is not a valid index. *)\n  let get = unsafe_get_uint8 in\n  let max = length b - 1 in\n  match Char.unsafe_chr b0 with (* See The Unicode Standard, Table 3.7 *)\n  | '\\x00' .. '\\x7F' -> dec_ret 1 b0\n  | '\\xC2' .. '\\xDF' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x80_to_xBF b1 then dec_invalid 1 else\n      dec_ret 2 (utf_8_uchar_2 b0 b1)\n  | '\\xE0' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_xA0_to_xBF b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      dec_ret 3 (utf_8_uchar_3 b0 b1 b2)\n  | '\\xE1' .. '\\xEC' | '\\xEE' .. '\\xEF' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x80_to_xBF b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      dec_ret 3 (utf_8_uchar_3 b0 b1 b2)\n  | '\\xED' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x80_to_x9F b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      dec_ret 3 (utf_8_uchar_3 b0 b1 b2)\n  | '\\xF0' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x90_to_xBF b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      let i = i + 1 in if i > max then dec_invalid 3 else\n      let b3 = get b i in if not_in_x80_to_xBF b3 then dec_invalid 3 else\n      dec_ret 4 (utf_8_uchar_4 b0 b1 b2 b3)\n  | '\\xF1' .. '\\xF3' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x80_to_xBF b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      let i = i + 1 in if i > max then dec_invalid 3 else\n      let b3 = get b i in if not_in_x80_to_xBF b3 then dec_invalid 3 else\n      dec_ret 4 (utf_8_uchar_4 b0 b1 b2 b3)\n  | '\\xF4' ->\n      let i = i + 1 in if i > max then dec_invalid 1 else\n      let b1 = get b i in if not_in_x80_to_x8F b1 then dec_invalid 1 else\n      let i = i + 1 in if i > max then dec_invalid 2 else\n      let b2 = get b i in if not_in_x80_to_xBF b2 then dec_invalid 2 else\n      let i = i + 1 in if i > max then dec_invalid 3 else\n      let b3 = get b i in if not_in_x80_to_xBF b3 then dec_invalid 3 else\n      dec_ret 4 (utf_8_uchar_4 b0 b1 b2 b3)\n  | _ -> dec_invalid 1\n\nlet set_utf_8_uchar b i u =\n  let set = unsafe_set_uint8 in\n  let max = length b - 1 in\n  match Uchar.to_int u with\n  | u when u < 0 -> assert false\n  | u when u <= 0x007F ->\n      set_uint8 b i u;\n      1\n  | u when u <= 0x07FF ->\n      let last = i + 1 in\n      if last > max then 0 else\n      (set_uint8 b i (0xC0 lor (u lsr 6));\n       set b last (0x80 lor (u land 0x3F));\n       2)\n  | u when u <= 0xFFFF ->\n      let last = i + 2 in\n      if last > max then 0 else\n      (set_uint8 b i (0xE0 lor (u lsr 12));\n       set b (i + 1) (0x80 lor ((u lsr 6) land 0x3F));\n       set b last (0x80 lor (u land 0x3F));\n       3)\n  | u when u <= 0x10FFFF ->\n      let last = i + 3 in\n      if last > max then 0 else\n      (set_uint8 b i (0xF0 lor (u lsr 18));\n       set b (i + 1) (0x80 lor ((u lsr 12) land 0x3F));\n       set b (i + 2) (0x80 lor ((u lsr 6) land 0x3F));\n       set b last (0x80 lor (u land 0x3F));\n       4)\n  | _ -> assert false\n\nlet is_valid_utf_8 b =\n  let rec loop max b i =\n    if i > max then true else\n    let get = unsafe_get_uint8 in\n    match Char.unsafe_chr (get b i) with\n    | '\\x00' .. '\\x7F' -> loop max b (i + 1)\n    | '\\xC2' .. '\\xDF' ->\n        let last = i + 1 in\n        if last > max\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xE0' ->\n        let last = i + 2 in\n        if last > max\n        || not_in_xA0_to_xBF (get b (i + 1))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xE1' .. '\\xEC' | '\\xEE' .. '\\xEF' ->\n        let last = i + 2 in\n        if last > max\n        || not_in_x80_to_xBF (get b (i + 1))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xED' ->\n        let last = i + 2 in\n        if last > max\n        || not_in_x80_to_x9F (get b (i + 1))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xF0' ->\n        let last = i + 3 in\n        if last > max\n        || not_in_x90_to_xBF (get b (i + 1))\n        || not_in_x80_to_xBF (get b (i + 2))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xF1' .. '\\xF3' ->\n        let last = i + 3 in\n        if last > max\n        || not_in_x80_to_xBF (get b (i + 1))\n        || not_in_x80_to_xBF (get b (i + 2))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | '\\xF4' ->\n        let last = i + 3 in\n        if last > max\n        || not_in_x80_to_x8F (get b (i + 1))\n        || not_in_x80_to_xBF (get b (i + 2))\n        || not_in_x80_to_xBF (get b last)\n        then false\n        else loop max b (last + 1)\n    | _ -> false\n  in\n  loop (length b - 1) b 0\n\n(* UTF-16BE *)\n\nlet get_utf_16be_uchar b i =\n  let get = unsafe_get_uint16_be in\n  let max = length b - 1 in\n  if i < 0 || i > max then invalid_arg \"index out of bounds\" else\n  if i = max then dec_invalid 1 else\n  match get b i with\n  | u when u < 0xD800 || u > 0xDFFF -> dec_ret 2 u\n  | u when u > 0xDBFF -> dec_invalid 2\n  | hi -> (* combine [hi] with a low surrogate *)\n      let last = i + 3 in\n      if last > max then dec_invalid (max - i + 1) else\n      match get b (i + 2) with\n      | u when u < 0xDC00 || u > 0xDFFF -> dec_invalid 2 (* retry here *)\n      | lo ->\n          let u = (((hi land 0x3FF) lsl 10) lor (lo land 0x3FF)) + 0x10000 in\n          dec_ret 4 u\n\nlet set_utf_16be_uchar b i u =\n  let set = unsafe_set_uint16_be in\n  let max = length b - 1 in\n  if i < 0 || i > max then invalid_arg \"index out of bounds\" else\n  match Uchar.to_int u with\n  | u when u < 0 -> assert false\n  | u when u <= 0xFFFF ->\n      let last = i + 1 in\n      if last > max then 0 else (set b i u; 2)\n  | u when u <= 0x10FFFF ->\n      let last = i + 3 in\n      if last > max then 0 else\n      let u' = u - 0x10000 in\n      let hi = (0xD800 lor (u' lsr 10)) in\n      let lo = (0xDC00 lor (u' land 0x3FF)) in\n      set b i hi; set b (i + 2) lo; 4\n  | _ -> assert false\n\nlet is_valid_utf_16be b =\n  let rec loop max b i =\n    let get = unsafe_get_uint16_be in\n    if i > max then true else\n    if i = max then false else\n    match get b i with\n    | u when u < 0xD800 || u > 0xDFFF -> loop max b (i + 2)\n    | u when u > 0xDBFF -> false\n    | _hi ->\n        let last = i + 3 in\n        if last > max then false else\n        match get b (i + 2) with\n        | u when u < 0xDC00 || u > 0xDFFF -> false\n        | _lo -> loop max b (i + 4)\n  in\n  loop (length b - 1) b 0\n\n(* UTF-16LE *)\n\nlet get_utf_16le_uchar b i =\n  let get = unsafe_get_uint16_le in\n  let max = length b - 1 in\n  if i < 0 || i > max then invalid_arg \"index out of bounds\" else\n  if i = max then dec_invalid 1 else\n  match get b i with\n  | u when u < 0xD800 || u > 0xDFFF -> dec_ret 2 u\n  | u when u > 0xDBFF -> dec_invalid 2\n  | hi -> (* combine [hi] with a low surrogate *)\n      let last = i + 3 in\n      if last > max then dec_invalid (max - i + 1) else\n      match get b (i + 2) with\n      | u when u < 0xDC00 || u > 0xDFFF -> dec_invalid 2 (* retry here *)\n      | lo ->\n          let u = (((hi land 0x3FF) lsl 10) lor (lo land 0x3FF)) + 0x10000 in\n          dec_ret 4 u\n\nlet set_utf_16le_uchar b i u =\n  let set = unsafe_set_uint16_le in\n  let max = length b - 1 in\n  if i < 0 || i > max then invalid_arg \"index out of bounds\" else\n  match Uchar.to_int u with\n  | u when u < 0 -> assert false\n  | u when u <= 0xFFFF ->\n      let last = i + 1 in\n      if last > max then 0 else (set b i u; 2)\n  | u when u <= 0x10FFFF ->\n      let last = i + 3 in\n      if last > max then 0 else\n      let u' = u - 0x10000 in\n      let hi = (0xD800 lor (u' lsr 10)) in\n      let lo = (0xDC00 lor (u' land 0x3FF)) in\n      set b i hi; set b (i + 2) lo; 4\n  | _ -> assert false\n\nlet is_valid_utf_16le b =\n  let rec loop max b i =\n    let get = unsafe_get_uint16_le in\n    if i > max then true else\n    if i = max then false else\n    match get b i with\n    | u when u < 0xD800 || u > 0xDFFF -> loop max b (i + 2)\n    | u when u > 0xDBFF -> false\n    | _hi ->\n        let last = i + 3 in\n        if last > max then false else\n        match get b (i + 2) with\n        | u when u < 0xDC00 || u > 0xDFFF -> false\n        | _lo -> loop max b (i + 4)\n  in\n  loop (length b - 1) b 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*           Damien Doligez, projet Gallium, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* String operations, based on byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in bytes.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in bytes.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : string -> int = \"%string_length\"\nexternal get : string -> int -> char = \"%string_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%string_safe_set\"\nexternal create : int -> bytes = \"caml_create_string\"\nexternal unsafe_get : string -> int -> char = \"%string_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%string_unsafe_set\"\nexternal unsafe_blit : string -> int ->  bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_string\" [@@noalloc]\n\nmodule B = Bytes\n\nlet bts = B.unsafe_to_string\nlet bos = B.unsafe_of_string\n\nlet make n c =\n  B.make n c |> bts\nlet init n f =\n  B.init n f |> bts\nlet empty = \"\"\nlet copy s =\n  B.copy (bos s) |> bts\nlet of_bytes = B.to_string\nlet to_bytes = B.of_string\nlet sub s ofs len =\n  B.sub (bos s) ofs len |> bts\nlet fill =\n  B.fill\nlet blit =\n  B.blit_string\n\nlet ensure_ge (x:int) y = if x >= y then x else invalid_arg \"String.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> \"\"\n  | l -> let seplen = length sep in bts @@\n          unsafe_blits\n            (B.create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\nlet cat = ( ^ )\n\n(* duplicated in bytes.ml *)\nlet iter f s =\n  for i = 0 to length s - 1 do f (unsafe_get s i) done\n\n(* duplicated in bytes.ml *)\nlet iteri f s =\n  for i = 0 to length s - 1 do f i (unsafe_get s i) done\n\nlet map f s =\n  B.map f (bos s) |> bts\nlet mapi f s =\n  B.mapi f (bos s) |> bts\nlet fold_right f x a =\n  B.fold_right f (bos x) a\nlet fold_left f a x =\n  B.fold_left f a (bos x)\nlet exists f s =\n  B.exists f (bos s)\nlet for_all f s =\n  B.for_all f (bos s)\n\n(* Beware: we cannot use B.trim or B.escape because they always make a\n   copy, but String.mli spells out some cases where we are not allowed\n   to make a copy. *)\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  if s = \"\" then s\n  else if is_space (unsafe_get s 0) || is_space (unsafe_get s (length s - 1))\n    then bts (B.trim (bos s))\n  else s\n\nlet escaped s =\n  let rec escape_if_needed s n i =\n    if i >= n then s else\n      match unsafe_get s i with\n      | '\\\"' | '\\\\' | '\\000'..'\\031' | '\\127'.. '\\255' ->\n          bts (B.escaped (bos s))\n      | _ -> escape_if_needed s n (i+1)\n  in\n  escape_if_needed s (length s) 0\n\n(* duplicated in bytes.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in bytes.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in bytes.ml *)\nlet rec index_rec_opt s lim i c =\n  if i >= lim then None else\n  if unsafe_get s i = c then Some i else index_rec_opt s lim (i + 1) c\n\n(* duplicated in bytes.ml *)\nlet index_opt s c = index_rec_opt s (length s) 0 c\n\n(* duplicated in bytes.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n    index_rec s l i c\n\n(* duplicated in bytes.ml *)\nlet index_from_opt s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.index_from_opt / Bytes.index_from_opt\"\n  else\n    index_rec_opt s l i c\n\n(* duplicated in bytes.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n(* duplicated in bytes.ml *)\nlet rec rindex_rec_opt s i c =\n  if i < 0 then None else\n  if unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_opt s c = rindex_rec_opt s (length s - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_from_opt s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from_opt / Bytes.rindex_from_opt\"\n  else\n    rindex_rec_opt s i c\n\n(* duplicated in bytes.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n(* duplicated in bytes.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in bytes.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\nlet uppercase_ascii s =\n  B.uppercase_ascii (bos s) |> bts\nlet lowercase_ascii s =\n  B.lowercase_ascii (bos s) |> bts\nlet capitalize_ascii s =\n  B.capitalize_ascii (bos s) |> bts\nlet uncapitalize_ascii s =\n  B.uncapitalize_ascii (bos s) |> bts\n\n(* duplicated in bytes.ml *)\nlet starts_with ~prefix s =\n  let len_s = length s\n  and len_pre = length prefix in\n  let rec aux i =\n    if i = len_pre then true\n    else if unsafe_get s i <> unsafe_get prefix i then false\n    else aux (i + 1)\n  in len_s >= len_pre && aux 0\n\n(* duplicated in bytes.ml *)\nlet ends_with ~suffix s =\n  let len_s = length s\n  and len_suf = length suffix in\n  let diff = len_s - len_suf in\n  let rec aux i =\n    if i = len_suf then true\n    else if unsafe_get s (diff + i) <> unsafe_get suffix i then false\n    else aux (i + 1)\n  in diff >= 0 && aux 0\n\n(* duplicated in bytes.ml *)\nlet split_on_char sep s =\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if unsafe_get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s =\n  B.uppercase (bos s) |> bts\nlet lowercase s =\n  B.lowercase (bos s) |> bts\nlet capitalize s =\n  B.capitalize (bos s) |> bts\nlet uncapitalize s =\n  B.uncapitalize (bos s) |> bts\n\ntype t = string\n\nlet compare (x: t) (y: t) = Stdlib.compare x y\nexternal equal : string -> string -> bool = \"caml_string_equal\" [@@noalloc]\n\n(** {1 Iterators} *)\n\nlet to_seq s = bos s |> B.to_seq\n\nlet to_seqi s = bos s |> B.to_seqi\n\nlet of_seq g = B.of_seq g |> bts\n\n(* UTF decoders and validators *)\n\nlet get_utf_8_uchar s i = B.get_utf_8_uchar (bos s) i\nlet is_valid_utf_8 s = B.is_valid_utf_8 (bos s)\n\nlet get_utf_16be_uchar s i = B.get_utf_16be_uchar (bos s) i\nlet is_valid_utf_16be s = B.is_valid_utf_16be (bos s)\n\nlet get_utf_16le_uchar s i = B.get_utf_16le_uchar (bos s) i\nlet is_valid_utf_16le s = B.is_valid_utf_16le (bos s)\n\n(** {6 Binary encoding/decoding of integers} *)\n\nexternal get_uint8 : string -> int -> int = \"%string_safe_get\"\nexternal get_uint16_ne : string -> int -> int = \"%caml_string_get16\"\nexternal get_int32_ne : string -> int -> int32 = \"%caml_string_get32\"\nexternal get_int64_ne : string -> int -> int64 = \"%caml_string_get64\"\n\nlet get_int8 s i = B.get_int8 (bos s) i\nlet get_uint16_le s i = B.get_uint16_le (bos s) i\nlet get_uint16_be s i = B.get_uint16_be (bos s) i\nlet get_int16_ne s i = B.get_int16_ne (bos s) i\nlet get_int16_le s i = B.get_int16_le (bos s) i\nlet get_int16_be s i = B.get_int16_be (bos s) i\nlet get_int32_le s i = B.get_int32_le (bos s) i\nlet get_int32_be s i = B.get_int32_be (bos s) i\nlet get_int64_le s i = B.get_int64_le (bos s) i\nlet get_int64_be s i = B.get_int64_be (bos s) i\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* An alias for the type of arrays. *)\ntype 'a t = 'a array\n\n(* Array operations *)\n\nexternal length : 'a array -> int = \"%array_length\"\nexternal get: 'a array -> int -> 'a = \"%array_safe_get\"\nexternal set: 'a array -> int -> 'a -> unit = \"%array_safe_set\"\nexternal unsafe_get: 'a array -> int -> 'a = \"%array_unsafe_get\"\nexternal unsafe_set: 'a array -> int -> 'a -> unit = \"%array_unsafe_set\"\nexternal make: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal create: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal unsafe_sub : 'a array -> int -> int -> 'a array = \"caml_array_sub\"\nexternal append_prim : 'a array -> 'a array -> 'a array = \"caml_array_append\"\nexternal concat : 'a array list -> 'a array = \"caml_array_concat\"\nexternal unsafe_blit :\n  'a array -> int -> 'a array -> int -> int -> unit = \"caml_array_blit\"\nexternal unsafe_fill :\n  'a array -> int -> int -> 'a -> unit = \"caml_array_fill\"\nexternal create_float: int -> float array = \"caml_make_float_vect\"\nlet make_float = create_float\n\nmodule Floatarray = struct\n  external create : int -> floatarray = \"caml_floatarray_create\"\n  external length : floatarray -> int = \"%floatarray_length\"\n  external get : floatarray -> int -> float = \"%floatarray_safe_get\"\n  external set : floatarray -> int -> float -> unit = \"%floatarray_safe_set\"\n  external unsafe_get : floatarray -> int -> float = \"%floatarray_unsafe_get\"\n  external unsafe_set : floatarray -> int -> float -> unit\n      = \"%floatarray_unsafe_set\"\nend\n\nlet init l f =\n  if l = 0 then [||] else\n  if l < 0 then invalid_arg \"Array.init\"\n  (* See #6575. We could also check for maximum array size, but this depends\n     on whether we create a float array or a regular one... *)\n  else\n   let res = create l (f 0) in\n   for i = 1 to pred l do\n     unsafe_set res i (f i)\n   done;\n   res\n\nlet make_matrix sx sy init =\n  let res = create sx [||] in\n  for x = 0 to pred sx do\n    unsafe_set res x (create sy init)\n  done;\n  res\n\nlet create_matrix = make_matrix\n\nlet copy a =\n  let l = length a in if l = 0 then [||] else unsafe_sub a 0 l\n\nlet append a1 a2 =\n  let l1 = length a1 in\n  if l1 = 0 then copy a2\n  else if length a2 = 0 then unsafe_sub a1 0 l1\n  else append_prim a1 a2\n\nlet sub a ofs len =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.sub\"\n  else unsafe_sub a ofs len\n\nlet fill a ofs len v =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.fill\"\n  else unsafe_fill a ofs len v\n\nlet blit a1 ofs1 a2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length a1 - len\n             || ofs2 < 0 || ofs2 > length a2 - len\n  then invalid_arg \"Array.blit\"\n  else unsafe_blit a1 ofs1 a2 ofs2 len\n\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\nlet iter2 f a b =\n  if length a <> length b then\n    invalid_arg \"Array.iter2: arrays must have the same length\"\n  else\n    for i = 0 to length a - 1 do f (unsafe_get a i) (unsafe_get b i) done\n\nlet map f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f(unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f(unsafe_get a i))\n    done;\n    r\n  end\n\nlet map2 f a b =\n  let la = length a in\n  let lb = length b in\n  if la <> lb then\n    invalid_arg \"Array.map2: arrays must have the same length\"\n  else begin\n    if la = 0 then [||] else begin\n      let r = create la (f (unsafe_get a 0) (unsafe_get b 0)) in\n      for i = 1 to la - 1 do\n        unsafe_set r i (f (unsafe_get a i) (unsafe_get b i))\n      done;\n      r\n    end\n  end\n\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet mapi f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f 0 (unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f i (unsafe_get a i))\n    done;\n    r\n  end\n\nlet to_list a =\n  let rec tolist i res =\n    if i < 0 then res else tolist (i - 1) (unsafe_get a i :: res) in\n  tolist (length a - 1) []\n\n(* Cannot use List.length here because the List module depends on Array. *)\nlet rec list_length accu = function\n  | [] -> accu\n  | _::t -> list_length (succ accu) t\n\nlet of_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let a = create (list_length 0 l) hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i+1) tl in\n      fill 1 tl\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_left_map f acc input_array =\n  let len = length input_array in\n  if len = 0 then (acc, [||]) else begin\n    let acc, elt = f acc (unsafe_get input_array 0) in\n    let output_array = create len elt in\n    let acc = ref acc in\n    for i = 1 to len - 1 do\n      let acc', elt = f !acc (unsafe_get input_array i) in\n      acc := acc';\n      unsafe_set output_array i elt;\n    done;\n    !acc, output_array\n  end\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nlet exists p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if p (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nlet for_all p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then true\n    else if p (unsafe_get a i) then loop (succ i)\n    else false in\n  loop 0\n\nlet for_all2 p l1 l2 =\n  let n1 = length l1\n  and n2 = length l2 in\n  if n1 <> n2 then invalid_arg \"Array.for_all2\"\n  else let rec loop i =\n    if i = n1 then true\n    else if p (unsafe_get l1 i) (unsafe_get l2 i) then loop (succ i)\n    else false in\n  loop 0\n\nlet exists2 p l1 l2 =\n  let n1 = length l1\n  and n2 = length l2 in\n  if n1 <> n2 then invalid_arg \"Array.exists2\"\n  else let rec loop i =\n    if i = n1 then false\n    else if p (unsafe_get l1 i) (unsafe_get l2 i) then true\n    else loop (succ i) in\n  loop 0\n\nlet mem x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if compare (unsafe_get a i) x = 0 then true\n    else loop (succ i) in\n  loop 0\n\nlet memq x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if x == (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nlet find_opt p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then None\n    else\n      let x = unsafe_get a i in\n      if p x then Some x\n      else loop (succ i)\n  in\n  loop 0\n\nlet find_map f a =\n  let n = length a in\n  let rec loop i =\n    if i = n then None\n    else\n      match f (unsafe_get a i) with\n      | None -> loop (succ i)\n      | Some _ as r -> r\n  in\n  loop 0\n\nlet split x =\n  if x = [||] then [||], [||]\n  else begin\n    let a0, b0 = unsafe_get x 0 in\n    let n = length x in\n    let a = create n a0 in\n    let b = create n b0 in\n    for i = 1 to n - 1 do\n      let ai, bi = unsafe_get x i in\n      unsafe_set a i ai;\n      unsafe_set b i bi\n    done;\n    a, b\n  end\n\nlet combine a b =\n  let na = length a in\n  let nb = length b in\n  if na <> nb then invalid_arg \"Array.combine\";\n  if na = 0 then [||]\n  else begin\n    let x = create na (unsafe_get a 0, unsafe_get b 0) in\n    for i = 1 to na - 1 do\n      unsafe_set x i (unsafe_get a i, unsafe_get b i)\n    done;\n    x\n  end\n\nexception Bottom of int\nlet sort cmp a =\n  let maxson l i =\n    let i31 = i+i+i+1 in\n    let x = ref i31 in\n    if i31+2 < l then begin\n      if cmp (get a i31) (get a (i31+1)) < 0 then x := i31+1;\n      if cmp (get a !x) (get a (i31+2)) < 0 then x := i31+2;\n      !x\n    end else\n      if i31+1 < l && cmp (get a i31) (get a (i31+1)) < 0\n      then i31+1\n      else if i31 < l then i31 else raise (Bottom i)\n  in\n  let rec trickledown l i e =\n    let j = maxson l i in\n    if cmp (get a j) e > 0 then begin\n      set a i (get a j);\n      trickledown l j e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let trickle l i e = try trickledown l i e with Bottom i -> set a i e in\n  let rec bubbledown l i =\n    let j = maxson l i in\n    set a i (get a j);\n    bubbledown l j\n  in\n  let bubble l i = try bubbledown l i with Bottom i -> i in\n  let rec trickleup i e =\n    let father = (i - 1) / 3 in\n    assert (i <> father);\n    if cmp (get a father) e < 0 then begin\n      set a i (get a father);\n      if father > 0 then trickleup father e else set a 0 e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let l = length a in\n  for i = (l + 1) / 3 - 1 downto 0 do trickle l i (get a i); done;\n  for i = l - 1 downto 2 do\n    let e = (get a i) in\n    set a i (get a 0);\n    trickleup (bubble i 0) e;\n  done;\n  if l > 1 then (let e = (get a 1) in set a 1 (get a 0); set a 0 e)\n\n\nlet cutoff = 5\nlet stable_sort cmp a =\n  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =\n    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in\n    let rec loop i1 s1 i2 s2 d =\n      if cmp s1 s2 <= 0 then begin\n        set dst d s1;\n        let i1 = i1 + 1 in\n        if i1 < src1r then\n          loop i1 (get a i1) i2 s2 (d + 1)\n        else\n          blit src2 i2 dst (d + 1) (src2r - i2)\n      end else begin\n        set dst d s2;\n        let i2 = i2 + 1 in\n        if i2 < src2r then\n          loop i1 s1 i2 (get src2 i2) (d + 1)\n        else\n          blit a i1 dst (d + 1) (src1r - i1)\n      end\n    in loop src1ofs (get a src1ofs) src2ofs (get src2 src2ofs) dstofs;\n  in\n  let isortto srcofs dst dstofs len =\n    for i = 0 to len - 1 do\n      let e = (get a (srcofs + i)) in\n      let j = ref (dstofs + i - 1) in\n      while (!j >= dstofs && cmp (get dst !j) e > 0) do\n        set dst (!j + 1) (get dst !j);\n        decr j;\n      done;\n      set dst (!j + 1) e;\n    done;\n  in\n  let rec sortto srcofs dst dstofs len =\n    if len <= cutoff then isortto srcofs dst dstofs len else begin\n      let l1 = len / 2 in\n      let l2 = len - l1 in\n      sortto (srcofs + l1) dst (dstofs + l1) l2;\n      sortto srcofs a (srcofs + l2) l1;\n      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs;\n    end;\n  in\n  let l = length a in\n  if l <= cutoff then isortto 0 a 0 l else begin\n    let l1 = l / 2 in\n    let l2 = l - l1 in\n    let t = make l2 (get a 0) in\n    sortto l1 t 0 l2;\n    sortto 0 a l2 l1;\n    merge l2 l1 t 0 l2 a 0;\n  end\n\n\nlet fast_sort = stable_sort\n\n(** {1 Iterators} *)\n\nlet to_seq a =\n  let rec aux i () =\n    if i < length a\n    then\n      let x = unsafe_get a i in\n      Seq.Cons (x, aux (i+1))\n    else Seq.Nil\n  in\n  aux 0\n\nlet to_seqi a =\n  let rec aux i () =\n    if i < length a\n    then\n      let x = unsafe_get a i in\n      Seq.Cons ((i,x), aux (i+1))\n    else Seq.Nil\n  in\n  aux 0\n\nlet of_rev_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let len = list_length 0 l in\n      let a = create len hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i-1) tl\n      in\n      fill (len-2) tl\n\nlet of_seq i =\n  let l = Seq.fold_left (fun acc x -> x::acc) [] i in\n  of_rev_list l\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type !+'a t\n    val empty: 'a t\n    val is_empty: 'a t -> bool\n    val mem:  key -> 'a t -> bool\n    val add: key -> 'a -> 'a t -> 'a t\n    val update: key -> ('a option -> 'a option) -> 'a t -> 'a t\n    val singleton: key -> 'a -> 'a t\n    val remove: key -> 'a t -> 'a t\n    val merge:\n          (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t\n    val union: (key -> 'a -> 'a -> 'a option) -> 'a t -> 'a t -> 'a t\n    val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int\n    val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val for_all: (key -> 'a -> bool) -> 'a t -> bool\n    val exists: (key -> 'a -> bool) -> 'a t -> bool\n    val filter: (key -> 'a -> bool) -> 'a t -> 'a t\n    val filter_map: (key -> 'a -> 'b option) -> 'a t -> 'b t\n    val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t\n    val cardinal: 'a t -> int\n    val bindings: 'a t -> (key * 'a) list\n    val min_binding: 'a t -> (key * 'a)\n    val min_binding_opt: 'a t -> (key * 'a) option\n    val max_binding: 'a t -> (key * 'a)\n    val max_binding_opt: 'a t -> (key * 'a) option\n    val choose: 'a t -> (key * 'a)\n    val choose_opt: 'a t -> (key * 'a) option\n    val split: key -> 'a t -> 'a t * 'a option * 'a t\n    val find: key -> 'a t -> 'a\n    val find_opt: key -> 'a t -> 'a option\n    val find_first: (key -> bool) -> 'a t -> key * 'a\n    val find_first_opt: (key -> bool) -> 'a t -> (key * 'a) option\n    val find_last: (key -> bool) -> 'a t -> key * 'a\n    val find_last_opt: (key -> bool) -> 'a t -> (key * 'a) option\n    val map: ('a -> 'b) -> 'a t -> 'b t\n    val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_rev_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_from : key -> 'a t -> (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -> 'a t -> 'a t\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule Make(Ord: OrderedType) = struct\n\n    type key = Ord.t\n\n    type 'a t =\n        Empty\n      | Node of {l:'a t; v:key; d:'a; r:'a t; h:int}\n\n    let height = function\n        Empty -> 0\n      | Node {h} -> h\n\n    let create l x d r =\n      let hl = height l and hr = height r in\n      Node{l; v=x; d; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    let singleton x d = Node{l=Empty; v=x; d; r=Empty; h=1}\n\n    let bal l x d r =\n      let hl = match l with Empty -> 0 | Node {h} -> h in\n      let hr = match r with Empty -> 0 | Node {h} -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node{l=ll; v=lv; d=ld; r=lr} ->\n            if height ll >= height lr then\n              create ll lv ld (create lr x d r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node{l=lrl; v=lrv; d=lrd; r=lrr}->\n                  create (create ll lv ld lrl) lrv lrd (create lrr x d r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node{l=rl; v=rv; d=rd; r=rr} ->\n            if height rr >= height rl then\n              create (create l x d rl) rv rd rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node{l=rll; v=rlv; d=rld; r=rlr} ->\n                  create (create l x d rll) rlv rld (create rlr rv rd rr)\n            end\n      end else\n        Node{l; v=x; d; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec add x data = function\n        Empty ->\n          Node{l=Empty; v=x; d=data; r=Empty; h=1}\n      | Node {l; v; d; r; h} as m ->\n          let c = Ord.compare x v in\n          if c = 0 then\n            if d == data then m else Node{l; v=x; d=data; r; h}\n          else if c < 0 then\n            let ll = add x data l in\n            if l == ll then m else bal ll v d r\n          else\n            let rr = add x data r in\n            if r == rr then m else bal l v d rr\n\n    let rec find x = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then d\n          else find x (if c < 0 then l else r)\n\n    let rec find_first_aux v0 d0 f = function\n        Empty ->\n          (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_aux v d f l\n          else\n            find_first_aux v0 d0 f r\n\n    let rec find_first f = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_aux v d f l\n          else\n            find_first f r\n\n    let rec find_first_opt_aux v0 d0 f = function\n        Empty ->\n          Some (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_opt_aux v d f l\n          else\n            find_first_opt_aux v0 d0 f r\n\n    let rec find_first_opt f = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_opt_aux v d f l\n          else\n            find_first_opt f r\n\n    let rec find_last_aux v0 d0 f = function\n        Empty ->\n          (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_aux v d f r\n          else\n            find_last_aux v0 d0 f l\n\n    let rec find_last f = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_aux v d f r\n          else\n            find_last f l\n\n    let rec find_last_opt_aux v0 d0 f = function\n        Empty ->\n          Some (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_opt_aux v d f r\n          else\n            find_last_opt_aux v0 d0 f l\n\n    let rec find_last_opt f = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_opt_aux v d f r\n          else\n            find_last_opt f l\n\n    let rec find_opt x = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then Some d\n          else find_opt x (if c < 0 then l else r)\n\n    let rec mem x = function\n        Empty ->\n          false\n      | Node {l; v; r} ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec min_binding = function\n        Empty -> raise Not_found\n      | Node {l=Empty; v; d} -> (v, d)\n      | Node {l} -> min_binding l\n\n    let rec min_binding_opt = function\n        Empty -> None\n      | Node {l=Empty; v; d} -> Some (v, d)\n      | Node {l}-> min_binding_opt l\n\n    let rec max_binding = function\n        Empty -> raise Not_found\n      | Node {v; d; r=Empty} -> (v, d)\n      | Node {r} -> max_binding r\n\n    let rec max_binding_opt = function\n        Empty -> None\n      | Node {v; d; r=Empty} -> Some (v, d)\n      | Node {r} -> max_binding_opt r\n\n    let rec remove_min_binding = function\n        Empty -> invalid_arg \"Map.remove_min_elt\"\n      | Node {l=Empty; r} -> r\n      | Node {l; v; d; r} -> bal (remove_min_binding l) v d r\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          bal t1 x d (remove_min_binding t2)\n\n    let rec remove x = function\n        Empty ->\n          Empty\n      | (Node {l; v; d; r} as m) ->\n          let c = Ord.compare x v in\n          if c = 0 then merge l r\n          else if c < 0 then\n            let ll = remove x l in if l == ll then m else bal ll v d r\n          else\n            let rr = remove x r in if r == rr then m else bal l v d rr\n\n    let rec update x f = function\n        Empty ->\n          begin match f None with\n          | None -> Empty\n          | Some data -> Node{l=Empty; v=x; d=data; r=Empty; h=1}\n          end\n      | Node {l; v; d; r; h} as m ->\n          let c = Ord.compare x v in\n          if c = 0 then begin\n            match f (Some d) with\n            | None -> merge l r\n            | Some data ->\n                if d == data then m else Node{l; v=x; d=data; r; h}\n          end else if c < 0 then\n            let ll = update x f l in\n            if l == ll then m else bal ll v d r\n          else\n            let rr = update x f r in\n            if r == rr then m else bal l v d rr\n\n    let rec iter f = function\n        Empty -> ()\n      | Node {l; v; d; r} ->\n          iter f l; f v d; iter f r\n\n    let rec map f = function\n        Empty ->\n          Empty\n      | Node {l; v; d; r; h} ->\n          let l' = map f l in\n          let d' = f d in\n          let r' = map f r in\n          Node{l=l'; v; d=d'; r=r'; h}\n\n    let rec mapi f = function\n        Empty ->\n          Empty\n      | Node {l; v; d; r; h} ->\n          let l' = mapi f l in\n          let d' = f v d in\n          let r' = mapi f r in\n          Node{l=l'; v; d=d'; r=r'; h}\n\n    let rec fold f m accu =\n      match m with\n        Empty -> accu\n      | Node {l; v; d; r} ->\n          fold f r (f v d (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node {l; v; d; r} -> p v d && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node {l; v; d; r} -> p v d || exists p l || exists p r\n\n    (* Beware: those two functions assume that the added k is *strictly*\n       smaller (or bigger) than all the present keys in the tree; it\n       does not test for equality with the current min (or max) key.\n\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_binding k x = function\n      | Empty -> singleton k x\n      | Node {l; v; d; r} ->\n        bal (add_min_binding k x l) v d r\n\n    let rec add_max_binding k x = function\n      | Empty -> singleton k x\n      | Node {l; v; d; r} ->\n        bal l v d (add_max_binding k x r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v d r =\n      match (l, r) with\n        (Empty, _) -> add_min_binding v d r\n      | (_, Empty) -> add_max_binding v d l\n      | (Node{l=ll; v=lv; d=ld; r=lr; h=lh},\n         Node{l=rl; v=rv; d=rd; r=rr; h=rh}) ->\n          if lh > rh + 2 then bal ll lv ld (join lr v d r) else\n          if rh > lh + 2 then bal (join l v d rl) rv rd rr else\n          create l v d r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          join t1 x d (remove_min_binding t2)\n\n    let concat_or_join t1 v d t2 =\n      match d with\n      | Some d -> join t1 v d t2\n      | None -> concat t1 t2\n\n    let rec split x = function\n        Empty ->\n          (Empty, None, Empty)\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, Some d, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v d r)\n          else\n            let (lr, pres, rr) = split x r in (join l v d lr, pres, rr)\n\n    let rec merge f s1 s2 =\n      match (s1, s2) with\n        (Empty, Empty) -> Empty\n      | (Node {l=l1; v=v1; d=d1; r=r1; h=h1}, _) when h1 >= height s2 ->\n          let (l2, d2, r2) = split v1 s2 in\n          concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)\n      | (_, Node {l=l2; v=v2; d=d2; r=r2}) ->\n          let (l1, d1, r1) = split v2 s1 in\n          concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)\n      | _ ->\n          assert false\n\n    let rec union f s1 s2 =\n      match (s1, s2) with\n      | (Empty, s) | (s, Empty) -> s\n      | (Node {l=l1; v=v1; d=d1; r=r1; h=h1},\n         Node {l=l2; v=v2; d=d2; r=r2; h=h2}) ->\n          if h1 >= h2 then\n            let (l2, d2, r2) = split v1 s2 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d2 with\n            | None -> join l v1 d1 r\n            | Some d2 -> concat_or_join l v1 (f v1 d1 d2) r\n          else\n            let (l1, d1, r1) = split v2 s1 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d1 with\n            | None -> join l v2 d2 r\n            | Some d1 -> concat_or_join l v2 (f v2 d1 d2) r\n\n    let rec filter p = function\n        Empty -> Empty\n      | Node {l; v; d; r} as m ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pvd = p v d in\n          let r' = filter p r in\n          if pvd then if l==l' && r==r' then m else join l' v d r'\n          else concat l' r'\n\n    let rec filter_map f = function\n        Empty -> Empty\n      | Node {l; v; d; r} ->\n          (* call [f] in the expected left-to-right order *)\n          let l' = filter_map f l in\n          let fvd = f v d in\n          let r' = filter_map f r in\n          begin match fvd with\n            | Some d' -> join l' v d' r'\n            | None -> concat l' r'\n          end\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node {l; v; d; r} ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pvd = p v d in\n          let (rt, rf) = partition p r in\n          if pvd\n          then (join lt v d rt, concat lf rf)\n          else (concat lt rt, join lf v d rf)\n\n    type 'a enumeration = End | More of key * 'a * 'a t * 'a enumeration\n\n    let rec cons_enum m e =\n      match m with\n        Empty -> e\n      | Node {l; v; d; r} -> cons_enum l (More(v, d, r, e))\n\n    let compare cmp m1 m2 =\n      let rec compare_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> 0\n        | (End, _)  -> -1\n        | (_, End) -> 1\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            let c = Ord.compare v1 v2 in\n            if c <> 0 then c else\n            let c = cmp d1 d2 in\n            if c <> 0 then c else\n            compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in compare_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let equal cmp m1 m2 =\n      let rec equal_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> true\n        | (End, _)  -> false\n        | (_, End) -> false\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            Ord.compare v1 v2 = 0 && cmp d1 d2 &&\n            equal_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in equal_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node {l; r} -> cardinal l + 1 + cardinal r\n\n    let rec bindings_aux accu = function\n        Empty -> accu\n      | Node {l; v; d; r} -> bindings_aux ((v, d) :: bindings_aux accu r) l\n\n    let bindings s =\n      bindings_aux [] s\n\n    let choose = min_binding\n\n    let choose_opt = min_binding_opt\n\n    let add_seq i m =\n      Seq.fold_left (fun m (k,v) -> add k v m) m i\n\n    let of_seq i = add_seq i empty\n\n    let rec seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (k,v,t,rest) -> Seq.Cons ((k,v), seq_of_enum_ (cons_enum t rest))\n\n    let to_seq m =\n      seq_of_enum_ (cons_enum m End)\n\n    let rec snoc_enum s e =\n      match s with\n        Empty -> e\n      | Node{l; v; d; r} -> snoc_enum r (More(v, d, l, e))\n\n    let rec rev_seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (k,v,t,rest) ->\n          Seq.Cons ((k,v), rev_seq_of_enum_ (snoc_enum t rest))\n\n    let to_rev_seq c =\n      rev_seq_of_enum_ (snoc_enum c End)\n\n    let to_seq_from low m =\n      let rec aux low m c = match m with\n        | Empty -> c\n        | Node {l; v; d; r; _} ->\n            begin match Ord.compare v low with\n              | 0 -> More (v, d, r, c)\n              | n when n<0 -> aux low r c\n              | _ -> aux low l (More (v, d, r, c))\n            end\n      in\n      seq_of_enum_ (aux low m End)\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype 'a t = { mutable c : 'a list; mutable len : int; }\n\nexception Empty\n\nlet create () = { c = []; len = 0; }\n\nlet clear s = s.c <- []; s.len <- 0\n\nlet copy s = { c = s.c; len = s.len; }\n\nlet push x s = s.c <- x :: s.c; s.len <- s.len + 1\n\nlet pop s =\n  match s.c with\n  | hd::tl -> s.c <- tl; s.len <- s.len - 1; hd\n  | []     -> raise Empty\n\nlet pop_opt s =\n  match s.c with\n  | hd::tl -> s.c <- tl; s.len <- s.len - 1; Some hd\n  | []     -> None\n\nlet top s =\n  match s.c with\n  | hd::_ -> hd\n  | []    -> raise Empty\n\nlet top_opt s =\n  match s.c with\n  | hd::_ -> Some hd\n  | []    -> None\n\nlet is_empty s = (s.c = [])\n\nlet length s = s.len\n\nlet iter f s = List.iter f s.c\n\nlet fold f acc s = List.fold_left f acc s.c\n\n(** {1 Iterators} *)\n\nlet to_seq s = List.to_seq s.c\n\nlet add_seq q i = Seq.iter (fun x -> push x q) i\n\nlet of_seq g =\n  let s = create() in\n  add_seq s g;\n  s\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*         Francois Pottier, projet Cristal, INRIA Rocquencourt           *)\n(*                  Jeremie Dimino, Jane Street Europe                    *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nexception Empty\n\ntype 'a cell =\n  | Nil\n  | Cons of { content: 'a; mutable next: 'a cell }\n\ntype 'a t = {\n  mutable length: int;\n  mutable first: 'a cell;\n  mutable last: 'a cell\n}\n\nlet create () = {\n  length = 0;\n  first = Nil;\n  last = Nil\n}\n\nlet clear q =\n  q.length <- 0;\n  q.first <- Nil;\n  q.last <- Nil\n\nlet add x q =\n  let cell = Cons {\n    content = x;\n    next = Nil\n  } in\n  match q.last with\n  | Nil ->\n    q.length <- 1;\n    q.first <- cell;\n    q.last <- cell\n  | Cons last ->\n    q.length <- q.length + 1;\n    last.next <- cell;\n    q.last <- cell\n\nlet push =\n  add\n\nlet peek q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content } -> content\n\nlet peek_opt q =\n  match q.first with\n  | Nil -> None\n  | Cons { content } -> Some content\n\nlet top =\n  peek\n\nlet take q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content; next = Nil } ->\n    clear q;\n    content\n  | Cons { content; next } ->\n    q.length <- q.length - 1;\n    q.first <- next;\n    content\n\nlet take_opt q =\n  match q.first with\n  | Nil -> None\n  | Cons { content; next = Nil } ->\n    clear q;\n    Some content\n  | Cons { content; next } ->\n    q.length <- q.length - 1;\n    q.first <- next;\n    Some content\n\nlet pop =\n  take\n\nlet copy =\n  let rec copy q_res prev cell =\n    match cell with\n    | Nil -> q_res.last <- prev; q_res\n    | Cons { content; next } ->\n      let res = Cons { content; next = Nil } in\n      begin match prev with\n      | Nil -> q_res.first <- res\n      | Cons p -> p.next <- res\n      end;\n      copy q_res res next\n  in\n  fun q -> copy { length = q.length; first = Nil; last = Nil } Nil q.first\n\nlet is_empty q =\n  q.length = 0\n\nlet length q =\n  q.length\n\nlet iter =\n  let rec iter f cell =\n    match cell with\n    | Nil -> ()\n    | Cons { content; next } ->\n      f content;\n      iter f next\n  in\n  fun f q -> iter f q.first\n\nlet fold =\n  let rec fold f accu cell =\n    match cell with\n    | Nil -> accu\n    | Cons { content; next } ->\n      let accu = f accu content in\n      fold f accu next\n  in\n  fun f accu q -> fold f accu q.first\n\nlet transfer q1 q2 =\n  if q1.length > 0 then\n    match q2.last with\n    | Nil ->\n      q2.length <- q1.length;\n      q2.first <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n    | Cons last ->\n      q2.length <- q2.length + q1.length;\n      last.next <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n\n(** {1 Iterators} *)\n\nlet to_seq q =\n  let rec aux c () = match c with\n    | Nil -> Seq.Nil\n    | Cons { content=x; next; } -> Seq.Cons (x, aux next)\n  in\n  aux q.first\n\nlet add_seq q i = Seq.iter (fun x -> push x q) i\n\nlet of_seq g =\n  let q = create() in\n  add_seq q g;\n  q\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*    Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt    *)\n(*                                                                        *)\n(*   Copyright 1999 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Extensible buffers *)\n\ntype t =\n {mutable buffer : bytes;\n  mutable position : int;\n  mutable length : int;\n  initial_buffer : bytes}\n(* Invariants: all parts of the code preserve the invariants that:\n   - [0 <= b.position <= b.length]\n   - [b.length = Bytes.length b.buffer]\n\n   Note in particular that [b.position = b.length] is legal,\n   it means that the buffer is full and will have to be extended\n   before any further addition. *)\n\nlet create n =\n let n = if n < 1 then 1 else n in\n let n = if n > Sys.max_string_length then Sys.max_string_length else n in\n let s = Bytes.create n in\n {buffer = s; position = 0; length = n; initial_buffer = s}\n\nlet contents b = Bytes.sub_string b.buffer 0 b.position\nlet to_bytes b = Bytes.sub b.buffer 0 b.position\n\nlet sub b ofs len =\n  if ofs < 0 || len < 0 || ofs > b.position - len\n  then invalid_arg \"Buffer.sub\"\n  else Bytes.sub_string b.buffer ofs len\n\n\nlet blit src srcoff dst dstoff len =\n  if len < 0 || srcoff < 0 || srcoff > src.position - len\n             || dstoff < 0 || dstoff > (Bytes.length dst) - len\n  then invalid_arg \"Buffer.blit\"\n  else\n    Bytes.unsafe_blit src.buffer srcoff dst dstoff len\n\n\nlet nth b ofs =\n  if ofs < 0 || ofs >= b.position then\n   invalid_arg \"Buffer.nth\"\n  else Bytes.unsafe_get b.buffer ofs\n\n\nlet length b = b.position\n\nlet clear b = b.position <- 0\n\nlet reset b =\n  b.position <- 0;\n  b.buffer <- b.initial_buffer;\n  b.length <- Bytes.length b.buffer\n\n(* [resize b more] ensures that [b.position + more <= b.length] holds\n   by dynamically extending [b.buffer] if necessary -- and thus\n   increasing [b.length].\n\n   In particular, after [resize b more] is called, a direct access of\n   size [more] at [b.position] will always be in-bounds, so that\n   (unsafe_{get,set}) may be used for performance.\n*)\nlet resize b more =\n  let old_pos = b.position in\n  let old_len = b.length in\n  let new_len = ref old_len in\n  while old_pos + more > !new_len do new_len := 2 * !new_len done;\n  if !new_len > Sys.max_string_length then begin\n    if old_pos + more <= Sys.max_string_length\n    then new_len := Sys.max_string_length\n    else failwith \"Buffer.add: cannot grow buffer\"\n  end;\n  let new_buffer = Bytes.create !new_len in\n  (* PR#6148: let's keep using [blit] rather than [unsafe_blit] in\n     this tricky function that is slow anyway. *)\n  Bytes.blit b.buffer 0 new_buffer 0 b.position;\n  b.buffer <- new_buffer;\n  b.length <- !new_len;\n  assert (b.position + more <= b.length);\n  assert (old_pos + more <= b.length);\n  ()\n  (* Note: there are various situations (preemptive threads, signals and\n     gc finalizers) where OCaml code may be run asynchronously; in\n     particular, there may be a race with another user of [b], changing\n     its mutable fields in the middle of the [resize] call. The Buffer\n     module does not provide any correctness guarantee if that happens,\n     but we must still ensure that the datastructure invariants hold for\n     memory-safety -- as we plan to use [unsafe_{get,set}].\n\n     There are two potential allocation points in this function,\n     [ref] and [Bytes.create], but all reads and writes to the fields\n     of [b] happen before both of them or after both of them.\n\n     We therefore assume that [b.position] may change at these allocations,\n     and check that the [b.position + more <= b.length] postcondition\n     holds for both values of [b.position], before or after the function\n     is called. More precisely, the following invariants must hold if the\n     function returns correctly, in addition to the usual buffer invariants:\n     - [old(b.position) + more <= new(b.length)]\n     - [new(b.position) + more <= new(b.length)]\n     - [old(b.length) <= new(b.length)]\n\n     Note: [b.position + more <= old(b.length)] does *not*\n     hold in general, as it is precisely the case where you need\n     to call [resize] to increase [b.length].\n\n     Note: [assert] above does not mean that we know the conditions\n     always hold, but that the function may return correctly\n     only if they hold.\n\n     Note: the other functions in this module does not need\n     to be checked with this level of scrutiny, given that they\n     read/write the buffer immediately after checking that\n     [b.position + more <= b.length] hold or calling [resize].\n  *)\n\nlet add_char b c =\n  let pos = b.position in\n  if pos >= b.length then resize b 1;\n  Bytes.unsafe_set b.buffer pos c;\n  b.position <- pos + 1\n\nlet uchar_utf_8_byte_length_max = 4\nlet uchar_utf_16_byte_length_max = 4\n\nlet rec add_utf_8_uchar b u =\n  let pos = b.position in\n  if pos >= b.length then resize b uchar_utf_8_byte_length_max;\n  let n = Bytes.set_utf_8_uchar b.buffer pos u in\n  if n = 0\n  then (resize b uchar_utf_8_byte_length_max; add_utf_8_uchar b u)\n  else (b.position <- pos + n)\n\nlet rec add_utf_16be_uchar b u =\n  let pos = b.position in\n  if pos >= b.length then resize b uchar_utf_16_byte_length_max;\n  let n = Bytes.set_utf_16be_uchar b.buffer pos u in\n  if n = 0\n  then (resize b uchar_utf_16_byte_length_max; add_utf_16be_uchar b u)\n  else (b.position <- pos + n)\n\nlet rec add_utf_16le_uchar b u =\n  let pos = b.position in\n  if pos >= b.length then resize b uchar_utf_16_byte_length_max;\n  let n = Bytes.set_utf_16le_uchar b.buffer pos u in\n  if n = 0\n  then (resize b uchar_utf_16_byte_length_max; add_utf_16le_uchar b u)\n  else (b.position <- pos + n)\n\nlet add_substring b s offset len =\n  if offset < 0 || len < 0 || offset > String.length s - len\n  then invalid_arg \"Buffer.add_substring/add_subbytes\";\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.unsafe_blit_string s offset b.buffer b.position len;\n  b.position <- new_position\n\nlet add_subbytes b s offset len =\n  add_substring b (Bytes.unsafe_to_string s) offset len\n\nlet add_string b s =\n  let len = String.length s in\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.unsafe_blit_string s 0 b.buffer b.position len;\n  b.position <- new_position\n\nlet add_bytes b s = add_string b (Bytes.unsafe_to_string s)\n\nlet add_buffer b bs =\n  add_subbytes b bs.buffer 0 bs.position\n\n(* this (private) function could move into the standard library *)\nlet really_input_up_to ic buf ofs len =\n  let rec loop ic buf ~already_read ~ofs ~to_read =\n    if to_read = 0 then already_read\n    else begin\n      let r = input ic buf ofs to_read in\n      if r = 0 then already_read\n      else begin\n        let already_read = already_read + r in\n        let ofs = ofs + r in\n        let to_read = to_read - r in\n        loop ic buf ~already_read ~ofs ~to_read\n      end\n    end\n  in loop ic buf ~already_read:0 ~ofs ~to_read:len\n\n\nlet unsafe_add_channel_up_to b ic len =\n  if b.position + len > b.length then resize b len;\n  let n = really_input_up_to ic b.buffer b.position len in\n  (* The assertion below may fail in weird scenario where\n     threaded/finalizer code, run asynchronously during the\n     [really_input_up_to] call, races on the buffer; we don't ensure\n     correctness in this case, but need to preserve the invariants for\n     memory-safety (see discussion of [resize]). *)\n  assert (b.position + n <= b.length);\n  b.position <- b.position + n;\n  n\n\nlet add_channel b ic len =\n  if len < 0 || len > Sys.max_string_length then   (* PR#5004 *)\n    invalid_arg \"Buffer.add_channel\";\n  let n = unsafe_add_channel_up_to b ic len in\n  (* It is intentional that a consumer catching End_of_file\n     will see the data written (see #6719, #7136). *)\n  if n < len then raise End_of_file;\n  ()\n\nlet output_buffer oc b =\n  output oc b.buffer 0 b.position\n\nlet closing = function\n  | '(' -> ')'\n  | '{' -> '}'\n  | _ -> assert false\n\n(* opening and closing: open and close characters, typically ( and )\n   k: balance of opening and closing chars\n   s: the string where we are searching\n   start: the index where we start the search. *)\nlet advance_to_closing opening closing k s start =\n  let rec advance k i lim =\n    if i >= lim then raise Not_found else\n    if s.[i] = opening then advance (k + 1) (i + 1) lim else\n    if s.[i] = closing then\n      if k = 0 then i else advance (k - 1) (i + 1) lim\n    else advance k (i + 1) lim in\n  advance k start (String.length s)\n\nlet advance_to_non_alpha s start =\n  let rec advance i lim =\n    if i >= lim then lim else\n    match s.[i] with\n    | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' -> advance (i + 1) lim\n    | _ -> i in\n  advance start (String.length s)\n\n(* We are just at the beginning of an ident in s, starting at start. *)\nlet find_ident s start lim =\n  if start >= lim then raise Not_found else\n  match s.[start] with\n  (* Parenthesized ident ? *)\n  | '(' | '{' as c ->\n     let new_start = start + 1 in\n     let stop = advance_to_closing c (closing c) 0 s new_start in\n     String.sub s new_start (stop - start - 1), stop + 1\n  (* Regular ident *)\n  | _ ->\n     let stop = advance_to_non_alpha s (start + 1) in\n     String.sub s start (stop - start), stop\n\n(* Substitute $ident, $(ident), or ${ident} in s,\n    according to the function mapping f. *)\nlet add_substitute b f s =\n  let lim = String.length s in\n  let rec subst previous i =\n    if i < lim then begin\n      match s.[i] with\n      | '$' as current when previous = '\\\\' ->\n         add_char b current;\n         subst ' ' (i + 1)\n      | '$' ->\n         let j = i + 1 in\n         let ident, next_i = find_ident s j lim in\n         add_string b (f ident);\n         subst ' ' next_i\n      | current when previous == '\\\\' ->\n         add_char b '\\\\';\n         add_char b current;\n         subst ' ' (i + 1)\n      | '\\\\' as current ->\n         subst current (i + 1)\n      | current ->\n         add_char b current;\n         subst current (i + 1)\n    end else\n    if previous = '\\\\' then add_char b previous in\n  subst ' ' 0\n\nlet truncate b len =\n    if len < 0 || len > length b then\n      invalid_arg \"Buffer.truncate\"\n    else\n      b.position <- len\n\n(** {1 Iterators} *)\n\nlet to_seq b =\n  let rec aux i () =\n    (* Note that b.position is not a constant and cannot be lifted out of aux *)\n    if i >= b.position then Seq.Nil\n    else\n      let x = Bytes.unsafe_get b.buffer i in\n      Seq.Cons (x, aux (i+1))\n  in\n  aux 0\n\nlet to_seqi b =\n  let rec aux i () =\n    (* Note that b.position is not a constant and cannot be lifted out of aux *)\n    if i >= b.position then Seq.Nil\n    else\n      let x = Bytes.unsafe_get b.buffer i in\n      Seq.Cons ((i,x), aux (i+1))\n  in\n  aux 0\n\nlet add_seq b seq = Seq.iter (add_char b) seq\n\nlet of_seq i =\n  let b = create 32 in\n  add_seq b i;\n  b\n\n(** {6 Binary encoding of integers} *)\n\nexternal unsafe_set_int8 : bytes -> int -> int -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_set_int16 : bytes -> int -> int -> unit = \"%caml_bytes_set16u\"\nexternal unsafe_set_int32 : bytes -> int -> int32 -> unit = \"%caml_bytes_set32u\"\nexternal unsafe_set_int64 : bytes -> int -> int64 -> unit = \"%caml_bytes_set64u\"\nexternal swap16 : int -> int = \"%bswap16\"\nexternal swap32 : int32 -> int32 = \"%bswap_int32\"\nexternal swap64 : int64 -> int64 = \"%bswap_int64\"\n\n\nlet add_int8 b x =\n  let new_position = b.position + 1 in\n  if new_position > b.length then resize b 1;\n  unsafe_set_int8 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int16_ne b x =\n  let new_position = b.position + 2 in\n  if new_position > b.length then resize b 2;\n  unsafe_set_int16 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int32_ne b x =\n  let new_position = b.position + 4 in\n  if new_position > b.length then resize b 4;\n  unsafe_set_int32 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int64_ne b x =\n  let new_position = b.position + 8 in\n  if new_position > b.length then resize b 8;\n  unsafe_set_int64 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int16_le b x =\n  add_int16_ne b (if Sys.big_endian then swap16 x else x)\n\nlet add_int16_be b x =\n  add_int16_ne b (if Sys.big_endian then x else swap16 x)\n\nlet add_int32_le b x =\n  add_int32_ne b (if Sys.big_endian then swap32 x else x)\n\nlet add_int32_be b x =\n  add_int32_ne b (if Sys.big_endian then x else swap32 x)\n\nlet add_int64_le b x =\n  add_int64_ne b (if Sys.big_endian then swap64 x else x)\n\nlet add_int64_be b x =\n  add_int64_ne b (if Sys.big_endian then x else swap64 x)\n\nlet add_uint8 = add_int8\nlet add_uint16_ne = add_int16_ne\nlet add_uint16_le = add_int16_le\nlet add_uint16_be = add_int16_be\n","let utf8_of_code buf x =\n  let add = Buffer.add_char in\n\n  (* Straight <= doesn't work with signed 31-bit ints *)\n  let maxbits n x = x lsr n = 0 in\n\n  if maxbits 7 x then (* 7 *)\n    add buf (Char.chr x)\n  else if maxbits 11 x then (\n    (* 5 + 6 *)\n    add buf (Char.chr (0b11000000 lor ((x lsr 6) land 0b00011111)));\n    add buf (Char.chr (0b10000000 lor (x land 0b00111111))))\n  else if maxbits 16 x then (\n    (* 4 + 6 + 6 *)\n    add buf (Char.chr (0b11100000 lor ((x lsr 12) land 0b00001111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 6) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor (x land 0b00111111))))\n  else if maxbits 21 x then (\n    (* 3 + 6 + 6 + 6 *)\n    add buf (Char.chr (0b11110000 lor ((x lsr 18) land 0b00000111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 12) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 6) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor (x land 0b00111111))))\n  else if maxbits 26 x then (\n    (* 2 + 6 + 6 + 6 + 6 *)\n    add buf (Char.chr (0b11111000 lor ((x lsr 24) land 0b00000011)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 18) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 12) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 6) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor (x land 0b00111111))))\n  else (\n    assert (maxbits 31 x);\n    (* 1 + 6 + 6 + 6 + 6 + 6 *)\n    add buf (Char.chr (0b11111100 lor ((x lsr 30) land 0b00000001)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 24) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 18) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 12) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor ((x lsr 6) land 0b00111111)));\n    add buf (Char.chr (0b10000000 lor (x land 0b00111111))))\n\nlet code_of_surrogate_pair i j =\n  let high10 = i - 0xD800 in\n  let low10 = j - 0xDC00 in\n  0x10000 + ((high10 lsl 10) lor low10)\n\nlet utf8_of_surrogate_pair buf i j =\n  utf8_of_code buf (code_of_surrogate_pair i j)\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*   Xavier Leroy and Pierre Weis, projet Cristal, INRIA Rocquencourt     *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\nlet kfprintf k o (Format (fmt, _)) =\n  make_printf (fun acc -> output_acc o acc; k o) End_of_acc fmt\nlet kbprintf k b (Format (fmt, _)) =\n  make_printf (fun acc -> bufput_acc b acc; k b) End_of_acc fmt\nlet ikfprintf k oc (Format (fmt, _)) =\n  make_iprintf k oc fmt\nlet ikbprintf = ikfprintf\n\nlet fprintf oc fmt = kfprintf ignore oc fmt\nlet bprintf b fmt = kbprintf ignore b fmt\nlet ifprintf oc fmt = ikfprintf ignore oc fmt\nlet ibprintf b fmt = ikbprintf ignore b fmt\nlet printf fmt = fprintf stdout fmt\nlet eprintf fmt = fprintf stderr fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let k' acc =\n    let buf = Buffer.create 64 in\n    strput_acc buf acc;\n    k (Buffer.contents buf) in\n  make_printf k' End_of_acc fmt\n\nlet sprintf fmt = ksprintf (fun s -> s) fmt\n\nlet kprintf = ksprintf\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*               Damien Doligez, projet Para, INRIA Rocquencourt          *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Pseudo-random number generator\n   This is a lagged-Fibonacci F(55, 24, +) with a modified addition\n   function to enhance the mixing of bits.\n   If we use normal addition, the low-order bit fails tests 1 and 7\n   of the Diehard test suite, and bits 1 and 2 also fail test 7.\n   If we use multiplication as suggested by Marsaglia, it doesn't fare\n   much better.\n   By mixing the bits of one of the numbers before addition (XOR the\n   5 high-order bits into the low-order bits), we get a generator that\n   passes all the Diehard tests.\n*)\n\nexternal random_seed: unit -> int array = \"caml_sys_random_seed\"\n\nmodule State = struct\n\n  type t = { st : int array; mutable idx : int }\n\n  let new_state () = { st = Array.make 55 0; idx = 0 }\n  let assign st1 st2 =\n    Array.blit st2.st 0 st1.st 0 55;\n    st1.idx <- st2.idx\n\n\n  let full_init s seed =\n    let combine accu x = Digest.string (accu ^ Int.to_string x) in\n    let extract d =\n      Char.code d.[0] + (Char.code d.[1] lsl 8) + (Char.code d.[2] lsl 16)\n      + (Char.code d.[3] lsl 24)\n    in\n    let seed = if Array.length seed = 0 then [| 0 |] else seed in\n    let l = Array.length seed in\n    for i = 0 to 54 do\n      s.st.(i) <- i;\n    done;\n    let accu = ref \"x\" in\n    for i = 0 to 54 + Int.max 55 l do\n      let j = i mod 55 in\n      let k = i mod l in\n      accu := combine !accu seed.(k);\n      s.st.(j) <- (s.st.(j) lxor extract !accu) land 0x3FFFFFFF;  (* PR#5575 *)\n    done;\n    s.idx <- 0\n\n\n  let make seed =\n    let result = new_state () in\n    full_init result seed;\n    result\n\n\n  let make_self_init () = make (random_seed ())\n\n  let copy s =\n    let result = new_state () in\n    assign result s;\n    result\n\n\n  (* Returns 30 random bits as an integer 0 <= x < 1073741824 *)\n  let bits s =\n    s.idx <- (s.idx + 1) mod 55;\n    let curval = s.st.(s.idx) in\n    let newval = s.st.((s.idx + 24) mod 55)\n                 + (curval lxor ((curval lsr 25) land 0x1F)) in\n    let newval30 = newval land 0x3FFFFFFF in  (* PR#5575 *)\n    s.st.(s.idx) <- newval30;\n    newval30\n\n\n  let rec intaux s n =\n    let r = bits s in\n    let v = r mod n in\n    if r - v > 0x3FFFFFFF - n + 1 then intaux s n else v\n\n  let int s bound =\n    if bound > 0x3FFFFFFF || bound <= 0\n    then invalid_arg \"Random.int\"\n    else intaux s bound\n\n  let rec int63aux s n =\n    let max_int_32 = (1 lsl 30) + 0x3FFFFFFF in (* 0x7FFFFFFF *)\n    let b1 = bits s in\n    let b2 = bits s in\n    let (r, max_int) =\n      if n <= max_int_32 then\n        (* 31 random bits on both 64-bit OCaml and JavaScript.\n           Use upper 15 bits of b1 and 16 bits of b2. *)\n        let bpos =\n          (((b2 land 0x3FFFC000) lsl 1) lor (b1 lsr 15))\n        in\n          (bpos, max_int_32)\n      else\n        let b3 = bits s in\n        (* 62 random bits on 64-bit OCaml; unreachable on JavaScript.\n           Use upper 20 bits of b1 and 21 bits of b2 and b3. *)\n        let bpos =\n          ((((b3 land 0x3FFFFE00) lsl 12) lor (b2 lsr 9)) lsl 20)\n            lor (b1 lsr 10)\n        in\n          (bpos, max_int)\n    in\n    let v = r mod n in\n    if r - v > max_int - n + 1 then int63aux s n else v\n\n  let full_int s bound =\n    if bound <= 0 then\n      invalid_arg \"Random.full_int\"\n    else if bound > 0x3FFFFFFF then\n      int63aux s bound\n    else\n      intaux s bound\n\n\n  let rec int32aux s n =\n    let b1 = Int32.of_int (bits s) in\n    let b2 = Int32.shift_left (Int32.of_int (bits s land 1)) 30 in\n    let r = Int32.logor b1 b2 in\n    let v = Int32.rem r n in\n    if Int32.sub r v > Int32.add (Int32.sub Int32.max_int n) 1l\n    then int32aux s n\n    else v\n\n  let int32 s bound =\n    if bound <= 0l\n    then invalid_arg \"Random.int32\"\n    else int32aux s bound\n\n\n  let rec int64aux s n =\n    let b1 = Int64.of_int (bits s) in\n    let b2 = Int64.shift_left (Int64.of_int (bits s)) 30 in\n    let b3 = Int64.shift_left (Int64.of_int (bits s land 7)) 60 in\n    let r = Int64.logor b1 (Int64.logor b2 b3) in\n    let v = Int64.rem r n in\n    if Int64.sub r v > Int64.add (Int64.sub Int64.max_int n) 1L\n    then int64aux s n\n    else v\n\n  let int64 s bound =\n    if bound <= 0L\n    then invalid_arg \"Random.int64\"\n    else int64aux s bound\n\n\n  let nativeint =\n    if Nativeint.size = 32\n    then fun s bound -> Nativeint.of_int32 (int32 s (Nativeint.to_int32 bound))\n    else fun s bound -> Int64.to_nativeint (int64 s (Int64.of_nativeint bound))\n\n\n  (* Returns a float 0 <= x <= 1 with at most 60 bits of precision. *)\n  let rawfloat s =\n    let scale = 1073741824.0  (* 2^30 *)\n    and r1 = Stdlib.float (bits s)\n    and r2 = Stdlib.float (bits s)\n    in (r1 /. scale +. r2) /. scale\n\n\n  let float s bound = rawfloat s *. bound\n\n  let bool s = (bits s land 1 = 0)\n\n  let bits32 s =\n    let b1 = Int32.(shift_right_logical (of_int (bits s)) 14) in  (* 16 bits *)\n    let b2 = Int32.(shift_right_logical (of_int (bits s)) 14) in  (* 16 bits *)\n    Int32.(logor b1 (shift_left b2 16))\n\n  let bits64 s =\n    let b1 = Int64.(shift_right_logical (of_int (bits s)) 9) in  (* 21 bits *)\n    let b2 = Int64.(shift_right_logical (of_int (bits s)) 9) in  (* 21 bits *)\n    let b3 = Int64.(shift_right_logical (of_int (bits s)) 8) in  (* 22 bits *)\n    Int64.(logor b1 (logor (shift_left b2 21) (shift_left b3 42)))\n\n  let nativebits =\n    if Nativeint.size = 32\n    then fun s -> Nativeint.of_int32 (bits32 s)\n    else fun s -> Int64.to_nativeint (bits64 s)\n\nend\n\n(* This is the state you get with [init 27182818] and then applying\n   the \"land 0x3FFFFFFF\" filter to them.  See #5575, #5793, #5977. *)\nlet default = {\n  State.st = [|\n      0x3ae2522b; 0x1d8d4634; 0x15b4fad0; 0x18b14ace; 0x12f8a3c4; 0x3b086c47;\n      0x16d467d6; 0x101d91c7; 0x321df177; 0x0176c193; 0x1ff72bf1; 0x1e889109;\n      0x0b464b18; 0x2b86b97c; 0x0891da48; 0x03137463; 0x085ac5a1; 0x15d61f2f;\n      0x3bced359; 0x29c1c132; 0x3a86766e; 0x366d8c86; 0x1f5b6222; 0x3ce1b59f;\n      0x2ebf78e1; 0x27cd1b86; 0x258f3dc3; 0x389a8194; 0x02e4c44c; 0x18c43f7d;\n      0x0f6e534f; 0x1e7df359; 0x055d0b7e; 0x10e84e7e; 0x126198e4; 0x0e7722cb;\n      0x1cbede28; 0x3391b964; 0x3d40e92a; 0x0c59933d; 0x0b8cd0b7; 0x24efff1c;\n      0x2803fdaa; 0x08ebc72e; 0x0f522e32; 0x05398edc; 0x2144a04c; 0x0aef3cbd;\n      0x01ad4719; 0x35b93cd6; 0x2a559d4f; 0x1e6fd768; 0x26e27f36; 0x186f18c3;\n      0x2fbf967a;\n    |];\n  State.idx = 0;\n}\n\nlet bits () = State.bits default\nlet int bound = State.int default bound\nlet full_int bound = State.full_int default bound\nlet int32 bound = State.int32 default bound\nlet nativeint bound = State.nativeint default bound\nlet int64 bound = State.int64 default bound\nlet float scale = State.float default scale\nlet bool () = State.bool default\nlet bits32 () = State.bits32 default\nlet bits64 () = State.bits64 default\nlet nativebits () = State.nativebits default\n\nlet full_init seed = State.full_init default seed\nlet init seed = State.full_init default [| seed |]\nlet self_init () = full_init (random_seed())\n\n(* Manipulating the current state. *)\n\nlet get_state () = State.copy default\nlet set_state s = State.assign default s\n\n(********************\n\n(* Test functions.  Not included in the library.\n   The [chisquare] function should be called with n > 10r.\n   It returns a triple (low, actual, high).\n   If low <= actual <= high, the [g] function passed the test,\n   otherwise it failed.\n\n  Some results:\n\ninit 27182818; chisquare int 100000 1000\ninit 27182818; chisquare int 100000 100\ninit 27182818; chisquare int 100000 5000\ninit 27182818; chisquare int 1000000 1000\ninit 27182818; chisquare int 100000 1024\ninit 299792643; chisquare int 100000 1024\ninit 14142136; chisquare int 100000 1024\ninit 27182818; init_diff 1024; chisquare diff 100000 1024\ninit 27182818; init_diff 100; chisquare diff 100000 100\ninit 27182818; init_diff2 1024; chisquare diff2 100000 1024\ninit 27182818; init_diff2 100; chisquare diff2 100000 100\ninit 14142136; init_diff2 100; chisquare diff2 100000 100\ninit 299792643; init_diff2 100; chisquare diff2 100000 100\n- : float * float * float = (936.754446796632465, 997.5, 1063.24555320336754)\n# - : float * float * float = (80., 89.7400000000052387, 120.)\n# - : float * float * float = (4858.57864376269, 5045.5, 5141.42135623731)\n# - : float * float * float =\n(936.754446796632465, 944.805999999982305, 1063.24555320336754)\n# - : float * float * float = (960., 1019.19744000000355, 1088.)\n# - : float * float * float = (960., 1059.31776000000536, 1088.)\n# - : float * float * float = (960., 1039.98463999999512, 1088.)\n# - : float * float * float = (960., 1054.38207999999577, 1088.)\n# - : float * float * float = (80., 90.096000000005, 120.)\n# - : float * float * float = (960., 1076.78720000000612, 1088.)\n# - : float * float * float = (80., 85.1760000000067521, 120.)\n# - : float * float * float = (80., 85.2160000000003492, 120.)\n# - : float * float * float = (80., 80.6220000000030268, 120.)\n\n*)\n\n(* Return the sum of the squares of v[i0,i1[ *)\nlet rec sumsq v i0 i1 =\n  if i0 >= i1 then 0.0\n  else if i1 = i0 + 1 then Stdlib.float v.(i0) *. Stdlib.float v.(i0)\n  else sumsq v i0 ((i0+i1)/2) +. sumsq v ((i0+i1)/2) i1\n\n\nlet chisquare g n r =\n  if n <= 10 * r then invalid_arg \"chisquare\";\n  let f = Array.make r 0 in\n  for i = 1 to n do\n    let t = g r in\n    f.(t) <- f.(t) + 1\n  done;\n  let t = sumsq f 0 r\n  and r = Stdlib.float r\n  and n = Stdlib.float n in\n  let sr = 2.0 *. sqrt r in\n  (r -. sr,   (r *. t /. n) -. n,   r +. sr)\n\n\n(* This is to test for linear dependencies between successive random numbers.\n*)\nlet st = ref 0\nlet init_diff r = st := int r\nlet diff r =\n  let x1 = !st\n  and x2 = int r\n  in\n  st := x2;\n  if x1 >= x2 then\n    x1 - x2\n  else\n    r + x1 - x2\n\n\nlet st1 = ref 0\nand st2 = ref 0\n\n\n(* This is to test for quadratic dependencies between successive random\n   numbers.\n*)\nlet init_diff2 r = st1 := int r; st2 := int r\nlet diff2 r =\n  let x1 = !st1\n  and x2 = !st2\n  and x3 = int r\n  in\n  st1 := x2;\n  st2 := x3;\n  (x3 - x2 - x2 + x1 + 2*r) mod r\n\n\n********************)\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Message digest (MD5) *)\n\ntype t = string\n\nlet compare = String.compare\nlet equal = String.equal\n\nexternal unsafe_string: string -> int -> int -> t = \"caml_md5_string\"\nexternal channel: in_channel -> int -> t = \"caml_md5_chan\"\n\nlet string str =\n  unsafe_string str 0 (String.length str)\n\nlet bytes b = string (Bytes.unsafe_to_string b)\n\nlet substring str ofs len =\n  if ofs < 0 || len < 0 || ofs > String.length str - len\n  then invalid_arg \"Digest.substring\"\n  else unsafe_string str ofs len\n\nlet subbytes b ofs len = substring (Bytes.unsafe_to_string b) ofs len\n\nlet file filename =\n  let ic = open_in_bin filename in\n  match channel ic (-1) with\n    | d -> close_in ic; d\n    | exception e -> close_in ic; raise e\n\nlet output chan digest =\n  output_string chan digest\n\nlet input chan = really_input_string chan 16\n\nlet char_hex n =\n  Char.unsafe_chr (n + if n < 10 then Char.code '0' else (Char.code 'a' - 10))\n\nlet to_hex d =\n  if String.length d <> 16 then invalid_arg \"Digest.to_hex\";\n  let result = Bytes.create 32 in\n  for i = 0 to 15 do\n    let x = Char.code d.[i] in\n    Bytes.unsafe_set result (i*2) (char_hex (x lsr 4));\n    Bytes.unsafe_set result (i*2+1) (char_hex (x land 0x0f));\n  done;\n  Bytes.unsafe_to_string result\n\nlet from_hex s =\n  if String.length s <> 32 then invalid_arg \"Digest.from_hex\";\n  let digit c =\n    match c with\n    | '0'..'9' -> Char.code c - Char.code '0'\n    | 'A'..'F' -> Char.code c - Char.code 'A' + 10\n    | 'a'..'f' -> Char.code c - Char.code 'a' + 10\n    | _ -> raise (Invalid_argument \"Digest.from_hex\")\n  in\n  let byte i = digit s.[i] lsl 4 + digit s.[i+1] in\n  let result = Bytes.create 16 in\n  for i = 0 to 15 do\n    Bytes.set result i (Char.chr (byte (2 * i)));\n  done;\n  Bytes.unsafe_to_string result\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Damien Doligez, projet Para, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1997 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(** Weak array operations *)\n\ntype !'a t\n\nexternal create : int -> 'a t = \"caml_weak_create\"\n\nlet create l =\n  if not (0 <= l && l <= Obj.Ephemeron.max_ephe_length) then\n    invalid_arg(\"Weak.create\");\n  create l\n\n(** number of additional values in a weak pointer *)\nlet additional_values = 2\n\nlet length x = Obj.size(Obj.repr x) - additional_values\n\nlet raise_if_invalid_offset e o msg =\n  if not (0 <= o && o < length e) then\n    invalid_arg(msg)\n\nexternal set' : 'a t -> int -> 'a -> unit = \"caml_ephe_set_key\"\nexternal unset : 'a t -> int -> unit = \"caml_ephe_unset_key\"\nlet set e o x =\n  raise_if_invalid_offset e o \"Weak.set\";\n  match x with\n  | None -> unset e o\n  | Some x -> set' e o x\n\nexternal get : 'a t -> int -> 'a option = \"caml_weak_get\"\nlet get e o =\n  raise_if_invalid_offset e o \"Weak.get\";\n  get e o\n\nexternal get_copy : 'a t -> int -> 'a option = \"caml_weak_get_copy\"\nlet get_copy e o =\n  raise_if_invalid_offset e o \"Weak.get_copy\";\n  get_copy e o\n\nexternal check : 'a t -> int -> bool = \"caml_weak_check\"\nlet check e o =\n  raise_if_invalid_offset e o \"Weak.check\";\n  check e o\n\nexternal blit : 'a t -> int -> 'a t -> int -> int -> unit = \"caml_weak_blit\"\n\n(* blit: src srcoff dst dstoff len *)\nlet blit e1 o1 e2 o2 l =\n  if l < 0 || o1 < 0 || o1 > length e1 - l\n     || o2 < 0 || o2 > length e2 - l\n  then invalid_arg \"Weak.blit\"\n  else if l <> 0 then blit e1 o1 e2 o2 l\n\nlet fill ar ofs len x =\n  if ofs < 0 || len < 0 || ofs > length ar - len\n  then raise (Invalid_argument \"Weak.fill\")\n  else begin\n    for i = ofs to (ofs + len - 1) do\n      set ar i x\n    done\n  end\n\n\n(** Weak hash tables *)\n\nmodule type S = sig\n  type data\n  type t\n  val create : int -> t\n  val clear : t -> unit\n  val merge : t -> data -> data\n  val add : t -> data -> unit\n  val remove : t -> data -> unit\n  val find : t -> data -> data\n  val find_opt : t -> data -> data option\n  val find_all : t -> data -> data list\n  val mem : t -> data -> bool\n  val iter : (data -> unit) -> t -> unit\n  val fold : (data -> 'a -> 'a) -> t -> 'a -> 'a\n  val count : t -> int\n  val stats : t -> int * int * int * int * int * int\nend\n\nmodule Make (H : Hashtbl.HashedType) : (S with type data = H.t) = struct\n\n  type 'a weak_t = 'a t\n  let weak_create = create\n  let emptybucket = weak_create 0\n\n  type data = H.t\n\n  type t = {\n    mutable table : data weak_t array;\n    mutable hashes : int array array;\n    mutable limit : int;               (* bucket size limit *)\n    mutable oversize : int;            (* number of oversize buckets *)\n    mutable rover : int;               (* for internal bookkeeping *)\n  }\n\n  let get_index t h = (h land max_int) mod (Array.length t.table)\n\n  let limit = 7\n  let over_limit = 2\n\n  let create sz =\n    let sz = if sz < 7 then 7 else sz in\n    let sz = if sz > Sys.max_array_length then Sys.max_array_length else sz in\n    {\n      table = Array.make sz emptybucket;\n      hashes = Array.make sz [| |];\n      limit = limit;\n      oversize = 0;\n      rover = 0;\n    }\n\n  let clear t =\n    for i = 0 to Array.length t.table - 1 do\n      t.table.(i) <- emptybucket;\n      t.hashes.(i) <- [| |];\n    done;\n    t.limit <- limit;\n    t.oversize <- 0\n\n\n  let fold f t init =\n    let rec fold_bucket i b accu =\n      if i >= length b then accu else\n      match get b i with\n      | Some v -> fold_bucket (i+1) b (f v accu)\n      | None -> fold_bucket (i+1) b accu\n    in\n    Array.fold_right (fold_bucket 0) t.table init\n\n\n  let iter f t =\n    let rec iter_bucket i b =\n      if i >= length b then () else\n      match get b i with\n      | Some v -> f v; iter_bucket (i+1) b\n      | None -> iter_bucket (i+1) b\n    in\n    Array.iter (iter_bucket 0) t.table\n\n\n  let iter_weak f t =\n    let rec iter_bucket i j b =\n      if i >= length b then () else\n      match check b i with\n      | true -> f b t.hashes.(j) i; iter_bucket (i+1) j b\n      | false -> iter_bucket (i+1) j b\n    in\n    Array.iteri (iter_bucket 0) t.table\n\n\n  let rec count_bucket i b accu =\n    if i >= length b then accu else\n    count_bucket (i+1) b (accu + (if check b i then 1 else 0))\n\n\n  let count t =\n    Array.fold_right (count_bucket 0) t.table 0\n\n\n  let next_sz n = Int.min (3 * n / 2 + 3) Sys.max_array_length\n  let prev_sz n = ((n - 3) * 2 + 2) / 3\n\n  let test_shrink_bucket t =\n    let bucket = t.table.(t.rover) in\n    let hbucket = t.hashes.(t.rover) in\n    let len = length bucket in\n    let prev_len = prev_sz len in\n    let live = count_bucket 0 bucket 0 in\n    if live <= prev_len then begin\n      let rec loop i j =\n        if j >= prev_len then begin\n          if check bucket i then loop (i + 1) j\n          else if check bucket j then begin\n            blit bucket j bucket i 1;\n            hbucket.(i) <- hbucket.(j);\n            loop (i + 1) (j - 1);\n          end else loop i (j - 1);\n        end;\n      in\n      loop 0 (length bucket - 1);\n      if prev_len = 0 then begin\n        t.table.(t.rover) <- emptybucket;\n        t.hashes.(t.rover) <- [| |];\n      end else begin\n        let newbucket = weak_create prev_len in\n        blit bucket 0 newbucket 0 prev_len;\n        t.table.(t.rover) <- newbucket;\n        t.hashes.(t.rover) <- Array.sub hbucket 0 prev_len\n      end;\n      if len > t.limit && prev_len <= t.limit then t.oversize <- t.oversize - 1;\n    end;\n    t.rover <- (t.rover + 1) mod (Array.length t.table)\n\n\n  let rec resize t =\n    let oldlen = Array.length t.table in\n    let newlen = next_sz oldlen in\n    if newlen > oldlen then begin\n      let newt = create newlen in\n      let add_weak ob oh oi =\n        let setter nb ni _ = blit ob oi nb ni 1 in\n        let h = oh.(oi) in\n        add_aux newt setter None h (get_index newt h);\n      in\n      iter_weak add_weak t;\n      t.table <- newt.table;\n      t.hashes <- newt.hashes;\n      t.limit <- newt.limit;\n      t.oversize <- newt.oversize;\n      t.rover <- t.rover mod Array.length newt.table;\n    end else begin\n      t.limit <- max_int;             (* maximum size already reached *)\n      t.oversize <- 0;\n    end\n\n  and add_aux t setter d h index =\n    let bucket = t.table.(index) in\n    let hashes = t.hashes.(index) in\n    let sz = length bucket in\n    let rec loop i =\n      if i >= sz then begin\n        let newsz =\n          Int.min (3 * sz / 2 + 3) (Sys.max_array_length - additional_values)\n        in\n        if newsz <= sz then failwith \"Weak.Make: hash bucket cannot grow more\";\n        let newbucket = weak_create newsz in\n        let newhashes = Array.make newsz 0 in\n        blit bucket 0 newbucket 0 sz;\n        Array.blit hashes 0 newhashes 0 sz;\n        setter newbucket sz d;\n        newhashes.(sz) <- h;\n        t.table.(index) <- newbucket;\n        t.hashes.(index) <- newhashes;\n        if sz <= t.limit && newsz > t.limit then begin\n          t.oversize <- t.oversize + 1;\n          for _i = 0 to over_limit do test_shrink_bucket t done;\n        end;\n        if t.oversize > Array.length t.table / over_limit then resize t;\n      end else if check bucket i then begin\n        loop (i + 1)\n      end else begin\n        setter bucket i d;\n        hashes.(i) <- h;\n      end;\n    in\n    loop 0\n\n\n  let add t d =\n    let h = H.hash d in\n    add_aux t set (Some d) h (get_index t h)\n\n\n  let find_or t d ifnotfound =\n    let h = H.hash d in\n    let index = get_index t h in\n    let bucket = t.table.(index) in\n    let hashes = t.hashes.(index) in\n    let sz = length bucket in\n    let rec loop i =\n      if i >= sz then ifnotfound h index\n      else if h = hashes.(i) then begin\n        match get_copy bucket i with\n        | Some v when H.equal v d\n           -> begin match get bucket i with\n              | Some v -> v\n              | None -> loop (i + 1)\n              end\n        | _ -> loop (i + 1)\n      end else loop (i + 1)\n    in\n    loop 0\n\n\n  let merge t d =\n    find_or t d (fun h index -> add_aux t set (Some d) h index; d)\n\n\n  let find t d = find_or t d (fun _h _index -> raise Not_found)\n\n  let find_opt t d =\n    let h = H.hash d in\n    let index = get_index t h in\n    let bucket = t.table.(index) in\n    let hashes = t.hashes.(index) in\n    let sz = length bucket in\n    let rec loop i =\n      if i >= sz then None\n      else if h = hashes.(i) then begin\n        match get_copy bucket i with\n        | Some v when H.equal v d\n           -> begin match get bucket i with\n              | Some _ as v -> v\n              | None -> loop (i + 1)\n              end\n        | _ -> loop (i + 1)\n      end else loop (i + 1)\n    in\n    loop 0\n\n\n  let find_shadow t d iffound ifnotfound =\n    let h = H.hash d in\n    let index = get_index t h in\n    let bucket = t.table.(index) in\n    let hashes = t.hashes.(index) in\n    let sz = length bucket in\n    let rec loop i =\n      if i >= sz then ifnotfound\n      else if h = hashes.(i) then begin\n        match get_copy bucket i with\n        | Some v when H.equal v d -> iffound bucket i\n        | _ -> loop (i + 1)\n      end else loop (i + 1)\n    in\n    loop 0\n\n\n  let remove t d = find_shadow t d (fun w i -> set w i None) ()\n\n\n  let mem t d = find_shadow t d (fun _w _i -> true) false\n\n\n  let find_all t d =\n    let h = H.hash d in\n    let index = get_index t h in\n    let bucket = t.table.(index) in\n    let hashes = t.hashes.(index) in\n    let sz = length bucket in\n    let rec loop i accu =\n      if i >= sz then accu\n      else if h = hashes.(i) then begin\n        match get_copy bucket i with\n        | Some v when H.equal v d\n           -> begin match get bucket i with\n              | Some v -> loop (i + 1) (v :: accu)\n              | None -> loop (i + 1) accu\n              end\n        | _ -> loop (i + 1) accu\n      end else loop (i + 1) accu\n    in\n    loop 0 []\n\n\n  let stats t =\n    let len = Array.length t.table in\n    let lens = Array.map length t.table in\n    Array.sort compare lens;\n    let totlen = Array.fold_left ( + ) 0 lens in\n    (len, count t, totlen, lens.(0), lens.(len/2), lens.(len-1))\n\n\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Pierre Weis, projet Cristal, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* A pretty-printing facility and definition of formatters for 'parallel'\n   (i.e. unrelated or independent) pretty-printing on multiple out channels. *)\n\n(*\n   The pretty-printing engine internal data structures.\n*)\n\nlet id x = x\n\n(* A devoted type for sizes to avoid confusion\n   between sizes and mere integers. *)\nmodule Size : sig\n  type t\n\n  val to_int : t -> int\n  val of_int : int -> t\n  val zero : t\n  val unknown : t\n  val is_known : t -> bool\nend  = struct\n  type t = int\n\n  let to_int = id\n  let of_int = id\n  let zero = 0\n  let unknown = -1\n  let is_known n = n >= 0\nend\n\n\n\n(* The pretty-printing boxes definition:\n   a pretty-printing box is either\n   - hbox: horizontal box (no line splitting)\n   - vbox: vertical box (every break hint splits the line)\n   - hvbox: horizontal/vertical box\n     (the box behaves as an horizontal box if it fits on\n      the current line, otherwise the box behaves as a vertical box)\n   - hovbox: horizontal or vertical compacting box\n     (the box is compacting material, printing as much material as possible\n      on every lines)\n   - box: horizontal or vertical compacting box with enhanced box structure\n     (the box behaves as an horizontal or vertical box but break hints split\n      the line if splitting would move to the left)\n*)\ntype box_type = CamlinternalFormatBasics.block_type =\n  | Pp_hbox | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits\n\n\n(* The pretty-printing tokens definition:\n   are either text to print or pretty printing\n   elements that drive indentation and line splitting. *)\ntype pp_token =\n  | Pp_text of string          (* normal text *)\n  | Pp_break of {              (* complete break *)\n      fits: string * int * string;   (* line is not split *)\n      breaks: string * int * string; (* line is split *)\n    }\n  | Pp_tbreak of int * int     (* go to next tabulation *)\n  | Pp_stab                    (* set a tabulation *)\n  | Pp_begin of int * box_type (* beginning of a box *)\n  | Pp_end                     (* end of a box *)\n  | Pp_tbegin of tbox          (* beginning of a tabulation box *)\n  | Pp_tend                    (* end of a tabulation box *)\n  | Pp_newline                 (* to force a newline inside a box *)\n  | Pp_if_newline              (* to do something only if this very\n                                  line has been broken *)\n  | Pp_open_tag of stag         (* opening a tag name *)\n  | Pp_close_tag               (* closing the most recently open tag *)\n\nand stag = ..\n\nand tbox = Pp_tbox of int list ref  (* Tabulation box *)\n\ntype tag = string\ntype stag += String_tag of tag\n\n\n(* The pretty-printer queue:\n   pretty-printing material is not written in the output as soon as emitted;\n   instead, the material is simply recorded in the pretty-printer queue,\n   until the enclosing box has a known computed size and proper splitting\n   decisions can be made.\n\n   The pretty-printer queue contains formatting elements to be printed.\n   Each formatting element is a tuple (size, token, length), where\n   - length is the declared length of the token,\n   - size is effective size of the token when it is printed\n     (size is set when the size of the box is known, so that size of break\n      hints are definitive). *)\ntype pp_queue_elem = {\n  mutable size : Size.t;\n  token : pp_token;\n  length : int;\n}\n\n\n(* The pretty-printer queue definition. *)\ntype pp_queue = pp_queue_elem Queue.t\n\n(* The pretty-printer scanning stack. *)\n\n(* The pretty-printer scanning stack: scanning element definition. *)\ntype pp_scan_elem = {\n  left_total : int; (* Value of pp_left_total when the element was enqueued. *)\n  queue_elem : pp_queue_elem\n}\n\n(* The pretty-printer formatting stack:\n   the formatting stack contains the description of all the currently active\n   boxes; the pretty-printer formatting stack is used to split the lines\n   while printing tokens. *)\n\n(* The pretty-printer formatting stack: formatting stack element definition.\n   Each stack element describes a pretty-printing box. *)\ntype pp_format_elem = { box_type : box_type; width : int }\n\n(* The formatter definition.\n   Each formatter value is a pretty-printer instance with all its\n   machinery. *)\ntype formatter = {\n  (* The pretty-printer scanning stack. *)\n  pp_scan_stack : pp_scan_elem Stack.t;\n  (* The pretty-printer formatting stack. *)\n  pp_format_stack : pp_format_elem Stack.t;\n  pp_tbox_stack : tbox Stack.t;\n  (* The pretty-printer semantics tag stack. *)\n  pp_tag_stack : stag Stack.t;\n  pp_mark_stack : stag Stack.t;\n  (* Value of right margin. *)\n  mutable pp_margin : int;\n  (* Minimal space left before margin, when opening a box. *)\n  mutable pp_min_space_left : int;\n  (* Maximum value of indentation:\n     no box can be opened further. *)\n  mutable pp_max_indent : int;\n  (* Space remaining on the current line. *)\n  mutable pp_space_left : int;\n  (* Current value of indentation. *)\n  mutable pp_current_indent : int;\n  (* True when the line has been broken by the pretty-printer. *)\n  mutable pp_is_new_line : bool;\n  (* Total width of tokens already printed. *)\n  mutable pp_left_total : int;\n  (* Total width of tokens ever put in queue. *)\n  mutable pp_right_total : int;\n  (* Current number of open boxes. *)\n  mutable pp_curr_depth : int;\n  (* Maximum number of boxes which can be simultaneously open. *)\n  mutable pp_max_boxes : int;\n  (* Ellipsis string. *)\n  mutable pp_ellipsis : string;\n  (* Output function. *)\n  mutable pp_out_string : string -> int -> int -> unit;\n  (* Flushing function. *)\n  mutable pp_out_flush : unit -> unit;\n  (* Output of new lines. *)\n  mutable pp_out_newline : unit -> unit;\n  (* Output of break hints spaces. *)\n  mutable pp_out_spaces : int -> unit;\n  (* Output of indentation of new lines. *)\n  mutable pp_out_indent : int -> unit;\n  (* Are tags printed ? *)\n  mutable pp_print_tags : bool;\n  (* Are tags marked ? *)\n  mutable pp_mark_tags : bool;\n  (* Find opening and closing markers of tags. *)\n  mutable pp_mark_open_tag : stag -> string;\n  mutable pp_mark_close_tag : stag -> string;\n  mutable pp_print_open_tag : stag -> unit;\n  mutable pp_print_close_tag : stag -> unit;\n  (* The pretty-printer queue. *)\n  pp_queue : pp_queue;\n}\n\n\n(* The formatter specific tag handling functions. *)\ntype formatter_stag_functions = {\n  mark_open_stag : stag -> string;\n  mark_close_stag : stag -> string;\n  print_open_stag : stag -> unit;\n  print_close_stag : stag -> unit;\n}\n\n\n(* The formatter functions to output material. *)\ntype formatter_out_functions = {\n  out_string : string -> int -> int -> unit;\n  out_flush : unit -> unit;\n  out_newline : unit -> unit;\n  out_spaces : int -> unit;\n  out_indent : int -> unit;\n}\n\n\n(*\n\n  Auxiliaries and basic functions.\n\n*)\n\n(* Enter a token in the pretty-printer queue. *)\nlet pp_enqueue state token =\n  state.pp_right_total <- state.pp_right_total + token.length;\n  Queue.add token state.pp_queue\n\n\nlet pp_clear_queue state =\n  state.pp_left_total <- 1; state.pp_right_total <- 1;\n  Queue.clear state.pp_queue\n\n\n(* Pp_infinity: large value for default tokens size.\n\n   Pp_infinity is documented as being greater than 1e10; to avoid\n   confusion about the word 'greater', we choose pp_infinity greater\n   than 1e10 + 1; for correct handling of tests in the algorithm,\n   pp_infinity must be even one more than 1e10 + 1; let's stand on the\n   safe side by choosing 1.e10+10.\n\n   Pp_infinity could probably be 1073741823 that is 2^30 - 1, that is\n   the minimal upper bound for integers; now that max_int is defined,\n   this limit could also be defined as max_int - 1.\n\n   However, before setting pp_infinity to something around max_int, we\n   must carefully double-check all the integer arithmetic operations\n   that involve pp_infinity, since any overflow would wreck havoc the\n   pretty-printing algorithm's invariants. Given that this arithmetic\n   correctness check is difficult and error prone and given that 1e10\n   + 1 is in practice large enough, there is no need to attempt to set\n   pp_infinity to the theoretically maximum limit. It is not worth the\n   burden ! *)\nlet pp_infinity = 1000000010\n\n(* Output functions for the formatter. *)\nlet pp_output_string state s = state.pp_out_string s 0 (String.length s)\nand pp_output_newline state = state.pp_out_newline ()\nand pp_output_spaces state n = state.pp_out_spaces n\nand pp_output_indent state n = state.pp_out_indent n\n\n(* Format a textual token *)\nlet format_pp_text state size text =\n  state.pp_space_left <- state.pp_space_left - size;\n  pp_output_string state text;\n  state.pp_is_new_line <- false\n\n(* Format a string by its length, if not empty *)\nlet format_string state s =\n  if s <> \"\" then format_pp_text state (String.length s) s\n\n(* To format a break, indenting a new line. *)\nlet break_new_line state (before, offset, after) width =\n  format_string state before;\n  pp_output_newline state;\n  state.pp_is_new_line <- true;\n  let indent = state.pp_margin - width + offset in\n  (* Don't indent more than pp_max_indent. *)\n  let real_indent = Int.min state.pp_max_indent indent in\n  state.pp_current_indent <- real_indent;\n  state.pp_space_left <- state.pp_margin - state.pp_current_indent;\n  pp_output_indent state state.pp_current_indent;\n  format_string state after\n\n\n(* To force a line break inside a box: no offset is added. *)\nlet break_line state width = break_new_line state (\"\", 0, \"\") width\n\n(* To format a break that fits on the current line. *)\nlet break_same_line state (before, width, after) =\n  format_string state before;\n  state.pp_space_left <- state.pp_space_left - width;\n  pp_output_spaces state width;\n  format_string state after\n\n\n(* To indent no more than pp_max_indent, if one tries to open a box\n   beyond pp_max_indent, then the box is rejected on the left\n   by simulating a break. *)\nlet pp_force_break_line state =\n  match Stack.top_opt state.pp_format_stack with\n  | None -> pp_output_newline state\n  | Some { box_type; width } ->\n    if width > state.pp_space_left then\n      match box_type with\n      | Pp_fits | Pp_hbox -> ()\n      | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box -> break_line state width\n\n\n(* To skip a token, if the previous line has been broken. *)\nlet pp_skip_token state =\n  match Queue.take_opt state.pp_queue with\n  | None -> () (* print_if_newline must have been the last printing command *)\n  | Some { size; length; _ } ->\n    state.pp_left_total <- state.pp_left_total - length;\n    state.pp_space_left <- state.pp_space_left + Size.to_int size\n\n\n(*\n\n  The main pretty printing functions.\n\n*)\n\n(* Formatting a token with a given size. *)\nlet format_pp_token state size = function\n\n  | Pp_text s ->\n    format_pp_text state size s\n\n  | Pp_begin (off, ty) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    if insertion_point > state.pp_max_indent then\n      (* can not open a box right there. *)\n      begin pp_force_break_line state end;\n    let width = state.pp_space_left - off in\n    let box_type =\n      match ty with\n      | Pp_vbox -> Pp_vbox\n      | Pp_hbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits ->\n        if size > state.pp_space_left then ty else Pp_fits in\n    Stack.push { box_type; width } state.pp_format_stack\n\n  | Pp_end ->\n    Stack.pop_opt state.pp_format_stack |> ignore\n\n  | Pp_tbegin (Pp_tbox _ as tbox) ->\n    Stack.push tbox state.pp_tbox_stack\n\n  | Pp_tend ->\n    Stack.pop_opt state.pp_tbox_stack |> ignore\n\n  | Pp_stab ->\n    begin match Stack.top_opt state.pp_tbox_stack with\n    | None -> () (* No open tabulation box. *)\n    | Some (Pp_tbox tabs) ->\n      let rec add_tab n = function\n        | [] -> [n]\n        | x :: l as ls -> if n < x then n :: ls else x :: add_tab n l in\n      tabs := add_tab (state.pp_margin - state.pp_space_left) !tabs\n    end\n\n  | Pp_tbreak (n, off) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    begin match Stack.top_opt state.pp_tbox_stack with\n    | None -> () (* No open tabulation box. *)\n    | Some (Pp_tbox tabs) ->\n      let tab =\n        match !tabs with\n        | [] -> insertion_point\n        | first :: _ ->\n          let rec find = function\n            | head :: tail ->\n              if head >= insertion_point then head else find tail\n            | [] -> first in\n          find !tabs in\n      let offset = tab - insertion_point in\n      if offset >= 0\n      then break_same_line state (\"\", offset + n, \"\")\n      else break_new_line state (\"\", tab + off, \"\") state.pp_margin\n    end\n\n  | Pp_newline ->\n    begin match Stack.top_opt state.pp_format_stack with\n    | None -> pp_output_newline state (* No open box. *)\n    | Some { width; _} -> break_line state width\n    end\n\n  | Pp_if_newline ->\n    if state.pp_current_indent != state.pp_margin - state.pp_space_left\n    then pp_skip_token state\n\n  | Pp_break { fits; breaks } ->\n    let before, off, _ = breaks in\n    begin match Stack.top_opt state.pp_format_stack with\n    | None -> () (* No open box. *)\n    | Some { box_type; width } ->\n      begin match box_type with\n      | Pp_hovbox ->\n        if size + String.length before > state.pp_space_left\n        then break_new_line state breaks width\n        else break_same_line state fits\n      | Pp_box ->\n        (* Have the line just been broken here ? *)\n        if state.pp_is_new_line then break_same_line state fits else\n        if size + String.length before > state.pp_space_left\n          then break_new_line state breaks width else\n        (* break the line here leads to new indentation ? *)\n        if state.pp_current_indent > state.pp_margin - width + off\n        then break_new_line state breaks width\n        else break_same_line state fits\n      | Pp_hvbox -> break_new_line state breaks width\n      | Pp_fits -> break_same_line state fits\n      | Pp_vbox -> break_new_line state breaks width\n      | Pp_hbox -> break_same_line state fits\n      end\n    end\n\n   | Pp_open_tag tag_name ->\n     let marker = state.pp_mark_open_tag tag_name in\n     pp_output_string state marker;\n     Stack.push tag_name state.pp_mark_stack\n\n   | Pp_close_tag ->\n     begin match Stack.pop_opt state.pp_mark_stack with\n     | None -> () (* No more tag to close. *)\n     | Some tag_name ->\n       let marker = state.pp_mark_close_tag tag_name in\n       pp_output_string state marker\n     end\n\n\n(* Print if token size is known else printing is delayed.\n   Printing is delayed when the text waiting in the queue requires\n   more room to format than exists on the current line. *)\nlet rec advance_left state =\n  match Queue.peek_opt state.pp_queue with\n  | None -> () (* No tokens to print *)\n  | Some { size; token; length } ->\n    let pending_count = state.pp_right_total - state.pp_left_total in\n    if Size.is_known size || pending_count >= state.pp_space_left then begin\n      Queue.take state.pp_queue |> ignore; (* Not empty: we peek into it *)\n      let size = if Size.is_known size then Size.to_int size else pp_infinity in\n      format_pp_token state size token;\n      state.pp_left_total <- length + state.pp_left_total;\n      (advance_left [@tailcall]) state\n    end\n\n\n(* To enqueue a token : try to advance. *)\nlet enqueue_advance state tok = pp_enqueue state tok; advance_left state\n\n\n(* To enqueue strings. *)\nlet enqueue_string_as state size s =\n  enqueue_advance state { size; token = Pp_text s; length = Size.to_int size }\n\n\nlet enqueue_string state s =\n  enqueue_string_as state (Size.of_int (String.length s)) s\n\n\n(* Routines for scan stack\n   determine size of boxes. *)\n\n(* The scan_stack is never empty. *)\nlet initialize_scan_stack stack =\n  Stack.clear stack;\n  let queue_elem = { size = Size.unknown; token = Pp_text \"\"; length = 0 } in\n  Stack.push { left_total = -1; queue_elem } stack\n\n(* Setting the size of boxes on scan stack:\n   if ty = true then size of break is set else size of box is set;\n   in each case pp_scan_stack is popped.\n\n   Note:\n   Pattern matching on scan stack is exhaustive, since scan_stack is never\n   empty.\n   Pattern matching on token in scan stack is also exhaustive,\n   since scan_push is used on breaks and opening of boxes. *)\nlet set_size state ty =\n  match Stack.top_opt state.pp_scan_stack with\n  | None -> () (* scan_stack is never empty. *)\n  | Some { left_total; queue_elem } ->\n    let size = Size.to_int queue_elem.size in\n    (* test if scan stack contains any data that is not obsolete. *)\n    if left_total < state.pp_left_total then\n      initialize_scan_stack state.pp_scan_stack\n    else\n      match queue_elem.token with\n      | Pp_break _ | Pp_tbreak (_, _) ->\n        if ty then begin\n          queue_elem.size <- Size.of_int (state.pp_right_total + size);\n          Stack.pop_opt state.pp_scan_stack |> ignore\n        end\n      | Pp_begin (_, _) ->\n        if not ty then begin\n          queue_elem.size <- Size.of_int (state.pp_right_total + size);\n          Stack.pop_opt state.pp_scan_stack |> ignore\n        end\n      | Pp_text _ | Pp_stab | Pp_tbegin _ | Pp_tend | Pp_end\n      | Pp_newline | Pp_if_newline | Pp_open_tag _ | Pp_close_tag ->\n        () (* scan_push is only used for breaks and boxes. *)\n\n\n(* Push a token on pretty-printer scanning stack.\n   If b is true set_size is called. *)\nlet scan_push state b token =\n  pp_enqueue state token;\n  if b then set_size state true;\n  let elem = { left_total = state.pp_right_total; queue_elem = token } in\n  Stack.push elem state.pp_scan_stack\n\n\n(* To open a new box :\n   the user may set the depth bound pp_max_boxes\n   any text nested deeper is printed as the ellipsis string. *)\nlet pp_open_box_gen state indent br_ty =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let elem = { size; token = Pp_begin (indent, br_ty); length = 0 } in\n    scan_push state false elem else\n  if state.pp_curr_depth = state.pp_max_boxes\n  then enqueue_string state state.pp_ellipsis\n\n\n(* The box which is always open. *)\nlet pp_open_sys_box state = pp_open_box_gen state 0 Pp_hovbox\n\n(* Close a box, setting sizes of its sub boxes. *)\nlet pp_close_box state () =\n  if state.pp_curr_depth > 1 then\n  begin\n    if state.pp_curr_depth < state.pp_max_boxes then\n    begin\n      pp_enqueue state { size = Size.zero; token = Pp_end; length = 0 };\n      set_size state true; set_size state false\n    end;\n    state.pp_curr_depth <- state.pp_curr_depth - 1;\n  end\n\n\n(* Open a tag, pushing it on the tag stack. *)\nlet pp_open_stag state tag_name =\n  if state.pp_print_tags then\n  begin\n    Stack.push tag_name state.pp_tag_stack;\n    state.pp_print_open_tag tag_name\n  end;\n  if state.pp_mark_tags then\n    let token = Pp_open_tag tag_name in\n    pp_enqueue state { size = Size.zero; token; length = 0 }\n\n\n(* Close a tag, popping it from the tag stack. *)\nlet pp_close_stag state () =\n  if state.pp_mark_tags then\n    pp_enqueue state { size = Size.zero; token = Pp_close_tag; length = 0 };\n  if state.pp_print_tags then\n    match Stack.pop_opt state.pp_tag_stack with\n    | None -> () (* No more tag to close. *)\n    | Some tag_name ->\n      state.pp_print_close_tag tag_name\n\nlet pp_open_tag state s = pp_open_stag state (String_tag s)\nlet pp_close_tag state () = pp_close_stag state ()\n\nlet pp_set_print_tags state b = state.pp_print_tags <- b\nlet pp_set_mark_tags state b = state.pp_mark_tags <- b\nlet pp_get_print_tags state () = state.pp_print_tags\nlet pp_get_mark_tags state () = state.pp_mark_tags\nlet pp_set_tags state b =\n  pp_set_print_tags state b; pp_set_mark_tags state b\n\n\n(* Handling tag handling functions: get/set functions. *)\nlet pp_get_formatter_stag_functions state () = {\n  mark_open_stag = state.pp_mark_open_tag;\n  mark_close_stag = state.pp_mark_close_tag;\n  print_open_stag = state.pp_print_open_tag;\n  print_close_stag = state.pp_print_close_tag;\n}\n\n\nlet pp_set_formatter_stag_functions state {\n     mark_open_stag = mot;\n     mark_close_stag = mct;\n     print_open_stag = pot;\n     print_close_stag = pct;\n  } =\n  state.pp_mark_open_tag <- mot;\n  state.pp_mark_close_tag <- mct;\n  state.pp_print_open_tag <- pot;\n  state.pp_print_close_tag <- pct\n\n\n(* Initialize pretty-printer. *)\nlet pp_rinit state =\n  pp_clear_queue state;\n  initialize_scan_stack state.pp_scan_stack;\n  Stack.clear state.pp_format_stack;\n  Stack.clear state.pp_tbox_stack;\n  Stack.clear state.pp_tag_stack;\n  Stack.clear state.pp_mark_stack;\n  state.pp_current_indent <- 0;\n  state.pp_curr_depth <- 0;\n  state.pp_space_left <- state.pp_margin;\n  pp_open_sys_box state\n\nlet clear_tag_stack state =\n  Stack.iter (fun _ -> pp_close_tag state ()) state.pp_tag_stack\n\n\n(* Flushing pretty-printer queue. *)\nlet pp_flush_queue state b =\n  clear_tag_stack state;\n  while state.pp_curr_depth > 1 do\n    pp_close_box state ()\n  done;\n  state.pp_right_total <- pp_infinity;\n  advance_left state;\n  if b then pp_output_newline state;\n  pp_rinit state\n\n(*\n\n  Procedures to format values and use boxes.\n\n*)\n\n(* To format a string. *)\nlet pp_print_as_size state size s =\n  if state.pp_curr_depth < state.pp_max_boxes\n  then enqueue_string_as state size s\n\n\nlet pp_print_as state isize s =\n  pp_print_as_size state (Size.of_int isize) s\n\n\nlet pp_print_string state s =\n  pp_print_as state (String.length s) s\n\nlet pp_print_bytes state s =\n  pp_print_as state (Bytes.length s) (Bytes.to_string s)\n\n(* To format an integer. *)\nlet pp_print_int state i = pp_print_string state (Int.to_string i)\n\n(* To format a float. *)\nlet pp_print_float state f = pp_print_string state (string_of_float f)\n\n(* To format a boolean. *)\nlet pp_print_bool state b = pp_print_string state (string_of_bool b)\n\n(* To format a char. *)\nlet pp_print_char state c =\n  pp_print_as state 1 (String.make 1 c)\n\n\n(* Opening boxes. *)\nlet pp_open_hbox state () = pp_open_box_gen state 0 Pp_hbox\nand pp_open_vbox state indent = pp_open_box_gen state indent Pp_vbox\n\nand pp_open_hvbox state indent = pp_open_box_gen state indent Pp_hvbox\nand pp_open_hovbox state indent = pp_open_box_gen state indent Pp_hovbox\nand pp_open_box state indent = pp_open_box_gen state indent Pp_box\n\n\n(* Printing queued text.\n\n   [pp_print_flush] prints all pending items in the pretty-printer queue and\n   then flushes the low level output device of the formatter to actually\n   display printing material.\n\n   [pp_print_newline] behaves as [pp_print_flush] after printing an additional\n   new line. *)\nlet pp_print_newline state () =\n  pp_flush_queue state true; state.pp_out_flush ()\nand pp_print_flush state () =\n  pp_flush_queue state false; state.pp_out_flush ()\n\n\n(* To get a newline when one does not want to close the current box. *)\nlet pp_force_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state { size = Size.zero; token = Pp_newline; length = 0 }\n\n\n(* To format something, only in case the line has just been broken. *)\nlet pp_print_if_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state\n      { size = Size.zero; token = Pp_if_newline; length = 0 }\n\n\n(* Generalized break hint that allows printing strings before/after\n   same-line offset (width) or new-line offset *)\nlet pp_print_custom_break state ~fits ~breaks =\n  let before, width, after = fits in\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let token = Pp_break { fits; breaks } in\n    let length = String.length before + width + String.length after in\n    let elem = { size; token; length } in\n    scan_push state true elem\n\n(* Printing break hints:\n   A break hint indicates where a box may be broken.\n   If line is broken then offset is added to the indentation of the current\n   box else (the value of) width blanks are printed. *)\nlet pp_print_break state width offset =\n  pp_print_custom_break state\n    ~fits:(\"\", width, \"\") ~breaks:(\"\", offset, \"\")\n\n\n(* Print a space :\n   a space is a break hint that prints a single space if the break does not\n   split the line;\n   a cut is a break hint that prints nothing if the break does not split the\n   line. *)\nlet pp_print_space state () = pp_print_break state 1 0\nand pp_print_cut state () = pp_print_break state 0 0\n\n\n(* Tabulation boxes. *)\nlet pp_open_tbox state () =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.zero in\n    let elem = { size; token = Pp_tbegin (Pp_tbox (ref [])); length = 0 } in\n    enqueue_advance state elem\n\n\n(* Close a tabulation box. *)\nlet pp_close_tbox state () =\n  if state.pp_curr_depth > 1 then\n  begin\n   if state.pp_curr_depth < state.pp_max_boxes then\n     let elem = { size = Size.zero; token = Pp_tend; length = 0 } in\n     enqueue_advance state elem;\n     state.pp_curr_depth <- state.pp_curr_depth - 1\n  end\n\n\n(* Print a tabulation break. *)\nlet pp_print_tbreak state width offset =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let elem = { size; token = Pp_tbreak (width, offset); length = width } in\n    scan_push state true elem\n\n\nlet pp_print_tab state () = pp_print_tbreak state 0 0\n\nlet pp_set_tab state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem = { size = Size.zero; token = Pp_stab; length = 0 } in\n    enqueue_advance state elem\n\n\n(*\n\n  Procedures to control the pretty-printers\n\n*)\n\n(* Set_max_boxes. *)\nlet pp_set_max_boxes state n = if n > 1 then state.pp_max_boxes <- n\n\n(* To know the current maximum number of boxes allowed. *)\nlet pp_get_max_boxes state () = state.pp_max_boxes\n\nlet pp_over_max_boxes state () = state.pp_curr_depth = state.pp_max_boxes\n\n(* Ellipsis. *)\nlet pp_set_ellipsis_text state s = state.pp_ellipsis <- s\nand pp_get_ellipsis_text state () = state.pp_ellipsis\n\n\n(* To set the margin of pretty-printer. *)\nlet pp_limit n =\n  if n < pp_infinity then n else pred pp_infinity\n\n\n(* Internal pretty-printer functions. *)\nlet pp_set_min_space_left state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_min_space_left <- n;\n    state.pp_max_indent <- state.pp_margin - state.pp_min_space_left;\n    pp_rinit state\n\n\n(* Initially, we have :\n   pp_max_indent = pp_margin - pp_min_space_left, and\n   pp_space_left = pp_margin. *)\nlet pp_set_max_indent state n =\n  if n > 1 then\n    pp_set_min_space_left state (state.pp_margin - n)\n\n\nlet pp_get_max_indent state () = state.pp_max_indent\n\nlet pp_set_margin state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_margin <- n;\n    let new_max_indent =\n      (* Try to maintain max_indent to its actual value. *)\n      if state.pp_max_indent <= state.pp_margin\n      then state.pp_max_indent else\n      (* If possible maintain pp_min_space_left to its actual value,\n         if this leads to a too small max_indent, take half of the\n         new margin, if it is greater than 1. *)\n       Int.max (Int.max (state.pp_margin - state.pp_min_space_left)\n                (state.pp_margin / 2)) 1 in\n    (* Rebuild invariants. *)\n    pp_set_max_indent state new_max_indent\n\n\n(** Geometry functions and types *)\ntype geometry = { max_indent:int; margin: int}\n\nlet validate_geometry {margin; max_indent} =\n  if max_indent < 2 then\n    Error \"max_indent < 2\"\n  else if margin <= max_indent then\n    Error \"margin <= max_indent\"\n  else Ok ()\n\nlet check_geometry geometry =\n  match validate_geometry geometry with\n  | Ok () -> true\n  | Error _ -> false\n\nlet pp_get_margin state () = state.pp_margin\n\nlet pp_set_full_geometry state {margin; max_indent} =\n  pp_set_margin state margin;\n  pp_set_max_indent state max_indent;\n  ()\n\nlet pp_set_geometry state ~max_indent ~margin =\n  let geometry = { max_indent; margin } in\n  match validate_geometry geometry with\n  | Error msg ->\n    raise (Invalid_argument (\"Format.pp_set_geometry: \" ^ msg))\n  | Ok () ->\n    pp_set_full_geometry state geometry\n\nlet pp_safe_set_geometry state ~max_indent ~margin =\n  let geometry = { max_indent; margin } in\n  match validate_geometry geometry with\n  | Error _msg ->\n     ()\n  | Ok () ->\n    pp_set_full_geometry state geometry\n\nlet pp_get_geometry state () =\n  { margin = pp_get_margin state (); max_indent = pp_get_max_indent state () }\n\nlet pp_update_geometry state update =\n  let geometry = pp_get_geometry state () in\n  pp_set_full_geometry state (update geometry)\n\n(* Setting a formatter basic output functions. *)\nlet pp_set_formatter_out_functions state {\n      out_string = f;\n      out_flush = g;\n      out_newline = h;\n      out_spaces = i;\n      out_indent = j;\n    } =\n  state.pp_out_string <- f;\n  state.pp_out_flush <- g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i;\n  state.pp_out_indent <- j\n\nlet pp_get_formatter_out_functions state () = {\n  out_string = state.pp_out_string;\n  out_flush = state.pp_out_flush;\n  out_newline = state.pp_out_newline;\n  out_spaces = state.pp_out_spaces;\n  out_indent = state.pp_out_indent;\n}\n\n\n(* Setting a formatter basic string output and flush functions. *)\nlet pp_set_formatter_output_functions state f g =\n  state.pp_out_string <- f; state.pp_out_flush <- g\n\nlet pp_get_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush)\n\n\n(* The default function to output new lines. *)\nlet display_newline state () = state.pp_out_string \"\\n\" 0  1\n\n(* The default function to output spaces. *)\nlet blank_line = String.make 80 ' '\nlet rec display_blanks state n =\n  if n > 0 then\n  if n <= 80 then state.pp_out_string blank_line 0 n else\n  begin\n    state.pp_out_string blank_line 0 80;\n    display_blanks state (n - 80)\n  end\n\n\n(* The default function to output indentation of new lines. *)\nlet display_indent = display_blanks\n\n(* Setting a formatter basic output functions as printing to a given\n   [Pervasive.out_channel] value. *)\nlet pp_set_formatter_out_channel state oc =\n  state.pp_out_string <- output_substring oc;\n  state.pp_out_flush <- (fun () -> flush oc);\n  state.pp_out_newline <- display_newline state;\n  state.pp_out_spaces <- display_blanks state;\n  state.pp_out_indent <- display_indent state\n\n(*\n\n  Defining specific formatters\n\n*)\n\nlet default_pp_mark_open_tag = function\n  | String_tag s -> \"<\" ^ s ^ \">\"\n  | _ -> \"\"\nlet default_pp_mark_close_tag = function\n  | String_tag s -> \"</\" ^ s ^ \">\"\n  | _ -> \"\"\n\nlet default_pp_print_open_tag = ignore\nlet default_pp_print_close_tag = ignore\n\n(* Building a formatter given its basic output functions.\n   Other fields get reasonable default values. *)\nlet pp_make_formatter f g h i j =\n  (* The initial state of the formatter contains a dummy box. *)\n  let pp_queue = Queue.create () in\n  let sys_tok =\n    { size = Size.unknown; token = Pp_begin (0, Pp_hovbox); length = 0 } in\n  Queue.add sys_tok pp_queue;\n  let scan_stack = Stack.create () in\n  initialize_scan_stack scan_stack;\n  Stack.push { left_total = 1; queue_elem = sys_tok } scan_stack;\n  let pp_margin = 78\n  and pp_min_space_left = 10 in\n  {\n    pp_scan_stack = scan_stack;\n    pp_format_stack = Stack.create ();\n    pp_tbox_stack = Stack.create ();\n    pp_tag_stack = Stack.create ();\n    pp_mark_stack = Stack.create ();\n    pp_margin = pp_margin;\n    pp_min_space_left = pp_min_space_left;\n    pp_max_indent = pp_margin - pp_min_space_left;\n    pp_space_left = pp_margin;\n    pp_current_indent = 0;\n    pp_is_new_line = true;\n    pp_left_total = 1;\n    pp_right_total = 1;\n    pp_curr_depth = 1;\n    pp_max_boxes = max_int;\n    pp_ellipsis = \".\";\n    pp_out_string = f;\n    pp_out_flush = g;\n    pp_out_newline = h;\n    pp_out_spaces = i;\n    pp_out_indent = j;\n    pp_print_tags = false;\n    pp_mark_tags = false;\n    pp_mark_open_tag = default_pp_mark_open_tag;\n    pp_mark_close_tag = default_pp_mark_close_tag;\n    pp_print_open_tag = default_pp_print_open_tag;\n    pp_print_close_tag = default_pp_print_close_tag;\n    pp_queue = pp_queue;\n  }\n\n\n(* Build a formatter out of its out functions. *)\nlet formatter_of_out_functions out_funs =\n  pp_make_formatter\n    out_funs.out_string\n    out_funs.out_flush\n    out_funs.out_newline\n    out_funs.out_spaces\n    out_funs.out_indent\n\n\n(* Make a formatter with default functions to output spaces,\n  indentation, and new lines. *)\nlet make_formatter output flush =\n  let ppf = pp_make_formatter output flush ignore ignore ignore in\n  ppf.pp_out_newline <- display_newline ppf;\n  ppf.pp_out_spaces <- display_blanks ppf;\n  ppf.pp_out_indent <- display_indent ppf;\n  ppf\n\n\n(* Make a formatter writing to a given [Pervasive.out_channel] value. *)\nlet formatter_of_out_channel oc =\n  make_formatter (output_substring oc) (fun () -> flush oc)\n\n\n(* Make a formatter writing to a given [Buffer.t] value. *)\nlet formatter_of_buffer b =\n  make_formatter (Buffer.add_substring b) ignore\n\n\n(* Allocating buffer for pretty-printing purposes.\n   Default buffer size is pp_buffer_size or 512.\n*)\nlet pp_buffer_size = 512\nlet pp_make_buffer () = Buffer.create pp_buffer_size\n\n(* The standard (shared) buffer. *)\nlet stdbuf = pp_make_buffer ()\n\n(* Predefined formatters standard formatter to print\n   to [Stdlib.stdout], [Stdlib.stderr], and {!stdbuf}. *)\nlet std_formatter = formatter_of_out_channel Stdlib.stdout\nand err_formatter = formatter_of_out_channel Stdlib.stderr\nand str_formatter = formatter_of_buffer stdbuf\n\n\n(* [flush_buffer_formatter buf ppf] flushes formatter [ppf],\n   then returns the contents of buffer [buf] that is reset.\n   Formatter [ppf] is supposed to print to buffer [buf], otherwise this\n   function is not really useful. *)\nlet flush_buffer_formatter buf ppf =\n  pp_flush_queue ppf false;\n  let s = Buffer.contents buf in\n  Buffer.reset buf;\n  s\n\n\n(* Flush [str_formatter] and get the contents of [stdbuf]. *)\nlet flush_str_formatter () = flush_buffer_formatter stdbuf str_formatter\n\n(*\n  Symbolic pretty-printing\n*)\n\n(*\n  Symbolic pretty-printing is pretty-printing with no low level output.\n\n  When using a symbolic formatter, all regular pretty-printing activities\n  occur but output material is symbolic and stored in a buffer of output\n  items. At the end of pretty-printing, flushing the output buffer allows\n  post-processing of symbolic output before low level output operations.\n*)\n\ntype symbolic_output_item =\n  | Output_flush\n  | Output_newline\n  | Output_string of string\n  | Output_spaces of int\n  | Output_indent of int\n\ntype symbolic_output_buffer = {\n  mutable symbolic_output_contents : symbolic_output_item list;\n}\n\nlet make_symbolic_output_buffer () =\n  { symbolic_output_contents = [] }\n\nlet clear_symbolic_output_buffer sob =\n  sob.symbolic_output_contents <- []\n\nlet get_symbolic_output_buffer sob =\n  List.rev sob.symbolic_output_contents\n\nlet flush_symbolic_output_buffer sob =\n  let items = get_symbolic_output_buffer sob in\n  clear_symbolic_output_buffer sob;\n  items\n\nlet add_symbolic_output_item sob item =\n  sob.symbolic_output_contents <- item :: sob.symbolic_output_contents\n\nlet formatter_of_symbolic_output_buffer sob =\n  let symbolic_flush sob () =\n    add_symbolic_output_item sob Output_flush\n  and symbolic_newline sob () =\n    add_symbolic_output_item sob Output_newline\n  and symbolic_string sob s i n =\n    add_symbolic_output_item sob (Output_string (String.sub s i n))\n  and symbolic_spaces sob n =\n    add_symbolic_output_item sob (Output_spaces n)\n  and symbolic_indent sob n =\n    add_symbolic_output_item sob (Output_indent n) in\n\n  let f = symbolic_string sob\n  and g = symbolic_flush sob\n  and h = symbolic_newline sob\n  and i = symbolic_spaces sob\n  and j = symbolic_indent sob in\n  pp_make_formatter f g h i j\n\n(*\n\n  Basic functions on the 'standard' formatter\n  (the formatter that prints to [Stdlib.stdout]).\n\n*)\n\nlet open_hbox = pp_open_hbox std_formatter\nand open_vbox = pp_open_vbox std_formatter\nand open_hvbox = pp_open_hvbox std_formatter\nand open_hovbox = pp_open_hovbox std_formatter\nand open_box = pp_open_box std_formatter\nand close_box = pp_close_box std_formatter\nand open_tag = pp_open_tag std_formatter\nand close_tag = pp_close_tag std_formatter\nand open_stag = pp_open_stag std_formatter\nand close_stag = pp_close_stag std_formatter\nand print_as = pp_print_as std_formatter\nand print_string = pp_print_string std_formatter\nand print_bytes = pp_print_bytes std_formatter\nand print_int = pp_print_int std_formatter\nand print_float = pp_print_float std_formatter\nand print_char = pp_print_char std_formatter\nand print_bool = pp_print_bool std_formatter\nand print_break = pp_print_break std_formatter\nand print_cut = pp_print_cut std_formatter\nand print_space = pp_print_space std_formatter\nand force_newline = pp_force_newline std_formatter\nand print_flush = pp_print_flush std_formatter\nand print_newline = pp_print_newline std_formatter\nand print_if_newline = pp_print_if_newline std_formatter\n\nand open_tbox = pp_open_tbox std_formatter\nand close_tbox = pp_close_tbox std_formatter\nand print_tbreak = pp_print_tbreak std_formatter\n\nand set_tab = pp_set_tab std_formatter\nand print_tab = pp_print_tab std_formatter\n\nand set_margin = pp_set_margin std_formatter\nand get_margin = pp_get_margin std_formatter\n\nand set_max_indent = pp_set_max_indent std_formatter\nand get_max_indent = pp_get_max_indent std_formatter\n\nand set_geometry = pp_set_geometry std_formatter\nand safe_set_geometry = pp_safe_set_geometry std_formatter\nand get_geometry = pp_get_geometry std_formatter\nand update_geometry = pp_update_geometry std_formatter\n\nand set_max_boxes = pp_set_max_boxes std_formatter\nand get_max_boxes = pp_get_max_boxes std_formatter\nand over_max_boxes = pp_over_max_boxes std_formatter\n\nand set_ellipsis_text = pp_set_ellipsis_text std_formatter\nand get_ellipsis_text = pp_get_ellipsis_text std_formatter\n\nand set_formatter_out_channel =\n  pp_set_formatter_out_channel std_formatter\n\nand set_formatter_out_functions =\n  pp_set_formatter_out_functions std_formatter\nand get_formatter_out_functions =\n  pp_get_formatter_out_functions std_formatter\n\nand set_formatter_output_functions =\n  pp_set_formatter_output_functions std_formatter\nand get_formatter_output_functions =\n  pp_get_formatter_output_functions std_formatter\n\nand set_formatter_stag_functions =\n  pp_set_formatter_stag_functions std_formatter\nand get_formatter_stag_functions =\n  pp_get_formatter_stag_functions std_formatter\nand set_print_tags =\n  pp_set_print_tags std_formatter\nand get_print_tags =\n  pp_get_print_tags std_formatter\nand set_mark_tags =\n  pp_set_mark_tags std_formatter\nand get_mark_tags =\n  pp_get_mark_tags std_formatter\nand set_tags =\n  pp_set_tags std_formatter\n\n\n(* Convenience functions *)\n\n(* To format a list *)\nlet rec pp_print_list ?(pp_sep = pp_print_cut) pp_v ppf = function\n  | [] -> ()\n  | [v] -> pp_v ppf v\n  | v :: vs ->\n    pp_v ppf v;\n    pp_sep ppf ();\n    pp_print_list ~pp_sep pp_v ppf vs\n\n(* To format a sequence *)\nlet rec pp_print_seq_in ~pp_sep pp_v ppf seq =\n  match seq () with\n  | Seq.Nil -> ()\n  | Seq.Cons (v, seq) ->\n    pp_sep ppf ();\n    pp_v ppf v;\n    pp_print_seq_in ~pp_sep pp_v ppf seq\n\nlet pp_print_seq ?(pp_sep = pp_print_cut) pp_v ppf seq =\n  match seq () with\n  | Seq.Nil -> ()\n  | Seq.Cons (v, seq) ->\n    pp_v ppf v;\n    pp_print_seq_in ~pp_sep pp_v ppf seq\n\n(* To format free-flowing text *)\nlet pp_print_text ppf s =\n  let len = String.length s in\n  let left = ref 0 in\n  let right = ref 0 in\n  let flush () =\n    pp_print_string ppf (String.sub s !left (!right - !left));\n    incr right; left := !right;\n  in\n  while (!right <> len) do\n    match s.[!right] with\n      | '\\n' ->\n        flush ();\n        pp_force_newline ppf ()\n      | ' ' ->\n        flush (); pp_print_space ppf ()\n      (* there is no specific support for '\\t'\n         as it is unclear what a right semantics would be *)\n      | _ -> incr right\n  done;\n  if !left <> len then flush ()\n\nlet pp_print_option ?(none = fun _ () -> ()) pp_v ppf = function\n| None -> none ppf ()\n| Some v -> pp_v ppf v\n\nlet pp_print_result ~ok ~error ppf = function\n| Ok v -> ok ppf v\n| Error e -> error ppf e\n\nlet pp_print_either ~left ~right ppf = function\n| Either.Left l -> left ppf l\n| Either.Right r -> right ppf r\n\n (**************************************************************)\n\nlet compute_tag output tag_acc =\n  let buf = Buffer.create 16 in\n  let ppf = formatter_of_buffer buf in\n  output ppf tag_acc;\n  pp_print_flush ppf ();\n  let len = Buffer.length buf in\n  if len < 2 then Buffer.contents buf\n  else Buffer.sub buf 1 (len - 2)\n\n (**************************************************************\n\n  Defining continuations to be passed as arguments of\n  CamlinternalFormat.make_printf.\n\n  **************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\n(* Interpret a formatting entity on a formatter. *)\nlet output_formatting_lit ppf fmting_lit = match fmting_lit with\n  | Close_box                 -> pp_close_box ppf ()\n  | Close_tag                 -> pp_close_tag ppf ()\n  | Break (_, width, offset)  -> pp_print_break ppf width offset\n  | FFlush                    -> pp_print_flush ppf ()\n  | Force_newline             -> pp_force_newline ppf ()\n  | Flush_newline             -> pp_print_newline ppf ()\n  | Magic_size (_, _)         -> ()\n  | Escaped_at                -> pp_print_char ppf '@'\n  | Escaped_percent           -> pp_print_char ppf '%'\n  | Scan_indic c              -> pp_print_char ppf '@'; pp_print_char ppf c\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Differ from Printf.output_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec output_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (String.make 1 c);\n  | Acc_formatting_lit (p, f) ->\n    output_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc ppf p;\n    pp_open_stag ppf (String_tag (compute_tag output_acc acc'))\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag output_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> output_acc ppf p; f ppf;\n  | Acc_flush p              -> output_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> output_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from Printf.bufput_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec strput_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (String.make 1 c);\n  | Acc_delay (Acc_formatting_lit (p, Magic_size (_, size)), f) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (f ());\n  | Acc_formatting_lit (p, f) ->\n    strput_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc ppf p;\n    pp_open_stag ppf (String_tag (compute_tag strput_acc acc'))\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag strput_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> strput_acc ppf p; pp_print_string ppf (f ());\n  | Acc_flush p              -> strput_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> strput_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(*\n\n  Defining [fprintf] and various flavors of [fprintf].\n\n*)\n\nlet kfprintf k ppf (Format (fmt, _)) =\n  make_printf\n    (fun acc -> output_acc ppf acc; k ppf)\n    End_of_acc fmt\n\nand ikfprintf k ppf (Format (fmt, _)) =\n  make_iprintf k ppf fmt\n\nlet ifprintf _ppf (Format (fmt, _)) =\n  make_iprintf ignore () fmt\n\nlet fprintf ppf = kfprintf ignore ppf\nlet printf fmt = fprintf std_formatter fmt\nlet eprintf fmt = fprintf err_formatter fmt\n\nlet kdprintf k (Format (fmt, _)) =\n  make_printf\n    (fun acc -> k (fun ppf -> output_acc ppf acc))\n    End_of_acc fmt\n\nlet dprintf fmt = kdprintf (fun i -> i) fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k acc =\n    strput_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k End_of_acc fmt\n\n\nlet sprintf fmt = ksprintf id fmt\n\nlet kasprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k acc =\n    output_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k End_of_acc fmt\n\n\nlet asprintf fmt = kasprintf id fmt\n\n(* Flushing standard formatters at end of execution. *)\n\nlet flush_standard_formatters () =\n  pp_print_flush std_formatter ();\n  pp_print_flush err_formatter ()\n\nlet () = at_exit flush_standard_formatters\n\n(*\n\n  Deprecated stuff.\n\n*)\n\n(* Deprecated : subsumed by pp_set_formatter_out_functions *)\nlet pp_set_all_formatter_output_functions state\n    ~out:f ~flush:g ~newline:h ~spaces:i =\n  pp_set_formatter_output_functions state f g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i\n\n(* Deprecated : subsumed by pp_get_formatter_out_functions *)\nlet pp_get_all_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush,\n   state.pp_out_newline, state.pp_out_spaces)\n\n\n(* Deprecated : subsumed by set_formatter_out_functions *)\nlet set_all_formatter_output_functions =\n  pp_set_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : subsumed by get_formatter_out_functions *)\nlet get_all_formatter_output_functions =\n  pp_get_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : error prone function, do not use it.\n   This function is neither compositional nor incremental, since it flushes\n   the pretty-printer queue at each call.\n   To get the same functionality, define a formatter of your own writing to\n   the buffer argument, as in\n   let ppf = formatter_of_buffer b\n   then use {!fprintf ppf} as usual. *)\nlet bprintf b (Format (fmt, _) : ('a, formatter, unit) format) =\n  let ppf = formatter_of_buffer b in\n  let k acc = output_acc ppf acc; pp_flush_queue ppf false in\n  make_printf k End_of_acc fmt\n\n\n(* Deprecated : alias for ksprintf. *)\nlet kprintf = ksprintf\n\n\n\n(* Deprecated tag functions *)\n\ntype formatter_tag_functions = {\n  mark_open_tag : tag -> string;\n  mark_close_tag : tag -> string;\n  print_open_tag : tag -> unit;\n  print_close_tag : tag -> unit;\n}\n\n\nlet pp_set_formatter_tag_functions state {\n     mark_open_tag = mot;\n     mark_close_tag = mct;\n     print_open_tag = pot;\n     print_close_tag = pct;\n   } =\n  let stringify f e = function String_tag s -> f s | _ -> e in\n  state.pp_mark_open_tag <- stringify mot \"\";\n  state.pp_mark_close_tag <- stringify mct \"\";\n  state.pp_print_open_tag <- stringify pot ();\n  state.pp_print_close_tag <- stringify pct ()\n\nlet pp_get_formatter_tag_functions fmt () =\n  let funs = pp_get_formatter_stag_functions fmt () in\n  let mark_open_tag s = funs.mark_open_stag (String_tag s) in\n  let mark_close_tag s = funs.mark_close_stag (String_tag s) in\n  let print_open_tag s = funs.print_open_stag (String_tag s) in\n  let print_close_tag s = funs.print_close_stag (String_tag s) in\n  {mark_open_tag; mark_close_tag; print_open_tag; print_close_tag}\n\nlet set_formatter_tag_functions =\n  pp_set_formatter_tag_functions std_formatter\nand get_formatter_tag_functions =\n  pp_get_formatter_tag_functions std_formatter\n","let version = \"2.1.2\"\n\nexception Json_error of string\n\nlet json_error s = raise (Json_error s)\n\nexception End_of_array\nexception End_of_object\nexception End_of_tuple\nexception End_of_input\n\ntype lexer_state = {\n  buf : Buffer.t; (* Buffer used to accumulate substrings *)\n  mutable lnum : int; (* Current line number (starting from 1) *)\n  mutable bol : int;\n      (* Absolute position of the first character of the current line\n         (starting from 0) *)\n  mutable fname : string option; (* Name describing the input file *)\n}\n\nmodule Lexer_state = struct\n  type t = lexer_state = {\n    buf : Buffer.t;\n    mutable lnum : int;\n    mutable bol : int;\n    mutable fname : string option;\n  }\nend\n\nlet init_lexer ?buf ?fname ?(lnum = 1) () =\n  let buf = match buf with None -> Buffer.create 256 | Some buf -> buf in\n  { buf; lnum; bol = 0; fname }\n","let __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\254\\255\\255\\255\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_default =\n   \"\\001\\000\\000\\000\\000\\000\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\002\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec read_junk buf n lexbuf =\n   __ocaml_lex_read_junk_rec buf n lexbuf 0\nand __ocaml_lex_read_junk_rec buf n lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 2 \"lib/lexer_utils.mll\"\n        ( () )\n# 98 \"lib/lexer_utils.ml\"\n\n  | 1 ->\n# 3 \"lib/lexer_utils.mll\"\n      (\n     if n <= 0 then ()\n     else begin\n       Buffer.add_char buf (Lexing.lexeme_char lexbuf 0);\n       read_junk buf (n - 1) lexbuf\n     end\n     )\n# 109 \"lib/lexer_utils.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_read_junk_rec buf n lexbuf __ocaml_lex_state\n\n;;\n\n# 11 \"lib/lexer_utils.mll\"\n \nlet read_junk_without_positions buf n (lexbuf : Lexing.lexbuf) =\n  let junk_start_pos = lexbuf.lex_start_pos in\n  read_junk buf n lexbuf;\n  lexbuf.lex_start_pos <- junk_start_pos + 1\n\n# 123 \"lib/lexer_utils.ml\"\n","open Dec\n\n(** val remove : 'a1 coq_Discrete -> 'a1 -> 'a1 list -> 'a1 list **)\n\nlet rec remove h5 x = function\n| [] -> []\n| y :: xs' -> if h5 x y then remove h5 x xs' else y :: (remove h5 x xs')\n","\ntype 'x coq_Ord =\n  'x -> 'x -> bool\n  (* singleton inductive, whose constructor was Build_Ord *)\n\n(** val insert : 'a1 coq_Ord -> 'a1 -> 'a1 list -> 'a1 list **)\n\nlet rec insert h x xs = match xs with\n| [] -> x :: []\n| y :: ys -> if h x y then x :: xs else y :: (insert h x ys)\n\n(** val insertion_sort : 'a1 coq_Ord -> 'a1 list -> 'a1 list **)\n\nlet rec insertion_sort h = function\n| [] -> []\n| x :: ys -> insert h x (insertion_sort h ys)\n","\n(** val negb : bool -> bool **)\n\nlet negb = function\n| true -> false\n| false -> true\n\n(** val app : 'a1 list -> 'a1 list -> 'a1 list **)\n\nlet rec app l m =\n  match l with\n  | [] -> m\n  | a :: l1 -> a :: (app l1 m)\n","open Compare_dec\nopen Dec\nopen Sort\nopen Specif\n\ntype __ = Obj.t\nlet __ = let rec f _ = Obj.repr f in Obj.repr f\n\ntype 'x coq_Enum =\n  'x list\n  (* singleton inductive, whose constructor was Build_Enum *)\n\ntype coq_Graph = { coq_Vert_disc : __ coq_Discrete;\n                   coq_Vert_enum : __ coq_Enum; successors : (__ -> __ list) }\n\ntype coq_Vert = __\n\n(** val coq_Graph_Vert_disc : coq_Graph -> coq_Vert coq_Discrete **)\n\nlet coq_Graph_Vert_disc g =\n  g.coq_Vert_disc\n\n(** val coq_Graph_Vert_enum : coq_Graph -> coq_Vert coq_Enum **)\n\nlet coq_Graph_Vert_enum g =\n  g.coq_Vert_enum\n\n(** val first_index_aux_In :\n    'a1 coq_Discrete -> 'a1 list -> int -> 'a1 -> (int, __) sigT **)\n\nlet rec first_index_aux_In h xs n x =\n  match xs with\n  | [] -> assert false (* absurd case *)\n  | y :: l ->\n    let d = h x y in\n    if d\n    then Coq_existT (n, __)\n    else first_index_aux_In h l (Stdlib.Int.succ n) x\n\n(** val subcount_Ord : 'a1 coq_Discrete -> 'a1 coq_Enum -> 'a1 coq_Ord **)\n\nlet subcount_Ord h h0 x y =\n  let s = first_index_aux_In h h0 0 x in\n  let Coq_existT (x0, _) = s in\n  let s0 = first_index_aux_In h h0 0 y in\n  let Coq_existT (x1, _) = s0 in le_le_S_dec x0 x1\n","open Dec\nopen IntHash\nopen PrimInt63\n\ntype __ = Obj.t\nlet __ = let rec f _ = Obj.repr f in Obj.repr f\n\ntype 'm coq_IntMap = { empty : (__ -> 'm);\n                       add : (__ -> Uint63.t -> __ -> 'm -> 'm);\n                       lookup : (__ -> Uint63.t -> 'm -> __ option);\n                       size : (__ -> 'm -> int) }\n\n(** val lookup : 'a1 coq_IntMap -> Uint63.t -> 'a1 -> 'a2 option **)\n\nlet lookup intMap x x0 =\n  Obj.magic intMap.lookup __ x x0\n\n(** val hash_lookup :\n    'a1 coq_IntMap -> 'a2 coq_IntHash -> 'a2 -> 'a1 -> 'a3 option **)\n\nlet hash_lookup h h0 x =\n  lookup h (h0 x)\n\n(** val int_Discrete : Uint63.t coq_Discrete **)\n\nlet int_Discrete x y =\n  let b = eqb x y in if b then true else false\n\n(** val in_dec : 'a1 coq_Discrete -> 'a1 -> 'a1 list -> bool **)\n\nlet rec in_dec h x = function\n| [] -> false\n| y :: l -> let d = h y x in if d then true else in_dec h x l\n\n(** val in_decb : 'a1 coq_Discrete -> 'a1 -> 'a1 list -> bool **)\n\nlet in_decb h x xs =\n  if in_dec h x xs then true else false\n\n(** val coq_Hash_disc : 'a1 coq_IntHash -> 'a1 coq_Discrete **)\n\nlet coq_Hash_disc h x y =\n  int_Discrete (h x) (h y)\n","open Datatypes\n\n(** val concat : 'a1 list list -> 'a1 list **)\n\nlet rec concat = function\n| [] -> []\n| x :: l0 -> app x (concat l0)\n\n(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)\n\nlet rec map f = function\n| [] -> []\n| a :: t -> (f a) :: (map f t)\n\n(** val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1 **)\n\nlet rec fold_right f a0 = function\n| [] -> a0\n| b :: t -> f b (fold_right f a0 t)\n\n(** val filter : ('a1 -> bool) -> 'a1 list -> 'a1 list **)\n\nlet rec filter f = function\n| [] -> []\n| x :: l0 -> if f x then x :: (filter f l0) else filter f l0\n","open Datatypes\nopen Dec\nopen Game\nopen Graph\nopen IntMap\nopen List0\nopen Player\nopen Sort\nopen TB\n\ntype __ = Obj.t\nlet __ = let rec f _ = Obj.repr f in Obj.repr f\n\n(** val coq_NoDup_dec : 'a1 coq_Discrete -> 'a1 list -> bool **)\n\nlet rec coq_NoDup_dec h = function\n| [] -> true\n| y :: l -> let s = in_dec h y l in if s then false else coq_NoDup_dec h l\n\ntype coq_BG_State = { to_play : coq_Player; bear : coq_Vert;\n                      hunters : coq_Vert list }\n\ntype coq_BearMv =\n  coq_Vert\n  (* singleton inductive, whose constructor was Build_BearMv *)\n\ntype coq_HunterMv = { h_orig : coq_Vert; h_dest : coq_Vert }\n\ntype coq_BG_Move =\n| BearMove of coq_BearMv\n| HunterMove of coq_HunterMv\n\n(** val create_Move :\n    coq_Graph -> coq_BG_State -> coq_Vert -> coq_Vert -> coq_BG_Move option **)\n\nlet create_Move g s v v' =\n  let p = s.to_play in\n  (match p with\n   | White ->\n     let s0 = in_dec (coq_Graph_Vert_disc g) v s.hunters in\n     if s0\n     then let s1 = in_dec (coq_Graph_Vert_disc g) v' (g.successors v) in\n          if s1\n          then let d = coq_Graph_Vert_disc g v' s.bear in\n               if d\n               then None\n               else let s2 = in_dec (coq_Graph_Vert_disc g) v' s.hunters in\n                    if s2\n                    then let d0 = coq_Graph_Vert_disc g v' v in\n                         if d0\n                         then Some (HunterMove { h_orig = v; h_dest = v' })\n                         else None\n                    else Some (HunterMove { h_orig = v; h_dest = v' })\n          else None\n     else None\n   | Black ->\n     let d = coq_Graph_Vert_disc g v s.bear in\n     if d\n     then let s0 = in_dec (coq_Graph_Vert_disc g) v' (g.successors v) in\n          if s0\n          then let s1 = in_dec (coq_Graph_Vert_disc g) v' s.hunters in\n               if s1 then None else Some (BearMove v')\n          else None\n     else None)\n\n(** val is_hunter : coq_Graph -> coq_BG_State -> coq_Vert -> bool **)\n\nlet is_hunter g s v =\n  if in_dec (coq_Graph_Vert_disc g) v s.hunters then true else false\n\n(** val is_bear : coq_Graph -> coq_BG_State -> coq_Vert -> bool **)\n\nlet is_bear g s v =\n  if coq_Graph_Vert_disc g v s.bear then true else false\n\n(** val exec_move :\n    coq_Graph -> coq_BG_State -> coq_BG_Move -> coq_BG_State **)\n\nlet exec_move g s = function\n| BearMove b -> { to_play = White; bear = b; hunters = s.hunters }\n| HunterMove h ->\n  { to_play = Black; bear = s.bear; hunters =\n    (insertion_sort\n      (subcount_Ord (coq_Graph_Vert_disc g) (coq_Graph_Vert_enum g))\n      (h.h_dest :: (remove (coq_Graph_Vert_disc g) h.h_orig s.hunters))) }\n\n(** val pf_map : 'a1 list -> ('a1 -> __ -> 'a2) -> 'a2 list **)\n\nlet rec pf_map xs f =\n  match xs with\n  | [] -> []\n  | x :: l -> (f x __) :: (pf_map l (fun x' _ -> f x' __))\n\n(** val eqb : 'a1 coq_Discrete -> 'a1 -> 'a1 -> bool **)\n\nlet eqb h x x' =\n  if h x x' then true else false\n\n(** val enum_moves : coq_Graph -> coq_BG_State -> coq_BG_Move list **)\n\nlet enum_moves g s =\n  let p = s.to_play in\n  (match p with\n   | White ->\n     concat\n       (pf_map s.hunters (fun h _ ->\n         pf_map\n           (filter (fun v ->\n             (&&) (negb (eqb (coq_Graph_Vert_disc g) v s.bear))\n               ((||) (negb (in_decb (coq_Graph_Vert_disc g) v s.hunters))\n                 (eqb (coq_Graph_Vert_disc g) v h))) (g.successors h))\n           (fun v _ -> HunterMove { h_orig = h; h_dest = v })))\n   | Black ->\n     pf_map\n       (filter (fun v -> negb (in_decb (coq_Graph_Vert_disc g) v s.hunters))\n         (g.successors s.bear)) (fun v _ -> BearMove v))\n\n(** val atomic_res : coq_Graph -> coq_BG_State -> coq_Result option **)\n\nlet atomic_res g s =\n  match enum_moves g s with\n  | [] ->\n    (match s.to_play with\n     | White -> Some Draw\n     | Black -> Some (Win White))\n  | _ :: _ -> None\n\n(** val coq_BearGame : coq_Graph -> coq_Game **)\n\nlet coq_BearGame g =\n  { Game.to_play = (Obj.magic (fun b -> b.to_play)); Game.exec_move =\n    (Obj.magic exec_move g); Game.atomic_res = (Obj.magic atomic_res g);\n    Game.enum_moves = (Obj.magic enum_moves g) }\n","open IntMap\n\ntype __ = Obj.t\n\ntype 'v coq_OM = 'v M.t\n\n(** val empty : 'a1 coq_OM **)\n\nlet empty = M.empty\n\n(** val add : Uint63.t -> 'a1 -> 'a1 coq_OM -> 'a1 coq_OM **)\n\nlet add = M.insert\n\n(** val lookup : Uint63.t -> 'a1 coq_OM -> 'a1 option **)\n\nlet lookup = M.lookup\n\n(** val size : 'a1 coq_OM -> int **)\n\nlet size = M.size\n\n(** val coq_OMap : __ coq_OM coq_IntMap **)\n\nlet coq_OMap =\n  { IntMap.empty = (fun _ -> empty); IntMap.add = (fun _ -> add);\n    IntMap.lookup = (fun _ -> lookup); IntMap.size = (fun _ -> size) }\n","open Game\nopen IntHash\nopen IntMap\nopen OMap\nopen Player\nopen Specif\nopen Strategy\n\ntype __ = Obj.t\nlet __ = let rec f _ = Obj.repr f in Obj.repr f\n\ntype coq_OCamlTablebase = { tb_whites : (coq_Player * int) coq_OM;\n                            tb_blacks : (coq_Player * int) coq_OM }\n\n(** val query_TB :\n    coq_Game -> coq_GameState coq_IntHash -> coq_OCamlTablebase ->\n    coq_GameState -> (coq_Player * int) option **)\n\nlet query_TB g h tb s =\n  match g.to_play s with\n  | White -> hash_lookup (Obj.magic coq_OMap) h s tb.tb_whites\n  | Black -> hash_lookup (Obj.magic coq_OMap) h s tb.tb_blacks\n\n(** val p_leb :\n    coq_Player -> (coq_Player * int) option -> (coq_Player * int) option ->\n    bool **)\n\nlet p_leb pl r1 r2 =\n  match pl with\n  | White ->\n    (match r1 with\n     | Some p ->\n       let (p0, m) = p in\n       (match p0 with\n        | White ->\n          (match r2 with\n           | Some p1 ->\n             let (p2, n) = p1 in\n             (match p2 with\n              | White -> (<=) n m\n              | Black -> false)\n           | None -> false)\n        | Black ->\n          (match r2 with\n           | Some p1 ->\n             let (p2, n) = p1 in\n             (match p2 with\n              | White -> true\n              | Black -> (<=) m n)\n           | None -> true))\n     | None ->\n       (match r2 with\n        | Some p ->\n          let (p0, _) = p in (match p0 with\n                              | White -> true\n                              | Black -> false)\n        | None -> true))\n  | Black ->\n    (match r1 with\n     | Some p ->\n       let (p0, m) = p in\n       (match p0 with\n        | White ->\n          (match r2 with\n           | Some p1 ->\n             let (p2, n) = p1 in\n             (match p2 with\n              | White -> (<=) m n\n              | Black -> true)\n           | None -> true)\n        | Black ->\n          (match r2 with\n           | Some p1 ->\n             let (p2, n) = p1 in\n             (match p2 with\n              | White -> false\n              | Black -> (<=) n m)\n           | None -> false))\n     | None ->\n       (match r2 with\n        | Some p ->\n          let (p0, _) = p in (match p0 with\n                              | White -> false\n                              | Black -> true)\n        | None -> true))\n\n(** val max_by : ('a1 -> 'a1 -> bool) -> 'a1 list -> 'a1 option **)\n\nlet rec max_by x_leb = function\n| [] -> None\n| x :: xs' ->\n  (match max_by x_leb xs' with\n   | Some y -> if x_leb x y then Some y else Some x\n   | None -> Some x)\n\n(** val max_by_ne_Some :\n    ('a1 -> 'a1 -> bool) -> 'a1 list -> ('a1, __) sigT **)\n\nlet max_by_ne_Some x_leb = function\n| [] -> assert false (* absurd case *)\n| x :: l ->\n  let o = max_by x_leb l in\n  (match o with\n   | Some x0 ->\n     let b = x_leb x x0 in\n     if b then Coq_existT (x0, __) else Coq_existT (x, __)\n   | None -> Coq_existT (x, __))\n\n(** val max_by_ne : ('a1 -> 'a1 -> bool) -> 'a1 list -> 'a1 **)\n\nlet max_by_ne x_leb xs =\n  projT1 (max_by_ne_Some x_leb xs)\n\n(** val tb_strat :\n    coq_Game -> coq_GameState -> coq_Player -> 'a1 coq_IntMap ->\n    coq_GameState coq_IntHash -> coq_OCamlTablebase -> strategy **)\n\nlet rec tb_strat g s pl h h0 tb =\n  let o = g.atomic_res s in\n  (match o with\n   | Some r -> lazy (Coq_atom_strategy (s, r))\n   | None ->\n     let s0 = player_id_or_opp_r_t (g.to_play s) pl in\n     if s0\n     then let m =\n            max_by_ne (fun m1 m2 ->\n              p_leb pl (query_TB g h0 tb (g.exec_move s m1))\n                (query_TB g h0 tb (g.exec_move s m2))) (g.enum_moves s)\n          in\n          lazy (Coq_eloise_strategy (s, m,\n          (tb_strat g (g.exec_move s m) pl h h0 tb)))\n     else lazy (Coq_abelard_strategy (s, (fun m ->\n            tb_strat g (g.exec_move s m) pl h h0 tb))))\n","open Yojson.Safe\n\nlet json_to_tup = function\n  | (i_str, `Tuple [`String \"White\"; `Int n]) -> (Int64.of_string i_str, (Player.White, n))\n  | (i_str, `Tuple [`String \"Black\"; `Int n]) -> (Int64.of_string i_str, (Player.Black, n))\n  | _ -> failwith \"Error converting json to tuple.\"\n\nlet json_to_tups = function\n  | `Assoc pairs -> List.rev_map json_to_tup pairs\n  | _ -> failwith \"Error converting json to tuples.\"\n\nlet make_tb =\n  let inc_w = open_in \"tb_w.json\" in\n  let inc_b = open_in \"tb_b.json\" in\n  let js_w = from_channel inc_w in\n  let js_b = from_channel inc_b in\n  let tups_w = json_to_tups js_w in\n  let tups_b = json_to_tups js_b in\n  let m_w = List.fold_left (fun m (str, pr) -> M.insert str pr m) M.empty tups_w in\n  let m_b = List.fold_left (fun m (str, pr) -> M.insert str pr m) M.empty tups_b in\n  let () = close_in inc_w in\n  let () = close_in inc_b in\n  { OCamlTB.tb_whites = m_w; OCamlTB.tb_blacks = m_b }","module Js = struct\n  type t\n\n  type 'a js_array = t\n\n  type ('a, 'b) meth_callback = t\n\n  external string : string -> t = \"caml_jsstring_of_string\"\n\n  external to_string : t -> string = \"caml_string_of_jsstring\"\n\n  external bytestring : string -> t = \"caml_jsbytes_of_string\"\n\n  external to_bytestring : t -> string = \"caml_string_of_jsbytes\"\n\n  external bool : bool -> t = \"caml_js_from_bool\"\n\n  external to_bool : t -> bool = \"caml_js_to_bool\"\n\n  external array : 'a array -> t = \"caml_js_from_array\"\n\n  external to_array : t -> 'a array = \"caml_js_to_array\"\n\n  external number_of_float : float -> t = \"caml_js_from_float\"\n\n  external float_of_number : t -> float = \"caml_js_to_float\"\n\n  external number_of_int32 : int32 -> t = \"caml_js_from_int32\"\n\n  external int32_of_number : t -> int32 = \"caml_js_to_int32\"\n\n  external number_of_nativeint : nativeint -> t = \"caml_js_from_nativeint\"\n\n  external nativeint_of_number : t -> nativeint = \"caml_js_to_nativeint\"\n\n  external typeof : t -> t = \"caml_js_typeof\"\n\n  external instanceof : t -> t -> bool = \"caml_js_instanceof\"\n\n  external debugger : unit -> unit = \"debugger\"\n\n  external get : t -> t -> t = \"caml_js_get\"\n\n  external set : t -> t -> t -> unit = \"caml_js_set\"\n\n  external delete : t -> t -> unit = \"caml_js_delete\"\n\n  external call : t -> t -> t array -> t = \"caml_js_call\"\n\n  external fun_call : t -> t array -> t = \"caml_js_fun_call\"\n\n  external meth_call : t -> string -> t array -> t = \"caml_js_meth_call\"\n\n  external new_obj : t -> t array -> t = \"caml_js_new\"\n\n  external new_obj_arr : t -> t js_array -> t = \"caml_ojs_new_arr\"\n\n  external obj : (string * t) array -> t = \"caml_js_object\"\n\n  external equals : t -> t -> bool = \"caml_js_equals\"\n\n  external strict_equals : t -> t -> bool = \"caml_js_strict_equals\"\n\n  external pure_expr : (unit -> 'a) -> 'a = \"caml_js_pure_expr\"\n\n  external eval_string : string -> 'a = \"caml_js_eval_string\"\n\n  external js_expr : string -> 'a = \"caml_js_expr\"\n\n  external pure_js_expr : string -> 'a = \"caml_pure_js_expr\"\n\n  external callback : ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_callback_unsafe\"\n\n  external callback_with_arguments :\n    (t js_array -> 'b) -> ('c, t js_array -> 'b) meth_callback\n    = \"caml_js_wrap_callback_arguments\"\n\n  external callback_with_arity : int -> ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback_strict\"\n\n  external meth_callback : ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_unsafe\"\n\n  external meth_callback_with_arity : int -> ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_strict\"\n\n  external meth_callback_with_arguments :\n    ('b -> t js_array -> 'a) -> ('b, t js_array -> 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_arguments\"\n\n  external wrap_callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback\"\n\n  external wrap_meth_callback : ('a -> 'b) -> ('a, 'b) meth_callback\n    = \"caml_js_wrap_meth_callback\"\nend\n\nmodule Sys = struct\n  type 'a callback = 'a\n\n  external create_file : name:string -> content:string -> unit = \"caml_create_file\"\n\n  external read_file : name:string -> string = \"caml_read_file_content\"\n\n  external set_channel_output' : out_channel -> (js_string:Js.t -> unit) callback -> unit\n    = \"caml_ml_set_channel_output\"\n\n  external set_channel_input' : in_channel -> (unit -> string) callback -> unit\n    = \"caml_ml_set_channel_refill\"\n\n  external mount_point : unit -> string list = \"caml_list_mount_point\"\n\n  external mount_autoload : string -> (string -> string -> string option) callback -> unit\n    = \"caml_mount_autoload\"\n\n  external unmount : string -> unit = \"caml_unmount\"\n\n  module Config = struct\n    external use_js_string : unit -> bool = \"caml_jsoo_flags_use_js_string\"\n\n    external effects : unit -> bool = \"caml_jsoo_flags_effects\"\n  end\n\n  let version = Runtime_version.s\n\n  let git_version = Runtime_version.git_version\nend\n\nmodule Error : sig\n  type t\n\n  val raise_ : t -> 'a\n\n  val attach_js_backtrace : exn -> force:bool -> exn\n  (** Attach a JavasScript error to an OCaml exception.  if [force = false] and a\n    JavasScript error is already attached, it will do nothing. This function is useful to\n    store and retrieve information about JavaScript stack traces.\n\n    Attaching JavasScript errors will happen automatically when compiling with\n    [--enable with-js-error]. *)\n\n  val of_exn : exn -> t option\n  (** Extract a JavaScript error attached to an OCaml exception, if any.  This is useful to\n      inspect an eventual stack strace, especially when sourcemap is enabled. *)\n\n  exception Exn of t\n  (** The [Error] exception wrap javascript exceptions when caught by OCaml code.\n      In case the javascript exception is not an instance of javascript [Error],\n      it will be serialized and wrapped into a [Failure] exception.\n  *)\nend = struct\n  type t\n\n  exception Exn of t\n\n  let _ = Callback.register_exception \"jsError\" (Exn (Obj.magic [||]))\n\n  let raise_ : t -> 'a = Js.js_expr \"(function (exn) { throw exn })\"\n\n  external of_exn : exn -> t option = \"caml_js_error_option_of_exception\"\n\n  external attach_js_backtrace : exn -> force:bool -> exn = \"caml_exn_with_js_backtrace\"\nend\n\n[@@@ocaml.warning \"-32-60\"]\n\nmodule For_compatibility_only = struct\n  (* Add primitives for compatibility reasons. Existing users might\n     depend on it (e.g. gen_js_api), we dont want the ocaml compiler\n     to complain about theses missing primitives. *)\n\n  external caml_js_from_string : string -> Js.t = \"caml_js_from_string\"\n\n  external caml_js_to_byte_string : Js.t -> string = \"caml_js_to_byte_string\"\n\n  external caml_js_to_string : Js.t -> string = \"caml_js_to_string\"\n\n  external caml_list_of_js_array : 'a Js.js_array -> 'a list = \"caml_list_of_js_array\"\n\n  external caml_list_to_js_array : 'a list -> 'a Js.js_array = \"caml_list_to_js_array\"\n\n  external variable : string -> 'a = \"caml_js_var\"\nend\n\nmodule Typed_array = struct\n  type ('a, 'b) typedArray = Js.t\n\n  type arrayBuffer = Js.t\n\n  type uint8Array = Js.t\n\n  external kind : ('a, 'b) typedArray -> ('a, 'b) Bigarray.kind\n    = \"caml_ba_kind_of_typed_array\"\n\n  external from_genarray :\n    ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t -> ('a, 'b) typedArray\n    = \"caml_ba_to_typed_array\"\n\n  external to_genarray :\n    ('a, 'b) typedArray -> ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t\n    = \"caml_ba_from_typed_array\"\n\n  module Bigstring = struct\n    type t = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t\n\n    external to_arrayBuffer : t -> arrayBuffer = \"bigstring_to_array_buffer\"\n\n    external to_uint8Array : t -> uint8Array = \"bigstring_to_typed_array\"\n\n    external of_arrayBuffer : arrayBuffer -> t = \"bigstring_of_array_buffer\"\n\n    external of_uint8Array : uint8Array -> t = \"bigstring_of_typed_array\"\n  end\n\n  external of_uint8Array : uint8Array -> string = \"caml_string_of_array\"\nend\n\nmodule Int64 = struct\n  external create_int64_lo_mi_hi : int -> int -> int -> Int64.t\n    = \"caml_int64_create_lo_mi_hi\"\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Registering OCaml values with the C runtime for later callbacks *)\n\nexternal register_named_value : string -> Obj.t -> unit\n                              = \"caml_register_named_value\"\n\nlet register name v =\n  register_named_value name (Obj.repr v)\n\nlet register_exception name (exn : exn) =\n  let exn = Obj.repr exn in\n  let slot = if Obj.tag exn = Obj.object_tag then exn else Obj.field exn 0 in\n  register_named_value name slot\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\nopen! Import\n\n(* This local module [Js] is needed so that the ppx_js extension work within that file. *)\nmodule Js = struct\n  type +'a t\n\n  type (-'a, +'b) meth_callback\n\n  module Unsafe = struct\n    type top\n\n    type any = top t\n\n    type any_js_array = any\n\n    external inject : 'a -> any = \"%identity\"\n\n    external coerce : _ t -> _ t = \"%identity\"\n\n    external get : 'a -> 'b -> 'c = \"caml_js_get\"\n\n    external set : 'a -> 'b -> 'c -> unit = \"caml_js_set\"\n\n    external delete : 'a -> 'b -> unit = \"caml_js_delete\"\n\n    external call : 'a -> 'b -> any array -> 'c = \"caml_js_call\"\n\n    external fun_call : 'a -> any array -> 'b = \"caml_js_fun_call\"\n\n    external meth_call : 'a -> string -> any array -> 'b = \"caml_js_meth_call\"\n\n    external new_obj : 'a -> any array -> 'b = \"caml_js_new\"\n\n    external new_obj_arr : 'a -> any_js_array -> 'b = \"caml_ojs_new_arr\"\n\n    external obj : (string * any) array -> 'a = \"caml_js_object\"\n\n    external equals : 'a -> 'b -> bool = \"caml_js_equals\"\n\n    external strict_equals : 'a -> 'b -> bool = \"caml_js_strict_equals\"\n\n    external pure_expr : (unit -> 'a) -> 'a = \"caml_js_pure_expr\"\n\n    external eval_string : string -> 'a = \"caml_js_eval_string\"\n\n    external js_expr : string -> 'a = \"caml_js_expr\"\n\n    external pure_js_expr : string -> 'a = \"caml_pure_js_expr\"\n\n    let global = pure_js_expr \"globalThis\"\n\n    external callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n      = \"caml_js_wrap_callback_unsafe\"\n\n    external callback_with_arguments :\n      (any_js_array -> 'b) -> ('c, any_js_array -> 'b) meth_callback\n      = \"caml_js_wrap_callback_arguments\"\n\n    external callback_with_arity : int -> ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n      = \"caml_js_wrap_callback_strict\"\n\n    external meth_callback : ('b -> 'a) -> ('b, 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_unsafe\"\n\n    external meth_callback_with_arity : int -> ('b -> 'a) -> ('b, 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_strict\"\n\n    external meth_callback_with_arguments :\n      ('b -> any_js_array -> 'a) -> ('b, any_js_array -> 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_arguments\"\n\n    (* DEPRECATED *)\n    external variable : string -> 'a = \"caml_js_var\"\n  end\n\n  (****)\n\n  type 'a opt = 'a\n\n  type 'a optdef = 'a\n\n  external debugger : unit -> unit = \"debugger\"\n\n  let null : 'a opt = Unsafe.pure_js_expr \"null\"\n\n  external some : 'a -> 'a opt = \"%identity\"\n\n  let undefined : 'a optdef = Unsafe.pure_js_expr \"undefined\"\n\n  external def : 'a -> 'a optdef = \"%identity\"\n\n  module type OPT = sig\n    type 'a t\n\n    val empty : 'a t\n\n    val return : 'a -> 'a t\n\n    val map : 'a t -> ('a -> 'b) -> 'b t\n\n    val bind : 'a t -> ('a -> 'b t) -> 'b t\n\n    val test : 'a t -> bool\n\n    val iter : 'a t -> ('a -> unit) -> unit\n\n    val case : 'a t -> (unit -> 'b) -> ('a -> 'b) -> 'b\n\n    val get : 'a t -> (unit -> 'a) -> 'a\n\n    val option : 'a option -> 'a t\n\n    val to_option : 'a t -> 'a option\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n  end\n\n  module Opt : OPT with type 'a t = 'a opt = struct\n    type 'a t = 'a opt\n\n    let empty = null\n\n    let return = some\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n    let map x f = if equals x null then null else return (f x)\n\n    let bind x f = if equals x null then null else f x\n\n    let test x = not (equals x null)\n\n    let iter x f = if not (equals x null) then f x\n\n    let case x f g = if equals x null then f () else g x\n\n    let get x f = if equals x null then f () else x\n\n    let option x =\n      match x with\n      | None -> empty\n      | Some x -> return x\n\n    let to_option x = case x (fun () -> None) (fun x -> Some x)\n  end\n\n  module Optdef : OPT with type 'a t = 'a optdef = struct\n    type 'a t = 'a optdef\n\n    let empty = undefined\n\n    let return = def\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n    let map x f = if strict_equals x undefined then undefined else return (f x)\n\n    let bind x f = if strict_equals x undefined then undefined else f x\n\n    let test x = not (strict_equals x undefined)\n\n    let iter x f = if not (strict_equals x undefined) then f x\n\n    let case x f g = if strict_equals x undefined then f () else g x\n\n    let get x f = if strict_equals x undefined then f () else x\n\n    let option x =\n      match x with\n      | None -> empty\n      | Some x -> return x\n\n    let to_option x = case x (fun () -> None) (fun x -> Some x)\n  end\n\n  (****)\n\n  let coerce x f g = Opt.get (f x) (fun () -> g x)\n\n  let coerce_opt x f g = Opt.get (Opt.bind x f) (fun () -> g x)\n\n  (****)\n\n  type +'a meth\n\n  type +'a gen_prop\n\n  type 'a readonly_prop = < get : 'a > gen_prop\n\n  type 'a writeonly_prop = < set : 'a -> unit > gen_prop\n\n  type 'a prop = < get : 'a ; set : 'a -> unit > gen_prop\n\n  type 'a optdef_prop = < get : 'a optdef ; set : 'a -> unit > gen_prop\n\n  type +'a constr\n\n  (****)\n\n  type 'a callback = (unit, 'a) meth_callback\n\n  external wrap_callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback\"\n\n  external wrap_meth_callback : ('a -> 'b) -> ('a, 'b) meth_callback\n    = \"caml_js_wrap_meth_callback\"\n\n  (****)\n\n  external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n  external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n  (****)\n\n  let _true = Unsafe.pure_js_expr \"true\"\n\n  let _false = Unsafe.pure_js_expr \"false\"\n\n  type match_result_handle\n\n  type string_array\n\n  type number_t = float\n\n  class type number = object\n    method toString : js_string t meth\n\n    method toString_radix : int -> js_string t meth\n\n    method toLocaleString : js_string t meth\n\n    method toFixed : int -> js_string t meth\n\n    method toExponential : js_string t meth\n\n    method toExponential_digits : int -> js_string t meth\n\n    method toPrecision : int -> js_string t meth\n  end\n\n  and js_string = object\n    method toString : js_string t meth\n\n    method valueOf : js_string t meth\n\n    method charAt : int -> js_string t meth\n\n    method charCodeAt : int -> number_t meth\n\n    (* This may return NaN... *)\n    method concat : js_string t -> js_string t meth\n\n    method concat_2 : js_string t -> js_string t -> js_string t meth\n\n    method concat_3 : js_string t -> js_string t -> js_string t -> js_string t meth\n\n    method concat_4 :\n      js_string t -> js_string t -> js_string t -> js_string t -> js_string t meth\n\n    method indexOf : js_string t -> int meth\n\n    method indexOf_from : js_string t -> int -> int meth\n\n    method lastIndexOf : js_string t -> int meth\n\n    method lastIndexOf_from : js_string t -> int -> int meth\n\n    method localeCompare : js_string t -> number_t meth\n\n    method _match : regExp t -> match_result_handle t opt meth\n\n    method normalize : js_string t meth\n\n    method normalize_form : normalization t -> js_string t meth\n\n    method replace : regExp t -> js_string t -> js_string t meth\n\n    method replace_string : js_string t -> js_string t -> js_string t meth\n\n    method search : regExp t -> int meth\n\n    method slice : int -> int -> js_string t meth\n\n    method slice_end : int -> js_string t meth\n\n    method split : js_string t -> string_array t meth\n\n    method split_limited : js_string t -> int -> string_array t meth\n\n    method split_regExp : regExp t -> string_array t meth\n\n    method split_regExpLimited : regExp t -> int -> string_array t meth\n\n    method substring : int -> int -> js_string t meth\n\n    method substring_toEnd : int -> js_string t meth\n\n    method toLowerCase : js_string t meth\n\n    method toLocaleLowerCase : js_string t meth\n\n    method toUpperCase : js_string t meth\n\n    method toLocaleUpperCase : js_string t meth\n\n    method trim : js_string t meth\n\n    method length : int readonly_prop\n  end\n\n  and regExp = object\n    method exec : js_string t -> match_result_handle t opt meth\n\n    method test : js_string t -> bool t meth\n\n    method toString : js_string t meth\n\n    method source : js_string t readonly_prop\n\n    method global : bool t readonly_prop\n\n    method ignoreCase : bool t readonly_prop\n\n    method multiline : bool t readonly_prop\n\n    method lastIndex : int prop\n  end\n\n  and normalization = js_string\n\n  (* string is used by ppx_js, it needs to come before any use of the\n     new syntax in this file *)\n  external string : string -> js_string t = \"caml_jsstring_of_string\"\n\n  external to_string : js_string t -> string = \"caml_string_of_jsstring\"\n\n  let nfc = string \"NFC\"\n\n  let nfd = string \"NFD\"\n\n  let nfkc = string \"NFKC\"\n\n  let nfkd = string \"NFKD\"\nend\n\ninclude Js\n\nclass type string_constr = object\n  method fromCharCode : int -> js_string t meth\nend\n\nlet string_constr = Unsafe.global##._String\n\nlet regExp = Unsafe.global##._RegExp\n\nlet regExp_copy = regExp\n\nlet regExp_withFlags = regExp\n\nclass type ['a] js_array = object\n  method toString : js_string t meth\n\n  method toLocaleString : js_string t meth\n\n  method concat : 'a js_array t -> 'a js_array t meth\n\n  method join : js_string t -> js_string t meth\n\n  method pop : 'a optdef meth\n\n  method push : 'a -> int meth\n\n  method push_2 : 'a -> 'a -> int meth\n\n  method push_3 : 'a -> 'a -> 'a -> int meth\n\n  method push_4 : 'a -> 'a -> 'a -> 'a -> int meth\n\n  method reverse : 'a js_array t meth\n\n  method shift : 'a optdef meth\n\n  method slice : int -> int -> 'a js_array t meth\n\n  method slice_end : int -> 'a js_array t meth\n\n  method sort : ('a -> 'a -> number_t) callback -> 'a js_array t meth\n\n  method sort_asStrings : 'a js_array t meth\n\n  method splice : int -> int -> 'a js_array t meth\n\n  method splice_1 : int -> int -> 'a -> 'a js_array t meth\n\n  method splice_2 : int -> int -> 'a -> 'a -> 'a js_array t meth\n\n  method splice_3 : int -> int -> 'a -> 'a -> 'a -> 'a js_array t meth\n\n  method splice_4 : int -> int -> 'a -> 'a -> 'a -> 'a -> 'a js_array t meth\n\n  method unshift : 'a -> int meth\n\n  method unshift_2 : 'a -> 'a -> int meth\n\n  method unshift_3 : 'a -> 'a -> 'a -> int meth\n\n  method unshift_4 : 'a -> 'a -> 'a -> 'a -> int meth\n\n  method some : ('a -> int -> 'a js_array t -> bool t) callback -> bool t meth\n\n  method every : ('a -> int -> 'a js_array t -> bool t) callback -> bool t meth\n\n  method forEach : ('a -> int -> 'a js_array t -> unit) callback -> unit meth\n\n  method map : ('a -> int -> 'a js_array t -> 'b) callback -> 'b js_array t meth\n\n  method filter : ('a -> int -> 'a js_array t -> bool t) callback -> 'a js_array t meth\n\n  method reduce_init : ('b -> 'a -> int -> 'a js_array t -> 'b) callback -> 'b -> 'b meth\n\n  method reduce : ('a -> 'a -> int -> 'a js_array t -> 'a) callback -> 'a meth\n\n  method reduceRight_init :\n    ('b -> 'a -> int -> 'a js_array t -> 'b) callback -> 'b -> 'b meth\n\n  method reduceRight : ('a -> 'a -> int -> 'a js_array t -> 'a) callback -> 'a meth\n\n  method length : int prop\nend\n\nlet object_constructor = Unsafe.global##._Object\n\nlet object_keys o : js_string t js_array t = object_constructor##keys o\n\nlet array_constructor = Unsafe.global##._Array\n\nlet array_empty = array_constructor\n\nlet array_length = array_constructor\n\nlet array_get : 'a #js_array t -> int -> 'a optdef = Unsafe.get\n\nlet array_set : 'a #js_array t -> int -> 'a -> unit = Unsafe.set\n\nlet array_map_poly :\n    'a #js_array t -> ('a -> int -> 'a #js_array t -> 'b) callback -> 'b #js_array t =\n fun a cb -> (Unsafe.coerce a)##map cb\n\nlet array_map f a = array_map_poly a (wrap_callback (fun x _idx _ -> f x))\n\nlet array_mapi f a = array_map_poly a (wrap_callback (fun x idx _ -> f idx x))\n\nclass type match_result = object\n  inherit [js_string t] js_array\n\n  method index : int readonly_prop\n\n  method input : js_string t readonly_prop\nend\n\nlet str_array : string_array t -> js_string t js_array t = Unsafe.coerce\n\nlet match_result : match_result_handle t -> match_result t = Unsafe.coerce\n\nclass type date = object\n  method toString : js_string t meth\n\n  method toDateString : js_string t meth\n\n  method toTimeString : js_string t meth\n\n  method toLocaleString : js_string t meth\n\n  method toLocaleDateString : js_string t meth\n\n  method toLocaleTimeString : js_string t meth\n\n  method valueOf : number_t meth\n\n  method getTime : number_t meth\n\n  method getFullYear : int meth\n\n  method getUTCFullYear : int meth\n\n  method getMonth : int meth\n\n  method getUTCMonth : int meth\n\n  method getDate : int meth\n\n  method getUTCDate : int meth\n\n  method getDay : int meth\n\n  method getUTCDay : int meth\n\n  method getHours : int meth\n\n  method getUTCHours : int meth\n\n  method getMinutes : int meth\n\n  method getUTCMinutes : int meth\n\n  method getSeconds : int meth\n\n  method getUTCSeconds : int meth\n\n  method getMilliseconds : int meth\n\n  method getUTCMilliseconds : int meth\n\n  method getTimezoneOffset : int meth\n\n  method setTime : number_t -> number_t meth\n\n  method setFullYear : int -> number_t meth\n\n  method setUTCFullYear : int -> number_t meth\n\n  method setMonth : int -> number_t meth\n\n  method setUTCMonth : int -> number_t meth\n\n  method setDate : int -> number_t meth\n\n  method setUTCDate : int -> number_t meth\n\n  method setDay : int -> number_t meth\n\n  method setUTCDay : int -> number_t meth\n\n  method setHours : int -> number_t meth\n\n  method setUTCHours : int -> number_t meth\n\n  method setMinutes : int -> number_t meth\n\n  method setUTCMinutes : int -> number_t meth\n\n  method setSeconds : int -> number_t meth\n\n  method setUTCSeconds : int -> number_t meth\n\n  method setMilliseconds : int -> number_t meth\n\n  method setUTCMilliseconds : int -> number_t meth\n\n  method toUTCString : js_string t meth\n\n  method toISOString : js_string t meth\n\n  method toJSON : 'a -> js_string t meth\nend\n\nclass type date_constr = object\n  method parse : js_string t -> number_t meth\n\n  method _UTC_month : int -> int -> number_t meth\n\n  method _UTC_day : int -> int -> number_t meth\n\n  method _UTC_hour : int -> int -> int -> int -> number_t meth\n\n  method _UTC_min : int -> int -> int -> int -> int -> number_t meth\n\n  method _UTC_sec : int -> int -> int -> int -> int -> int -> number_t meth\n\n  method _UTC_ms : int -> int -> int -> int -> int -> int -> int -> number_t meth\n\n  method now : number_t meth\nend\n\nlet date_constr = Unsafe.global##._Date\n\nlet date : date_constr t = date_constr\n\nlet date_now : date t constr = date_constr\n\nlet date_fromTimeValue : (number_t -> date t) constr = date_constr\n\nlet date_month : (int -> int -> date t) constr = date_constr\n\nlet date_day : (int -> int -> int -> date t) constr = date_constr\n\nlet date_hour : (int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_min : (int -> int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_sec : (int -> int -> int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_ms : (int -> int -> int -> int -> int -> int -> int -> date t) constr =\n  date_constr\n\nclass type math = object\n  method _E : number_t readonly_prop\n\n  method _LN2 : number_t readonly_prop\n\n  method _LN10 : number_t readonly_prop\n\n  method _LOG2E : number_t readonly_prop\n\n  method _LOG10E : number_t readonly_prop\n\n  method _PI : number_t readonly_prop\n\n  method _SQRT1_2_ : number_t readonly_prop\n\n  method _SQRT2 : number_t readonly_prop\n\n  method abs : number_t -> number_t meth\n\n  method acos : number_t -> number_t meth\n\n  method asin : number_t -> number_t meth\n\n  method atan : number_t -> number_t meth\n\n  method atan2 : number_t -> number_t -> number_t meth\n\n  method ceil : number_t -> number_t meth\n\n  method cos : number_t -> number_t meth\n\n  method exp : number_t -> number_t meth\n\n  method floor : number_t -> number_t meth\n\n  method log : number_t -> number_t meth\n\n  method max : number_t -> number_t -> number_t meth\n\n  method max_3 : number_t -> number_t -> number_t -> number_t meth\n\n  method max_4 : number_t -> number_t -> number_t -> number_t -> number_t meth\n\n  method min : number_t -> number_t -> number_t meth\n\n  method min_3 : number_t -> number_t -> number_t -> number_t meth\n\n  method min_4 : number_t -> number_t -> number_t -> number_t -> number_t meth\n\n  method pow : number_t -> number_t -> number_t meth\n\n  method random : number_t meth\n\n  method round : number_t -> number_t meth\n\n  method sin : number_t -> number_t meth\n\n  method sqrt : number_t -> number_t meth\n\n  method tan : number_t -> number_t meth\nend\n\nlet math = Unsafe.global##._Math\n\nclass type error = object\n  method name : js_string t prop\n\n  method message : js_string t prop\n\n  method stack : js_string t optdef prop\n\n  method toString : js_string t meth\nend\n\nlet error_constr = Unsafe.global##._Error\n\nmodule Js_error = struct\n  type error_t = error t\n\n  include Jsoo_runtime.Error\n\n  external of_error : error_t -> t = \"%identity\"\n\n  external to_error : t -> error_t = \"%identity\"\n\n  let name e = to_string (to_error e)##.name\n\n  let message e = to_string (to_error e)##.message\n\n  let stack (e : t) : string option =\n    Opt.to_option (Opt.map (to_error e)##.stack to_string)\n\n  let to_string e = to_string (to_error e)##toString\nend\n\nmodule Magic = struct\n  module type T = sig\n    exception Error of error t\n  end\n\n  type ('a, 'b) eq = Eq : ('a, 'a) eq\n\n  let (eq : (error t, Js_error.t) eq) = Obj.magic Eq\n\n  let m =\n    match eq with\n    | Eq ->\n        (module struct\n          exception Error = Js_error.Exn\n        end : T)\n\n  module Error = (val m : T)\nend\n\ninclude Magic.Error\n\nlet raise_js_error e = Js_error.raise_ (Js_error.of_error e)\n\nlet string_of_error e = Js_error.to_string (Js_error.of_error e)\n\nlet exn_with_js_backtrace = Js_error.attach_js_backtrace\n\nexternal js_error_of_exn : exn -> error t opt = \"caml_js_error_of_exception\"\n\nclass type json = object\n  method parse : js_string t -> 'a meth\n\n  method stringify : 'a -> js_string t meth\nend\n\nlet _JSON : json t = Unsafe.global##._JSON\n\nlet decodeURI (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.decodeURI [| Unsafe.inject s |]\n\nlet decodeURIComponent (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.decodeURIComponent [| Unsafe.inject s |]\n\nlet encodeURI (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.encodeURI [| Unsafe.inject s |]\n\nlet encodeURIComponent (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.encodeURIComponent [| Unsafe.inject s |]\n\nlet escape (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.escape [| Unsafe.inject s |]\n\nlet unescape (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.unescape [| Unsafe.inject s |]\n\nexternal bool : bool -> bool t = \"caml_js_from_bool\"\n\nexternal to_bool : bool t -> bool = \"caml_js_to_bool\"\n\nexternal array : 'a array -> 'a js_array t = \"caml_js_from_array\"\n\nexternal to_array : 'a js_array t -> 'a array = \"caml_js_to_array\"\n\nexternal bytestring : string -> js_string t = \"caml_jsbytes_of_string\"\n\nexternal to_bytestring : js_string t -> string = \"caml_string_of_jsbytes\"\n\nexternal float : float -> number_t = \"caml_js_from_float\"\n\nexternal to_float : number_t -> float = \"caml_js_to_float\"\n\nexternal number_of_float : float -> number t = \"caml_js_from_float\"\n\nexternal float_of_number : number t -> float = \"caml_js_to_float\"\n\nexternal int32 : int32 -> number_t = \"caml_js_from_int32\"\n\nexternal to_int32 : number_t -> int32 = \"caml_js_to_int32\"\n\nexternal nativeint : nativeint -> number_t = \"caml_js_from_nativeint\"\n\nexternal to_nativeint : number_t -> nativeint = \"caml_js_to_nativeint\"\n\nexternal typeof : _ t -> js_string t = \"caml_js_typeof\"\n\nexternal instanceof : _ t -> _ constr -> bool = \"caml_js_instanceof\"\n\nlet isNaN (i : 'a) : bool =\n  to_bool (Unsafe.fun_call Unsafe.global##.isNaN [| Unsafe.inject i |])\n\nlet parseInt (s : js_string t) : int =\n  let s = Unsafe.fun_call Unsafe.global##.parseInt [| Unsafe.inject s |] in\n  if isNaN s then failwith \"parseInt\" else s\n\nlet parseFloat (s : js_string t) : number_t =\n  let s = Unsafe.fun_call Unsafe.global##.parseFloat [| Unsafe.inject s |] in\n  if isNaN s then failwith \"parseFloat\" else s\n\nlet _ =\n  Printexc.register_printer (function\n      | Js_error.Exn e -> Some (Js_error.to_string e)\n      | _ -> None)\n\nlet _ =\n  Printexc.register_printer (fun e ->\n      let e : < .. > t = Obj.magic e in\n      if instanceof e array_constructor then None else Some (to_string e##toString))\n\nlet export_js (field : js_string t) x =\n  Unsafe.set\n    (Unsafe.pure_js_expr \"jsoo_exports\")\n    field\n    (if String.equal (Js.to_string (typeof (Obj.magic x))) \"function\"\n        (* function with arity/length equal to zero are already wrapped *)\n        && Unsafe.get (Obj.magic x) (Js.string \"length\") > 0\n     then Obj.magic (wrap_callback (Obj.magic x))\n     else x)\n\nlet export field x = export_js (string field) x\n\nlet export_all obj =\n  let keys = object_keys obj in\n  keys##forEach\n    (wrap_callback (fun (key : js_string t) _ _ -> export_js key (Unsafe.get obj key)))\n\n(****)\n\n(* DEPRECATED *)\n\ntype float_prop = number_t prop\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nexternal caml_js_on_ie : unit -> bool t = \"caml_js_on_ie\"\n\nlet onIE = Js.to_bool (caml_js_on_ie ())\n\nexternal html_escape : js_string t -> js_string t = \"caml_js_html_escape\"\n\nexternal decode_html_entities : js_string t -> js_string t = \"caml_js_html_entities\"\n\nclass type cssStyleDeclaration = object\n  method setProperty :\n    js_string t -> js_string t -> js_string t optdef -> js_string t meth\n\n  method getPropertyValue : js_string t -> js_string t meth\n\n  method getPropertyPriority : js_string t -> js_string t meth\n\n  method removeProperty : js_string t -> js_string t meth\n\n  method animation : js_string t prop\n\n  method animationDelay : js_string t prop\n\n  method animationDirection : js_string t prop\n\n  method animationDuration : js_string t prop\n\n  method animationFillMode : js_string t prop\n\n  method animationIterationCount : js_string t prop\n\n  method animationName : js_string t prop\n\n  method animationPlayState : js_string t prop\n\n  method animationTimingFunction : js_string t prop\n\n  method background : js_string t prop\n\n  method backgroundAttachment : js_string t prop\n\n  method backgroundColor : js_string t prop\n\n  method backgroundImage : js_string t prop\n\n  method backgroundPosition : js_string t prop\n\n  method backgroundRepeat : js_string t prop\n\n  method border : js_string t prop\n\n  method borderBottom : js_string t prop\n\n  method borderBottomColor : js_string t prop\n\n  method borderBottomStyle : js_string t prop\n\n  method borderBottomWidth : js_string t prop\n\n  method borderCollapse : js_string t prop\n\n  method borderColor : js_string t prop\n\n  method borderLeft : js_string t prop\n\n  method borderLeftColor : js_string t prop\n\n  method borderLeftStyle : js_string t prop\n\n  method borderLeftWidth : js_string t prop\n\n  method borderRadius : js_string t prop\n\n  method borderRight : js_string t prop\n\n  method borderRightColor : js_string t prop\n\n  method borderRightStyle : js_string t prop\n\n  method borderRightWidth : js_string t prop\n\n  method borderSpacing : js_string t prop\n\n  method borderStyle : js_string t prop\n\n  method borderTop : js_string t prop\n\n  method borderTopColor : js_string t prop\n\n  method borderTopStyle : js_string t prop\n\n  method borderTopWidth : js_string t prop\n\n  method borderWidth : js_string t prop\n\n  method bottom : js_string t prop\n\n  method captionSide : js_string t prop\n\n  method clear : js_string t prop\n\n  method clip : js_string t prop\n\n  method color : js_string t prop\n\n  method content : js_string t prop\n\n  method counterIncrement : js_string t prop\n\n  method counterReset : js_string t prop\n\n  method cssFloat : js_string t prop\n\n  method cssText : js_string t prop\n\n  method cursor : js_string t prop\n\n  method direction : js_string t prop\n\n  method display : js_string t prop\n\n  method emptyCells : js_string t prop\n\n  method fill : js_string t prop\n\n  method font : js_string t prop\n\n  method fontFamily : js_string t prop\n\n  method fontSize : js_string t prop\n\n  method fontStyle : js_string t prop\n\n  method fontVariant : js_string t prop\n\n  method fontWeight : js_string t prop\n\n  method height : js_string t prop\n\n  method left : js_string t prop\n\n  method letterSpacing : js_string t prop\n\n  method lineHeight : js_string t prop\n\n  method listStyle : js_string t prop\n\n  method listStyleImage : js_string t prop\n\n  method listStylePosition : js_string t prop\n\n  method listStyleType : js_string t prop\n\n  method margin : js_string t prop\n\n  method marginBottom : js_string t prop\n\n  method marginLeft : js_string t prop\n\n  method marginRight : js_string t prop\n\n  method marginTop : js_string t prop\n\n  method maxHeight : js_string t prop\n\n  method maxWidth : js_string t prop\n\n  method minHeight : js_string t prop\n\n  method minWidth : js_string t prop\n\n  method opacity : js_string t optdef prop\n\n  method outline : js_string t prop\n\n  method outlineColor : js_string t prop\n\n  method outlineOffset : js_string t prop\n\n  method outlineStyle : js_string t prop\n\n  method outlineWidth : js_string t prop\n\n  method overflow : js_string t prop\n\n  method overflowX : js_string t prop\n\n  method overflowY : js_string t prop\n\n  method padding : js_string t prop\n\n  method paddingBottom : js_string t prop\n\n  method paddingLeft : js_string t prop\n\n  method paddingRight : js_string t prop\n\n  method paddingTop : js_string t prop\n\n  method pageBreakAfter : js_string t prop\n\n  method pageBreakBefore : js_string t prop\n\n  method pointerEvents : js_string t prop\n\n  method position : js_string t prop\n\n  method right : js_string t prop\n\n  method stroke : js_string t prop\n\n  method strokeWidth : js_string t prop\n\n  method tableLayout : js_string t prop\n\n  method textAlign : js_string t prop\n\n  method textAnchor : js_string t prop\n\n  method textDecoration : js_string t prop\n\n  method textIndent : js_string t prop\n\n  method textTransform : js_string t prop\n\n  method top : js_string t prop\n\n  method transform : js_string t prop\n\n  method verticalAlign : js_string t prop\n\n  method visibility : js_string t prop\n\n  method whiteSpace : js_string t prop\n\n  method width : js_string t prop\n\n  method wordSpacing : js_string t prop\n\n  method zIndex : js_string t prop\nend\n\ntype ('a, 'b) event_listener = ('a, 'b) Dom.event_listener\n\ntype mouse_button =\n  | No_button\n  | Left_button\n  | Middle_button\n  | Right_button\n\ntype delta_mode =\n  | Delta_pixel\n  | Delta_line\n  | Delta_page\n\nclass type event = object\n  inherit [element] Dom.event\nend\n\nand ['a] customEvent = object\n  inherit [element, 'a] Dom.customEvent\nend\n\nand focusEvent = object\n  inherit event\n\n  method relatedTarget : element t opt optdef readonly_prop\nend\n\nand mouseEvent = object\n  inherit event\n\n  method relatedTarget : element t opt optdef readonly_prop\n\n  method clientX : int readonly_prop\n\n  method clientY : int readonly_prop\n\n  method screenX : int readonly_prop\n\n  method screenY : int readonly_prop\n\n  method offsetX : int readonly_prop\n\n  method offsetY : int readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method altKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method button : int readonly_prop\n\n  method which : mouse_button optdef readonly_prop\n\n  method fromElement : element t opt optdef readonly_prop\n\n  method toElement : element t opt optdef readonly_prop\n\n  method pageX : int optdef readonly_prop\n\n  method pageY : int optdef readonly_prop\nend\n\nand keyboardEvent = object\n  inherit event\n\n  method altKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method location : int readonly_prop\n\n  method key : js_string t optdef readonly_prop\n\n  method code : js_string t optdef readonly_prop\n\n  method which : int optdef readonly_prop\n\n  method charCode : int optdef readonly_prop\n\n  method keyCode : int readonly_prop\n\n  method getModifierState : js_string t -> bool t meth\n\n  method keyIdentifier : js_string t optdef readonly_prop\nend\n\nand mousewheelEvent = object\n  (* All modern browsers *)\n  inherit mouseEvent\n\n  method wheelDelta : int readonly_prop\n\n  method wheelDeltaX : int optdef readonly_prop\n\n  method wheelDeltaY : int optdef readonly_prop\n\n  method deltaX : number_t readonly_prop\n\n  method deltaY : number_t readonly_prop\n\n  method deltaZ : number_t readonly_prop\n\n  method deltaMode : delta_mode readonly_prop\nend\n\nand mouseScrollEvent = object\n  (* Firefox *)\n  inherit mouseEvent\n\n  method detail : int readonly_prop\n\n  method axis : int optdef readonly_prop\n\n  method _HORIZONTAL_AXIS : int optdef readonly_prop\n\n  method _VERTICAL_AXIS : int optdef readonly_prop\nend\n\nand touchEvent = object\n  inherit event\n\n  method touches : touchList t readonly_prop\n\n  method targetTouches : touchList t readonly_prop\n\n  method changedTouches : touchList t readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method altKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method relatedTarget : element t opt optdef readonly_prop\nend\n\nand touchList = object\n  method length : int readonly_prop\n\n  method item : int -> touch t optdef meth\nend\n\nand touch = object\n  method identifier : int readonly_prop\n\n  method target : element t optdef readonly_prop\n\n  method screenX : int readonly_prop\n\n  method screenY : int readonly_prop\n\n  method clientX : int readonly_prop\n\n  method clientY : int readonly_prop\n\n  method pageX : int readonly_prop\n\n  method pageY : int readonly_prop\nend\n\nand submitEvent = object\n  inherit event\n\n  method submitter : element t optdef readonly_prop\nend\n\nand dragEvent = object\n  inherit mouseEvent\n\n  method dataTransfer : dataTransfer t readonly_prop\nend\n\nand clipboardEvent = object\n  inherit event\n\n  method clipboardData : dataTransfer t readonly_prop\nend\n\nand dataTransfer = object\n  method dropEffect : js_string t prop\n\n  method effectAllowed : js_string t prop\n\n  method files : File.fileList t readonly_prop\n\n  method types : js_string t js_array t readonly_prop\n\n  method addElement : element t -> unit meth\n\n  method clearData : js_string t -> unit meth\n\n  method clearData_all : unit meth\n\n  method getData : js_string t -> js_string t meth\n\n  method setData : js_string t -> js_string t -> unit meth\n\n  method setDragImage : element t -> int -> int -> unit meth\nend\n\nand eventTarget = object ('self)\n  method onclick : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method ondblclick : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmousedown : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseup : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseover : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmousemove : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseout : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onkeypress : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onkeydown : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onkeyup : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onscroll : ('self t, event t) event_listener writeonly_prop\n\n  method onwheel : ('self t, mousewheelEvent t) event_listener writeonly_prop\n\n  method ondragstart : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragend : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragenter : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragover : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragleave : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondrag : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondrop : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method onanimationstart : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationend : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationiteration : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationcancel : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method ontransitionrun : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitionstart : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitionend : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitioncancel : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ongotpointercapture : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onlostpointercapture : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerenter : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointercancel : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerdown : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerleave : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointermove : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerout : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerover : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerup : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method dispatchEvent : event t -> bool t meth\nend\n\nand popStateEvent = object\n  inherit event\n\n  method state : Js.Unsafe.any readonly_prop\nend\n\nand pointerEvent = object\n  inherit mouseEvent\n\n  method pointerId : int Js.readonly_prop\n\n  method width : number_t Js.readonly_prop\n\n  method height : number_t Js.readonly_prop\n\n  method pressure : number_t Js.readonly_prop\n\n  method tangentialPressure : number_t Js.readonly_prop\n\n  method tiltX : int Js.readonly_prop\n\n  method tiltY : int Js.readonly_prop\n\n  method twist : int Js.readonly_prop\n\n  method pointerType : Js.js_string Js.t Js.readonly_prop\n\n  method isPrimary : bool Js.t Js.readonly_prop\nend\n\nand storageEvent = object\n  inherit event\n\n  method key : js_string t opt readonly_prop\n\n  method oldValue : js_string t opt readonly_prop\n\n  method newValue : js_string t opt readonly_prop\n\n  method url : js_string t readonly_prop\n\n  method storageArea : storage t opt readonly_prop\nend\n\nand storage = object\n  method length : int readonly_prop\n\n  method key : int -> js_string t opt meth\n\n  method getItem : js_string t -> js_string t opt meth\n\n  method setItem : js_string t -> js_string t -> unit meth\n\n  method removeItem : js_string t -> unit meth\n\n  method clear : unit meth\nend\n\nand hashChangeEvent = object\n  inherit event\n\n  method oldURL : js_string t readonly_prop\n\n  method newURL : js_string t readonly_prop\nend\n\nand animationEvent = object\n  inherit event\n\n  method animationName : js_string t readonly_prop\n\n  method elapsedTime : number_t readonly_prop\n\n  method pseudoElement : js_string t readonly_prop\nend\n\nand transitionEvent = object\n  inherit event\n\n  method propertyName : js_string t readonly_prop\n\n  method elapsedTime : number_t readonly_prop\n\n  method pseudoElement : js_string t readonly_prop\nend\n\nand mediaEvent = object\n  inherit event\nend\n\nand messageEvent = object\n  inherit event\n\n  method data : Unsafe.any opt readonly_prop\n\n  method source : Unsafe.any opt readonly_prop\nend\n\nand nodeSelector = object\n  method querySelector : js_string t -> element t opt meth\n\n  method querySelectorAll : js_string t -> element Dom.nodeList t meth\nend\n\nand tokenList = object\n  method length : int readonly_prop\n\n  method item : int -> js_string t optdef meth\n\n  method contains : js_string t -> bool t meth\n\n  method add : js_string t -> unit meth\n\n  method remove : js_string t -> unit meth\n\n  method toggle : js_string t -> bool t meth\n\n  method stringifier : js_string t prop\nend\n\nand element = object\n  inherit Dom.element\n\n  inherit nodeSelector\n\n  method id : js_string t prop\n\n  method title : js_string t prop\n\n  method lang : js_string t prop\n\n  method dir : js_string t prop\n\n  method className : js_string t prop\n\n  method classList : tokenList t readonly_prop\n\n  method closest : js_string t -> element t opt meth\n\n  method style : cssStyleDeclaration t prop\n\n  method innerHTML : js_string t prop\n\n  method outerHTML : js_string t prop\n\n  method textContent : js_string t opt prop\n\n  method innerText : js_string t prop\n\n  method clientLeft : int readonly_prop\n\n  method clientTop : int readonly_prop\n\n  method clientWidth : int readonly_prop\n\n  method clientHeight : int readonly_prop\n\n  method offsetLeft : int readonly_prop\n\n  method offsetTop : int readonly_prop\n\n  method offsetParent : element t opt readonly_prop\n\n  method offsetWidth : int readonly_prop\n\n  method offsetHeight : int readonly_prop\n\n  method scrollLeft : int prop\n\n  method scrollTop : int prop\n\n  method scrollWidth : int prop\n\n  method scrollHeight : int prop\n\n  method getClientRects : clientRectList t meth\n\n  method getBoundingClientRect : clientRect t meth\n\n  method scrollIntoView : bool t -> unit meth\n\n  method click : unit meth\n\n  method focus : unit meth\n\n  method blur : unit meth\n\n  inherit eventTarget\nend\n\nand clientRect = object\n  method top : number_t readonly_prop\n\n  method right : number_t readonly_prop\n\n  method bottom : number_t readonly_prop\n\n  method left : number_t readonly_prop\n\n  method width : number_t optdef readonly_prop\n\n  method height : number_t optdef readonly_prop\nend\n\nand clientRectList = object\n  method length : int readonly_prop\n\n  method item : int -> clientRect t opt meth\nend\n\nlet no_handler : ('a, 'b) event_listener = Dom.no_handler\n\nlet handler = Dom.handler\n\nlet full_handler = Dom.full_handler\n\nlet invoke_handler = Dom.invoke_handler\n\nmodule Event = struct\n  type 'a typ = 'a Dom.Event.typ\n\n  let click = Dom.Event.make \"click\"\n\n  let copy = Dom.Event.make \"copy\"\n\n  let cut = Dom.Event.make \"cut\"\n\n  let paste = Dom.Event.make \"paste\"\n\n  let dblclick = Dom.Event.make \"dblclick\"\n\n  let mousedown = Dom.Event.make \"mousedown\"\n\n  let mouseup = Dom.Event.make \"mouseup\"\n\n  let mouseover = Dom.Event.make \"mouseover\"\n\n  let mousemove = Dom.Event.make \"mousemove\"\n\n  let mouseout = Dom.Event.make \"mouseout\"\n\n  let keypress = Dom.Event.make \"keypress\"\n\n  let keydown = Dom.Event.make \"keydown\"\n\n  let keyup = Dom.Event.make \"keyup\"\n\n  let mousewheel = Dom.Event.make \"mousewheel\"\n\n  let wheel = Dom.Event.make \"wheel\"\n\n  let _DOMMouseScroll = Dom.Event.make \"DOMMouseScroll\"\n\n  let touchstart = Dom.Event.make \"touchstart\"\n\n  let touchmove = Dom.Event.make \"touchmove\"\n\n  let touchend = Dom.Event.make \"touchend\"\n\n  let touchcancel = Dom.Event.make \"touchcancel\"\n\n  let dragstart = Dom.Event.make \"dragstart\"\n\n  let dragend = Dom.Event.make \"dragend\"\n\n  let dragenter = Dom.Event.make \"dragenter\"\n\n  let dragover = Dom.Event.make \"dragover\"\n\n  let dragleave = Dom.Event.make \"dragleave\"\n\n  let drag = Dom.Event.make \"drag\"\n\n  let drop = Dom.Event.make \"drop\"\n\n  let hashchange = Dom.Event.make \"hashchange\"\n\n  let change = Dom.Event.make \"change\"\n\n  let input = Dom.Event.make \"input\"\n\n  let timeupdate = Dom.Event.make \"timeupdate\"\n\n  let submit = Dom.Event.make \"submit\"\n\n  let scroll = Dom.Event.make \"scroll\"\n\n  let focus = Dom.Event.make \"focus\"\n\n  let blur = Dom.Event.make \"blur\"\n\n  let load = Dom.Event.make \"load\"\n\n  let unload = Dom.Event.make \"unload\"\n\n  let beforeunload = Dom.Event.make \"beforeunload\"\n\n  let resize = Dom.Event.make \"resize\"\n\n  let orientationchange = Dom.Event.make \"orientationchange\"\n\n  let popstate = Dom.Event.make \"popstate\"\n\n  let error = Dom.Event.make \"error\"\n\n  let abort = Dom.Event.make \"abort\"\n\n  let select = Dom.Event.make \"select\"\n\n  let online = Dom.Event.make \"online\"\n\n  let offline = Dom.Event.make \"offline\"\n\n  let checking = Dom.Event.make \"checking\"\n\n  let noupdate = Dom.Event.make \"noupdate\"\n\n  let downloading = Dom.Event.make \"downloading\"\n\n  let progress = Dom.Event.make \"progress\"\n\n  let updateready = Dom.Event.make \"updateready\"\n\n  let cached = Dom.Event.make \"cached\"\n\n  let obsolete = Dom.Event.make \"obsolete\"\n\n  let domContentLoaded = Dom.Event.make \"DOMContentLoaded\"\n\n  let animationstart = Dom.Event.make \"animationstart\"\n\n  let animationend = Dom.Event.make \"animationend\"\n\n  let animationiteration = Dom.Event.make \"animationiteration\"\n\n  let animationcancel = Dom.Event.make \"animationcancel\"\n\n  let transitionrun = Dom.Event.make \"transitionrun\"\n\n  let transitionstart = Dom.Event.make \"transitionstart\"\n\n  let transitionend = Dom.Event.make \"transitionend\"\n\n  let transitioncancel = Dom.Event.make \"transitioncancel\"\n\n  let canplay = Dom.Event.make \"canplay\"\n\n  let canplaythrough = Dom.Event.make \"canplaythrough\"\n\n  let durationchange = Dom.Event.make \"durationchange\"\n\n  let emptied = Dom.Event.make \"emptied\"\n\n  let ended = Dom.Event.make \"ended\"\n\n  let gotpointercapture = Dom.Event.make \"gotpointercapture\"\n\n  let loadeddata = Dom.Event.make \"loadeddata\"\n\n  let loadedmetadata = Dom.Event.make \"loadedmetadata\"\n\n  let loadstart = Dom.Event.make \"loadstart\"\n\n  let lostpointercapture = Dom.Event.make \"lostpointercapture\"\n\n  let message = Dom.Event.make \"message\"\n\n  let pause = Dom.Event.make \"pause\"\n\n  let play = Dom.Event.make \"play\"\n\n  let playing = Dom.Event.make \"playing\"\n\n  let pointerenter = Dom.Event.make \"pointerenter\"\n\n  let pointercancel = Dom.Event.make \"pointercancel\"\n\n  let pointerdown = Dom.Event.make \"pointerdown\"\n\n  let pointerleave = Dom.Event.make \"pointerleave\"\n\n  let pointermove = Dom.Event.make \"pointermove\"\n\n  let pointerout = Dom.Event.make \"pointerout\"\n\n  let pointerover = Dom.Event.make \"pointerover\"\n\n  let pointerup = Dom.Event.make \"pointerup\"\n\n  let ratechange = Dom.Event.make \"ratechange\"\n\n  let seeked = Dom.Event.make \"seeked\"\n\n  let seeking = Dom.Event.make \"seeking\"\n\n  let stalled = Dom.Event.make \"stalled\"\n\n  let suspend = Dom.Event.make \"suspend\"\n\n  let volumechange = Dom.Event.make \"volumechange\"\n\n  let waiting = Dom.Event.make \"waiting\"\n\n  let make = Dom.Event.make\nend\n\ntype event_listener_id = Dom.event_listener_id\n\nlet addEventListener = Dom.addEventListener\n\nlet addEventListenerWithOptions = Dom.addEventListenerWithOptions\n\nlet removeEventListener = Dom.removeEventListener\n\nlet createCustomEvent = Dom.createCustomEvent\n\nclass type ['node] collection = object\n  method length : int readonly_prop\n\n  method item : int -> 'node t opt meth\n\n  method namedItem : js_string t -> 'node t opt meth\nend\n\nclass type htmlElement = element\n\nclass type headElement = object\n  inherit element\n\n  method profile : js_string t prop\nend\n\nclass type linkElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method charset : js_string t prop\n\n  method crossorigin : js_string t prop\n\n  method href : js_string t prop\n\n  method hreflang : js_string t prop\n\n  method media : js_string t prop\n\n  method rel : js_string t prop\n\n  method rev : js_string t prop\n\n  method target : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type titleElement = object\n  inherit element\n\n  method text : js_string t prop\nend\n\nclass type metaElement = object\n  inherit element\n\n  method content : js_string t prop\n\n  method httpEquiv : js_string t prop\n\n  method name : js_string t prop\n\n  method scheme : js_string t prop\nend\n\nclass type baseElement = object\n  inherit element\n\n  method href : js_string t prop\n\n  method target : js_string t prop\nend\n\nclass type styleElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method media : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type bodyElement = element\n\nclass type formElement = object\n  inherit element\n\n  method elements : element collection t readonly_prop\n\n  method length : int readonly_prop\n\n  method acceptCharset : js_string t prop\n\n  method action : js_string t prop\n\n  method enctype : js_string t prop\n\n  method _method : js_string t prop\n\n  method target : js_string t prop\n\n  method submit : unit meth\n\n  method reset : unit meth\n\n  method onsubmit : ('self t, submitEvent t) event_listener writeonly_prop\nend\n\nclass type optGroupElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method label : js_string t prop\nend\n\nclass type optionElement = object\n  inherit optGroupElement\n\n  method form : formElement t opt readonly_prop\n\n  method defaultSelected : bool t prop\n\n  method text : js_string t readonly_prop\n\n  method index : int readonly_prop\n\n  method selected : bool t prop\n\n  method value : js_string t prop\nend\n\nclass type selectElement = object ('self)\n  inherit element\n\n  method _type : js_string t readonly_prop\n\n  method selectedIndex : int prop\n\n  method value : js_string t prop\n\n  method length : int prop\n\n  method form : formElement t opt readonly_prop\n\n  method options : optionElement collection t readonly_prop\n\n  method disabled : bool t prop\n\n  method multiple : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method size : int prop\n\n  method tabIndex : int prop\n\n  method add : #optGroupElement t -> #optGroupElement t opt -> unit meth\n\n  method remove : int -> unit meth\n\n  method required : bool t writeonly_prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\nend\n\nclass type inputElement = object ('self)\n  inherit element\n\n  method defaultValue : js_string t prop\n\n  method defaultChecked : js_string t prop\n\n  method form : formElement t opt readonly_prop\n\n  method accept : js_string t prop\n\n  method accessKey : js_string t prop\n\n  method align : js_string t prop\n\n  method alt : js_string t prop\n\n  method checked : bool t prop\n\n  method disabled : bool t prop\n\n  method maxLength : int prop\n\n  method name : js_string t readonly_prop\n\n  method readOnly : bool t prop\n\n  method required : bool t writeonly_prop\n\n  method size : int prop\n\n  method src : js_string t prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method useMap : js_string t prop\n\n  method value : js_string t prop\n\n  method select : unit meth\n\n  method files : File.fileList t optdef readonly_prop\n\n  method placeholder : js_string t writeonly_prop\n\n  method selectionDirection : js_string t prop\n\n  method selectionStart : int prop\n\n  method selectionEnd : int prop\n\n  method onselect : ('self t, event t) event_listener prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\n\n  method onblur : ('self t, focusEvent t) event_listener prop\n\n  method onfocus : ('self t, focusEvent t) event_listener prop\nend\n\nclass type textAreaElement = object ('self)\n  inherit element\n\n  method defaultValue : js_string t prop\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method cols : int prop\n\n  method disabled : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method readOnly : bool t prop\n\n  method rows : int prop\n\n  method selectionDirection : js_string t prop\n\n  method selectionEnd : int prop\n\n  method selectionStart : int prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method value : js_string t prop\n\n  method select : unit meth\n\n  method required : bool t writeonly_prop\n\n  method placeholder : js_string t writeonly_prop\n\n  method onselect : ('self t, event t) event_listener prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\n\n  method onblur : ('self t, focusEvent t) event_listener prop\n\n  method onfocus : ('self t, focusEvent t) event_listener prop\nend\n\nclass type buttonElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method disabled : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method value : js_string t prop\nend\n\nclass type labelElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method htmlFor : js_string t prop\nend\n\nclass type fieldSetElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\nend\n\nclass type legendElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\nend\n\nclass type uListElement = element\n\nclass type oListElement = element\n\nclass type dListElement = element\n\nclass type liElement = element\n\nclass type divElement = element\n\nclass type paragraphElement = element\n\nclass type headingElement = element\n\nclass type quoteElement = object\n  inherit element\n\n  method cite : js_string t prop\nend\n\nclass type preElement = element\n\nclass type brElement = element\n\nclass type hrElement = element\n\nclass type modElement = object\n  inherit element\n\n  method cite : js_string t prop\n\n  method dateTime : js_string t prop\nend\n\nclass type anchorElement = object\n  inherit element\n\n  method accessKey : js_string t prop\n\n  method charset : js_string t prop\n\n  method coords : js_string t prop\n\n  method download : js_string t prop\n\n  method href : js_string t prop\n\n  method hreflang : js_string t prop\n\n  method name : js_string t prop\n\n  method rel : js_string t prop\n\n  method rev : js_string t prop\n\n  method shape : js_string t prop\n\n  method tabIndex : int prop\n\n  method target : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type imageElement = object ('self)\n  inherit element\n\n  method alt : js_string t prop\n\n  method src : js_string t prop\n\n  method useMap : js_string t prop\n\n  method isMap : bool t prop\n\n  method width : int prop\n\n  method height : int prop\n\n  method naturalWidth : int optdef readonly_prop\n\n  method naturalHeight : int optdef readonly_prop\n\n  method complete : bool t prop\n\n  method onload : ('self t, event t) event_listener prop\n\n  method onerror : ('self t, event t) event_listener prop\n\n  method onabort : ('self t, event t) event_listener prop\nend\n\nclass type objectElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method code : js_string t prop\n\n  method archive : js_string t prop\n\n  method codeBase : js_string t prop\n\n  method codeType : js_string t prop\n\n  method data : js_string t prop\n\n  method declare : bool t prop\n\n  method height : js_string t prop\n\n  method name : js_string t prop\n\n  method standby : js_string t prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t prop\n\n  method useMap : js_string t prop\n\n  method width : js_string t prop\n\n  method document : Dom.element Dom.document t opt readonly_prop\nend\n\nclass type paramElement = object\n  inherit element\n\n  method name : js_string t prop\n\n  method _type : js_string t prop\n\n  method value : js_string t prop\n\n  method valueType : js_string t prop\nend\n\nclass type areaElement = object\n  inherit element\n\n  method accessKey : js_string t prop\n\n  method alt : js_string t prop\n\n  method coords : js_string t prop\n\n  method href : js_string t prop\n\n  method noHref : bool t prop\n\n  method shape : js_string t prop\n\n  method tabIndex : int prop\n\n  method target : js_string t prop\nend\n\nclass type mapElement = object\n  inherit element\n\n  method areas : areaElement collection t readonly_prop\n\n  method name : js_string t prop\nend\n\nclass type scriptElement = object\n  inherit element\n\n  method text : js_string t prop\n\n  method charset : js_string t prop\n\n  method defer : bool t prop\n\n  method src : js_string t prop\n\n  method _type : js_string t prop\n\n  method async : bool t prop\nend\n\nclass type embedElement = object\n  inherit element\n\n  method src : js_string t prop\n\n  method height : js_string t prop\n\n  method width : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type tableCellElement = object\n  inherit element\n\n  method cellIndex : int readonly_prop\n\n  method abbr : js_string t prop\n\n  method align : js_string t prop\n\n  method axis : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method colSpan : int prop\n\n  method headers : js_string t prop\n\n  method rowSpan : int prop\n\n  method scope : js_string t prop\n\n  method vAlign : js_string t prop\nend\n\nclass type tableRowElement = object\n  inherit element\n\n  method rowIndex : int readonly_prop\n\n  method sectionRowIndex : int readonly_prop\n\n  method cells : tableCellElement collection t readonly_prop\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method vAlign : js_string t prop\n\n  method insertCell : int -> tableCellElement t meth\n\n  method deleteCell : int -> unit meth\nend\n\nclass type tableColElement = object\n  inherit element\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method span : int prop\n\n  method vAlign : js_string t prop\n\n  method width : js_string t prop\nend\n\nclass type tableSectionElement = object\n  inherit element\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method vAlign : js_string t prop\n\n  method rows : tableRowElement collection t readonly_prop\n\n  method insertRow : int -> tableRowElement t meth\n\n  method deleteRow : int -> unit meth\nend\n\nclass type tableCaptionElement = element\n\nclass type tableElement = object\n  inherit element\n\n  method caption : tableCaptionElement t prop\n\n  method tHead : tableSectionElement t prop\n\n  method tFoot : tableSectionElement t prop\n\n  method rows : tableRowElement collection t readonly_prop\n\n  method tBodies : tableSectionElement collection t readonly_prop\n\n  method align : js_string t prop\n\n  method border : js_string t prop\n\n  method cellPadding : js_string t prop\n\n  method cellSpacing : js_string t prop\n\n  method frame : js_string t prop\n\n  method rules : js_string t prop\n\n  method summary : js_string t prop\n\n  method width : js_string t prop\n\n  method createTHead : tableSectionElement t meth\n\n  method deleteTHead : unit meth\n\n  method createTFoot : tableSectionElement t meth\n\n  method deleteTFoot : unit meth\n\n  method createCaption : tableCaptionElement t meth\n\n  method deleteCaption : unit meth\n\n  method insertRow : int -> tableRowElement t meth\n\n  method deleteRow : int -> unit meth\nend\n\nclass type timeRanges = object\n  method length : int readonly_prop\n\n  method start : int -> number_t meth\n\n  method end_ : int -> number_t meth\nend\n\ntype networkState =\n  | NETWORK_EMPTY\n  | NETWORK_IDLE\n  | NETWORK_LOADING\n  | NETWORK_NO_SOURCE\n\ntype readyState =\n  | HAVE_NOTHING\n  | HAVE_METADATA\n  | HAVE_CURRENT_DATA\n  | HAVE_FUTURE_DATA\n  | HAVE_ENOUGH_DATA\n\n(* http://www.w3schools.com/tags/ref_av_dom.asp *)\n(* only features supported by all browser. (IE9+) *)\nclass type mediaElement = object\n  inherit element\n\n  method canPlayType : js_string t -> js_string t meth\n\n  method load : unit meth\n\n  method play : unit meth\n\n  method pause : unit meth\n\n  method autoplay : bool t prop\n\n  method buffered : timeRanges t readonly_prop\n\n  method controls : bool t prop\n\n  method currentSrc : js_string t readonly_prop\n\n  method currentTime : number_t prop\n\n  method duration : number_t readonly_prop\n\n  method ended : bool t readonly_prop\n\n  method loop : bool t prop\n\n  method mediagroup : js_string t prop\n\n  method muted : bool t prop\n\n  method networkState_int : int readonly_prop\n\n  method networkState : networkState readonly_prop\n\n  method paused : bool t readonly_prop\n\n  method playbackRate : number_t prop\n\n  method played : timeRanges t readonly_prop\n\n  method preload : js_string t prop\n\n  method readyState_int : int readonly_prop\n\n  method readyState : readyState readonly_prop\n\n  method seekable : timeRanges t readonly_prop\n\n  method seeking : bool t readonly_prop\n\n  method src : js_string t prop\n\n  method volume : number_t prop\n\n  method oncanplay : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method oncanplaythrough : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method ondurationchange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onemptied : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onended : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadeddata : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadedmetadata : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadstart : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onpause : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onplay : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onplaying : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onratechange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onseeked : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onseeking : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onstalled : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onsuspend : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onvolumechange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onwaiting : ('self t, mediaEvent t) event_listener writeonly_prop\nend\n\nclass type audioElement = object\n  inherit mediaElement\nend\n\nclass type videoElement = object\n  inherit mediaElement\nend\n\ntype context = js_string t\n\nlet _2d_ = Js.string \"2d\"\n\ntype canvasPattern\n\nclass type canvasElement = object\n  inherit element\n\n  method width : int prop\n\n  method height : int prop\n\n  method toDataURL : js_string t meth\n\n  method toDataURL_type : js_string t -> js_string t meth\n\n  method toDataURL_type_compression : js_string t -> number_t -> js_string t meth\n\n  method getContext : js_string t -> canvasRenderingContext2D t meth\nend\n\nand canvasRenderingContext2D = object\n  method canvas : canvasElement t readonly_prop\n\n  method save : unit meth\n\n  method restore : unit meth\n\n  method scale : number_t -> number_t -> unit meth\n\n  method rotate : number_t -> unit meth\n\n  method translate : number_t -> number_t -> unit meth\n\n  method transform :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method setTransform :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method globalAlpha : number_t prop\n\n  method globalCompositeOperation : js_string t prop\n\n  method strokeStyle : js_string t writeonly_prop\n\n  method strokeStyle_gradient : canvasGradient t writeonly_prop\n\n  method strokeStyle_pattern : canvasPattern t writeonly_prop\n\n  method fillStyle : js_string t writeonly_prop\n\n  method fillStyle_gradient : canvasGradient t writeonly_prop\n\n  method fillStyle_pattern : canvasPattern t writeonly_prop\n\n  method createLinearGradient :\n    number_t -> number_t -> number_t -> number_t -> canvasGradient t meth\n\n  method createRadialGradient :\n       number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> canvasGradient t meth\n\n  method createPattern : imageElement t -> js_string t -> canvasPattern t meth\n\n  method createPattern_fromCanvas : canvasElement t -> js_string t -> canvasPattern t meth\n\n  method createPattern_fromVideo : videoElement t -> js_string t -> canvasPattern t meth\n\n  method lineWidth : number_t prop\n\n  method lineCap : js_string t prop\n\n  method lineJoin : js_string t prop\n\n  method miterLimit : number_t prop\n\n  method shadowOffsetX : number_t prop\n\n  method shadowOffsetY : number_t prop\n\n  method shadowBlur : number_t prop\n\n  method shadowColor : js_string t prop\n\n  method clearRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method fillRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method strokeRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method beginPath : unit meth\n\n  method closePath : unit meth\n\n  method moveTo : number_t -> number_t -> unit meth\n\n  method lineTo : number_t -> number_t -> unit meth\n\n  method quadraticCurveTo : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method bezierCurveTo :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method arcTo : number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method rect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method arc :\n    number_t -> number_t -> number_t -> number_t -> number_t -> bool t -> unit meth\n\n  method fill : unit meth\n\n  method stroke : unit meth\n\n  method clip : unit meth\n\n  method isPointInPath : number_t -> number_t -> bool t meth\n\n  method drawFocusRing : #element t -> number_t -> number_t -> bool t -> bool t meth\n\n  method font : js_string t prop\n\n  method textAlign : js_string t prop\n\n  method textBaseline : js_string t prop\n\n  method fillText : js_string t -> number_t -> number_t -> unit meth\n\n  method fillText_withWidth : js_string t -> number_t -> number_t -> number_t -> unit meth\n\n  method strokeText : js_string t -> number_t -> number_t -> unit meth\n\n  method strokeText_withWidth :\n    js_string t -> number_t -> number_t -> number_t -> unit meth\n\n  method measureText : js_string t -> textMetrics t meth\n\n  method drawImage : imageElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_withSize :\n    imageElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_full :\n       imageElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method drawImage_fromCanvas : canvasElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_fromCanvasWithSize :\n    canvasElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_fullFromCanvas :\n       canvasElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method drawImage_fromVideoWithVideo :\n    videoElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_fromVideoWithSize :\n    videoElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_fullFromVideo :\n       videoElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method createImageData : int -> int -> imageData t meth\n\n  method getImageData : number_t -> number_t -> number_t -> number_t -> imageData t meth\n\n  method putImageData : imageData t -> number_t -> number_t -> unit meth\nend\n\nand canvasGradient = object\n  method addColorStop : number_t -> js_string t -> unit meth\nend\n\nand textMetrics = object\n  method width : number_t readonly_prop\nend\n\nand imageData = object\n  method width : int readonly_prop\n\n  method height : int readonly_prop\n\n  method data : canvasPixelArray t readonly_prop\nend\n\nand canvasPixelArray = object\n  method length : int readonly_prop\nend\n\nexternal pixel_get : canvasPixelArray t -> int -> int = \"caml_js_get\"\n\nexternal pixel_set : canvasPixelArray t -> int -> int -> unit = \"caml_js_set\"\n\nclass type range = object\n  method collapsed : bool t readonly_prop\n\n  method startOffset : int readonly_prop\n\n  method endOffset : int readonly_prop\n\n  method startContainer : Dom.node t readonly_prop\n\n  method endContainer : Dom.node t readonly_prop\n\n  method setStart : Dom.node t -> int -> unit meth\n\n  method setEnd : Dom.node t -> int -> unit meth\n\n  method setStartBefore : Dom.node t -> unit meth\n\n  method setEndBefore : Dom.node t -> unit meth\n\n  method setStartAfter : Dom.node t -> unit meth\n\n  method setEndAfter : Dom.node t -> unit meth\n\n  method selectNode : Dom.node t -> unit meth\n\n  method selectNodeContents : Dom.node t -> unit meth\n\n  method collapse : bool t -> unit meth\n\n  method cloneContents : Dom.documentFragment t meth\n\n  method extractContents : Dom.documentFragment t meth\n\n  method deleteContents : unit meth\n\n  method insertNode : Dom.node t -> unit meth\n\n  method surroundContents : Dom.node t -> unit meth\n\n  method cloneRange : range t meth\n\n  method toString : js_string t meth\nend\n\n(** Information on current selection *)\nclass type selection = object\n  method anchorNode : Dom.node t readonly_prop\n\n  method anchorOffset : int readonly_prop\n\n  method focusNode : Dom.node t readonly_prop\n\n  method focusOffset : int readonly_prop\n\n  method isCollapsed : bool t readonly_prop\n\n  method rangeCount : int readonly_prop\n\n  method getRangeAt : int -> range t meth\n\n  method collapse : bool t -> unit meth\n\n  method extend : Dom.node t -> int -> unit meth\n\n  method modify : js_string t -> js_string t -> js_string t -> unit meth\n\n  method collapseToStart : unit meth\n\n  method collapseToEnd : unit meth\n\n  method selectAllChildren : Dom.node t -> unit meth\n\n  method addRange : range t -> unit meth\n\n  method removeRange : range t -> unit meth\n\n  method removeAllRanges : unit meth\n\n  method deleteFromDocument : unit meth\n\n  method containsNode : Dom.node t -> bool t -> bool t meth\n\n  method toString : js_string t meth\nend\n\nclass type document = object\n  inherit [element] Dom.document\n\n  inherit nodeSelector\n\n  inherit eventTarget\n\n  method title : js_string t prop\n\n  method referrer : js_string t readonly_prop\n\n  method domain : js_string t prop\n\n  method _URL : js_string t readonly_prop\n\n  method head : headElement t prop\n\n  method body : bodyElement t prop\n\n  method documentElement : htmlElement t readonly_prop\n\n  method images : imageElement collection t readonly_prop\n\n  method applets : element collection t readonly_prop\n\n  method links : element collection t readonly_prop\n\n  method forms : formElement collection t readonly_prop\n\n  method anchors : element collection t readonly_prop\n\n  method cookie : js_string t prop\n\n  method designMode : js_string t prop\n\n  method open_ : unit meth\n\n  method close : unit meth\n\n  method write : js_string t -> unit meth\n\n  method execCommand : js_string t -> bool t -> js_string t opt -> unit meth\n\n  method createRange : range t meth\n\n  method readyState : js_string t readonly_prop\n\n  method getElementsByClassName : js_string t -> element Dom.nodeList t meth\n\n  method getElementsByName : js_string t -> element Dom.nodeList t meth\n\n  method activeElement : element t opt readonly_prop\n\n  method hidden : bool t readonly_prop\n\n  method onfullscreenchange : (document t, event t) event_listener writeonly_prop\n\n  method onwebkitfullscreenchange : (document t, event t) event_listener writeonly_prop\n\n  inherit eventTarget\nend\n\ntype interval_id\n\ntype timeout_id\n\ntype animation_frame_request_id\n\nclass type location = object\n  method href : js_string t prop\n\n  method protocol : js_string t prop\n\n  method host : js_string t prop\n\n  method hostname : js_string t prop\n\n  method origin : js_string t optdef readonly_prop\n\n  method port : js_string t prop\n\n  method pathname : js_string t prop\n\n  method search : js_string t prop\n\n  method hash : js_string t prop\n\n  method assign : js_string t -> unit meth\n\n  method replace : js_string t -> unit meth\n\n  method reload : unit meth\nend\n\nlet location_origin (loc : location t) =\n  Optdef.case\n    loc##.origin\n    (fun () ->\n      let protocol = loc##.protocol in\n      let hostname = loc##.hostname in\n      let port = loc##.port in\n      if protocol##.length = 0 && hostname##.length = 0\n      then Js.string \"\"\n      else\n        let origin = protocol##concat_2 (Js.string \"//\") hostname in\n        if port##.length > 0 then origin##concat_2 (Js.string \":\") loc##.port else origin)\n    (fun o -> o)\n\nclass type history = object\n  method length : int readonly_prop\n\n  method state : Js.Unsafe.any readonly_prop\n\n  method go : int opt -> unit meth\n\n  method back : unit meth\n\n  method forward : unit meth\n\n  method pushState : 'a. 'a -> js_string t -> js_string t opt -> unit meth\n\n  method replaceState : 'a. 'a -> js_string t -> js_string t opt -> unit meth\nend\n\nclass type undoManager = object end\n\nclass type navigator = object\n  method appCodeName : js_string t readonly_prop\n\n  method appName : js_string t readonly_prop\n\n  method appVersion : js_string t readonly_prop\n\n  method cookieEnabled : bool t readonly_prop\n\n  method onLine : bool t readonly_prop\n\n  method platform : js_string t readonly_prop\n\n  method vendor : js_string t readonly_prop\n\n  method userAgent : js_string t readonly_prop\n\n  method language : js_string t optdef readonly_prop\n\n  method userLanguage : js_string t optdef readonly_prop\n\n  method maxTouchPoints : int readonly_prop\nend\n\nclass type screen = object\n  method width : int readonly_prop\n\n  method height : int readonly_prop\n\n  method availWidth : int readonly_prop\n\n  method availHeight : int readonly_prop\nend\n\nclass type applicationCache = object\n  method status : int readonly_prop\n\n  method update : unit meth\n\n  method abort : unit meth\n\n  method swapCache : unit meth\n\n  method onchecking : (applicationCache t, event t) event_listener prop\n\n  method onerror : (applicationCache t, event t) event_listener prop\n\n  method onnoupdate : (applicationCache t, event t) event_listener prop\n\n  method ondownloading : (applicationCache t, event t) event_listener prop\n\n  method onprogress : (applicationCache t, event t) event_listener prop\n\n  method onupdateready : (applicationCache t, event t) event_listener prop\n\n  method oncached : (applicationCache t, event t) event_listener prop\n\n  method onobsolete : (applicationCache t, event t) event_listener prop\n\n  inherit eventTarget\nend\n\nclass type _URL = object\n  method createObjectURL : #File.blob t -> js_string t meth\n\n  method revokeObjectURL : js_string t -> unit meth\nend\n\nclass type window = object\n  inherit eventTarget\n\n  method document : document t readonly_prop\n\n  method applicationCache : applicationCache t readonly_prop\n\n  method name : js_string t prop\n\n  method location : location t readonly_prop\n\n  method history : history t readonly_prop\n\n  method undoManager : undoManager t readonly_prop\n\n  method navigator : navigator t readonly_prop\n\n  method getSelection : selection t meth\n\n  method close : unit meth\n\n  method closed : bool t readonly_prop\n\n  method stop : unit meth\n\n  method focus : unit meth\n\n  method blur : unit meth\n\n  method scroll : int -> int -> unit meth\n\n  method scrollBy : int -> int -> unit meth\n\n  method sessionStorage : storage t optdef readonly_prop\n\n  method localStorage : storage t optdef readonly_prop\n\n  method top : window t readonly_prop\n\n  method parent : window t readonly_prop\n\n  method frameElement : element t opt readonly_prop\n\n  method open_ : js_string t -> js_string t -> js_string t opt -> window t opt meth\n\n  method alert : js_string t -> unit meth\n\n  method confirm : js_string t -> bool t meth\n\n  method prompt : js_string t -> js_string t -> js_string t opt meth\n\n  method print : unit meth\n\n  method setInterval : (unit -> unit) Js.callback -> number_t -> interval_id meth\n\n  method clearInterval : interval_id -> unit meth\n\n  method setTimeout : (unit -> unit) Js.callback -> number_t -> timeout_id meth\n\n  method clearTimeout : timeout_id -> unit meth\n\n  method requestAnimationFrame :\n    (number_t -> unit) Js.callback -> animation_frame_request_id meth\n\n  method cancelAnimationFrame : animation_frame_request_id -> unit meth\n\n  method screen : screen t readonly_prop\n\n  method innerWidth : int readonly_prop\n\n  method innerHeight : int readonly_prop\n\n  method outerWidth : int readonly_prop\n\n  method outerHeight : int readonly_prop\n\n  method getComputedStyle : #element t -> cssStyleDeclaration t meth\n\n  method getComputedStyle_pseudoElt :\n    #element t -> js_string t -> cssStyleDeclaration t meth\n\n  method atob : js_string t -> js_string t meth\n\n  method btoa : js_string t -> js_string t meth\n\n  method onload : (window t, event t) event_listener prop\n\n  method onunload : (window t, event t) event_listener prop\n\n  method onbeforeunload : (window t, event t) event_listener prop\n\n  method onblur : (window t, focusEvent t) event_listener prop\n\n  method onfocus : (window t, focusEvent t) event_listener prop\n\n  method onresize : (window t, event t) event_listener prop\n\n  method onorientationchange : (window t, event t) event_listener prop\n\n  method onpopstate : (window t, popStateEvent t) event_listener prop\n\n  method onhashchange : (window t, hashChangeEvent t) event_listener prop\n\n  method ononline : (window t, event t) event_listener writeonly_prop\n\n  method onoffline : (window t, event t) event_listener writeonly_prop\n\n  method _URL : _URL t readonly_prop\n\n  method devicePixelRatio : number_t readonly_prop\nend\n\nlet window : window t = Js.Unsafe.global\n\n(* The toplevel object *)\n\nlet document = window##.document\n\nlet getElementById id =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> raise Not_found)\n    (fun pnode -> pnode)\n\nlet getElementById_exn id =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> failwith (Printf.sprintf \"getElementById_exn: %S not found\" id))\n    (fun pnode -> pnode)\n\nlet getElementById_opt id = Js.Opt.to_option (document##getElementById (Js.string id))\n\nlet getElementById_coerce id coerce =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> None)\n    (fun e -> Js.Opt.to_option (coerce e))\n\n(****)\n\nclass type frameSetElement = object\n  inherit element\n\n  method cols : js_string t prop\n\n  method rows : js_string t prop\nend\n\nclass type frameElement = object\n  inherit element\n\n  method frameBorder : js_string t prop\n\n  method longDesc : js_string t prop\n\n  method marginHeight : js_string t prop\n\n  method marginWidth : js_string t prop\n\n  method name : js_string t prop\n\n  method noResize : bool t prop\n\n  method scrolling : js_string t prop\n\n  method src : js_string t prop\n\n  method contentDocument : document t opt readonly_prop\nend\n\nclass type iFrameElement = object\n  inherit element\n\n  method frameBorder : js_string t prop\n\n  method height : js_string t prop\n\n  method width : js_string t prop\n\n  method longDesc : js_string t prop\n\n  method marginHeight : js_string t prop\n\n  method marginWidth : js_string t prop\n\n  method name : js_string t prop\n\n  method scrolling : js_string t prop\n\n  method src : js_string t prop\n\n  method contentDocument : document t opt readonly_prop\n\n  method contentWindow : window t readonly_prop\nend\n\n(****)\n\n(*XXX Should provide creation functions a la lablgtk... *)\n\nlet opt_iter x f =\n  match x with\n  | None -> ()\n  | Some v -> f v\n\nlet createElement (doc : document t) name = doc##createElement (Js.string name)\n\nlet unsafeCreateElement doc name = Js.Unsafe.coerce (createElement doc name)\n\nlet createElementSyntax = ref `Unknown\n\nlet rec unsafeCreateElementEx ?_type ?name doc elt =\n  if Poly.(_type = None) && Poly.(name = None)\n  then Js.Unsafe.coerce (createElement doc elt)\n  else\n    match !createElementSyntax with\n    | `Standard ->\n        let res = Js.Unsafe.coerce (createElement doc elt) in\n        opt_iter _type (fun t -> res##._type := t);\n        opt_iter name (fun n -> res##.name := n);\n        res\n    | `Extended ->\n        let a = new%js Js.array_empty in\n        ignore (a##push_2 (Js.string \"<\") (Js.string elt));\n        opt_iter _type (fun t ->\n            ignore (a##push_3 (Js.string \" type=\\\"\") (html_escape t) (Js.string \"\\\"\")));\n        opt_iter name (fun n ->\n            ignore (a##push_3 (Js.string \" name=\\\"\") (html_escape n) (Js.string \"\\\"\")));\n        ignore (a##push (Js.string \">\"));\n        Js.Unsafe.coerce (doc##createElement (a##join (Js.string \"\")))\n    | `Unknown ->\n        createElementSyntax :=\n          if try\n               let el : inputElement Js.t =\n                 Js.Unsafe.coerce\n                   (document##createElement (Js.string \"<input name=\\\"x\\\">\"))\n               in\n               Js.equals el##.tagName##toLowerCase (Js.string \"input\")\n               && Js.equals el##.name (Js.string \"x\")\n             with _ -> false\n          then `Extended\n          else `Standard;\n        unsafeCreateElementEx ?_type ?name doc elt\n\nlet createHtml doc : htmlElement t = unsafeCreateElement doc \"html\"\n\nlet createHead doc : headElement t = unsafeCreateElement doc \"head\"\n\nlet createLink doc : linkElement t = unsafeCreateElement doc \"link\"\n\nlet createTitle doc : titleElement t = unsafeCreateElement doc \"title\"\n\nlet createMeta doc : metaElement t = unsafeCreateElement doc \"meta\"\n\nlet createBase doc : baseElement t = unsafeCreateElement doc \"base\"\n\nlet createStyle doc : styleElement t = unsafeCreateElement doc \"style\"\n\nlet createBody doc : bodyElement t = unsafeCreateElement doc \"body\"\n\nlet createForm doc : formElement t = unsafeCreateElement doc \"form\"\n\nlet createOptgroup doc : optGroupElement t = unsafeCreateElement doc \"optgroup\"\n\nlet createOption doc : optionElement t = unsafeCreateElement doc \"option\"\n\nlet createSelect ?_type ?name doc : selectElement t =\n  unsafeCreateElementEx ?_type ?name doc \"select\"\n\nlet createInput ?_type ?name doc : inputElement t =\n  unsafeCreateElementEx ?_type ?name doc \"input\"\n\nlet createTextarea ?_type ?name doc : textAreaElement t =\n  unsafeCreateElementEx ?_type ?name doc \"textarea\"\n\nlet createButton ?_type ?name doc : buttonElement t =\n  unsafeCreateElementEx ?_type ?name doc \"button\"\n\nlet createLabel doc : labelElement t = unsafeCreateElement doc \"label\"\n\nlet createFieldset doc : fieldSetElement t = unsafeCreateElement doc \"fieldset\"\n\nlet createLegend doc : legendElement t = unsafeCreateElement doc \"legend\"\n\nlet createUl doc : uListElement t = unsafeCreateElement doc \"ul\"\n\nlet createOl doc : oListElement t = unsafeCreateElement doc \"ol\"\n\nlet createDl doc : dListElement t = unsafeCreateElement doc \"dl\"\n\nlet createLi doc : liElement t = unsafeCreateElement doc \"li\"\n\nlet createDiv doc : divElement t = unsafeCreateElement doc \"div\"\n\nlet createEmbed doc : embedElement t = unsafeCreateElement doc \"embed\"\n\nlet createP doc : paragraphElement t = unsafeCreateElement doc \"p\"\n\nlet createH1 doc : headingElement t = unsafeCreateElement doc \"h1\"\n\nlet createH2 doc : headingElement t = unsafeCreateElement doc \"h2\"\n\nlet createH3 doc : headingElement t = unsafeCreateElement doc \"h3\"\n\nlet createH4 doc : headingElement t = unsafeCreateElement doc \"h4\"\n\nlet createH5 doc : headingElement t = unsafeCreateElement doc \"h5\"\n\nlet createH6 doc : headingElement t = unsafeCreateElement doc \"h6\"\n\nlet createQ doc : quoteElement t = unsafeCreateElement doc \"q\"\n\nlet createBlockquote doc : quoteElement t = unsafeCreateElement doc \"blockquote\"\n\nlet createPre doc : preElement t = unsafeCreateElement doc \"pre\"\n\nlet createBr doc : brElement t = unsafeCreateElement doc \"br\"\n\nlet createHr doc : hrElement t = unsafeCreateElement doc \"hr\"\n\nlet createIns doc : modElement t = unsafeCreateElement doc \"ins\"\n\nlet createDel doc : modElement t = unsafeCreateElement doc \"del\"\n\nlet createA doc : anchorElement t = unsafeCreateElement doc \"a\"\n\nlet createImg doc : imageElement t = unsafeCreateElement doc \"img\"\n\nlet createObject doc : objectElement t = unsafeCreateElement doc \"object\"\n\nlet createParam doc : paramElement t = unsafeCreateElement doc \"param\"\n\nlet createMap doc : mapElement t = unsafeCreateElement doc \"map\"\n\nlet createArea doc : areaElement t = unsafeCreateElement doc \"area\"\n\nlet createScript doc : scriptElement t = unsafeCreateElement doc \"script\"\n\nlet createTable doc : tableElement t = unsafeCreateElement doc \"table\"\n\nlet createCaption doc : tableCaptionElement t = unsafeCreateElement doc \"caption\"\n\nlet createCol doc : tableColElement t = unsafeCreateElement doc \"col\"\n\nlet createColgroup doc : tableColElement t = unsafeCreateElement doc \"colgroup\"\n\nlet createThead doc : tableSectionElement t = unsafeCreateElement doc \"thead\"\n\nlet createTfoot doc : tableSectionElement t = unsafeCreateElement doc \"tfoot\"\n\nlet createTbody doc : tableSectionElement t = unsafeCreateElement doc \"tbody\"\n\nlet createTr doc : tableRowElement t = unsafeCreateElement doc \"tr\"\n\nlet createTh doc : tableCellElement t = unsafeCreateElement doc \"th\"\n\nlet createTd doc : tableCellElement t = unsafeCreateElement doc \"td\"\n\nlet createSub doc = createElement doc \"sub\"\n\nlet createSup doc = createElement doc \"sup\"\n\nlet createSpan doc = createElement doc \"span\"\n\nlet createTt doc = createElement doc \"tt\"\n\nlet createI doc = createElement doc \"i\"\n\nlet createB doc = createElement doc \"b\"\n\nlet createBig doc = createElement doc \"big\"\n\nlet createSmall doc = createElement doc \"small\"\n\nlet createEm doc = createElement doc \"em\"\n\nlet createStrong doc = createElement doc \"strong\"\n\nlet createCite doc = createElement doc \"cite\"\n\nlet createDfn doc = createElement doc \"dfn\"\n\nlet createCode doc = createElement doc \"code\"\n\nlet createSamp doc = createElement doc \"samp\"\n\nlet createKbd doc = createElement doc \"kbd\"\n\nlet createVar doc = createElement doc \"var\"\n\nlet createAbbr doc = createElement doc \"abbr\"\n\nlet createDd doc = createElement doc \"dd\"\n\nlet createDt doc = createElement doc \"dt\"\n\nlet createNoscript doc = createElement doc \"noscript\"\n\nlet createAddress doc = createElement doc \"address\"\n\nlet createFrameset doc : frameSetElement t = unsafeCreateElement doc \"frameset\"\n\nlet createFrame doc : frameElement t = unsafeCreateElement doc \"frame\"\n\nlet createIframe doc : iFrameElement t = unsafeCreateElement doc \"iframe\"\n\nlet createAudio doc : audioElement t = unsafeCreateElement doc \"audio\"\n\nlet createVideo doc : audioElement t = unsafeCreateElement doc \"video\"\n\nexception Canvas_not_available\n\nlet createCanvas doc : canvasElement t =\n  let c = unsafeCreateElement doc \"canvas\" in\n  if not (Opt.test c##.getContext) then raise Canvas_not_available;\n  c\n\nlet html_element : htmlElement t constr = Js.Unsafe.global##._HTMLElement\n\nmodule CoerceTo = struct\n  let element : #Dom.node Js.t -> element Js.t Js.opt =\n    if not (Js.Optdef.test (def html_element))\n    then\n      (* ie < 9 does not have HTMLElement: we have to cheat to check\n         that something is an html element *)\n      fun e ->\n      if not (Js.Optdef.test (def (Js.Unsafe.coerce e)##.innerHTML))\n      then Js.null\n      else Js.some (Js.Unsafe.coerce e)\n    else\n      fun e ->\n      if Js.instanceof e html_element then Js.some (Js.Unsafe.coerce e) else Js.null\n\n  let unsafeCoerce tag (e : #element t) =\n    if Js.equals e##.tagName##toLowerCase (Js.string tag)\n    then Js.some (Js.Unsafe.coerce e)\n    else Js.null\n\n  let a e = unsafeCoerce \"a\" e\n\n  let area e = unsafeCoerce \"area\" e\n\n  let base e = unsafeCoerce \"base\" e\n\n  let blockquote e = unsafeCoerce \"blockquote\" e\n\n  let body e = unsafeCoerce \"body\" e\n\n  let br e = unsafeCoerce \"br\" e\n\n  let button e = unsafeCoerce \"button\" e\n\n  let canvas e = unsafeCoerce \"canvas\" e\n\n  let caption e = unsafeCoerce \"caption\" e\n\n  let col e = unsafeCoerce \"col\" e\n\n  let colgroup e = unsafeCoerce \"colgroup\" e\n\n  let del e = unsafeCoerce \"del\" e\n\n  let div e = unsafeCoerce \"div\" e\n\n  let dl e = unsafeCoerce \"dl\" e\n\n  let fieldset e = unsafeCoerce \"fieldset\" e\n\n  let embed e = unsafeCoerce \"embed\" e\n\n  let form e = unsafeCoerce \"form\" e\n\n  let frameset e = unsafeCoerce \"frameset\" e\n\n  let frame e = unsafeCoerce \"frame\" e\n\n  let h1 e = unsafeCoerce \"h1\" e\n\n  let h2 e = unsafeCoerce \"h2\" e\n\n  let h3 e = unsafeCoerce \"h3\" e\n\n  let h4 e = unsafeCoerce \"h4\" e\n\n  let h5 e = unsafeCoerce \"h5\" e\n\n  let h6 e = unsafeCoerce \"h6\" e\n\n  let head e = unsafeCoerce \"head\" e\n\n  let hr e = unsafeCoerce \"hr\" e\n\n  let html e = unsafeCoerce \"html\" e\n\n  let iframe e = unsafeCoerce \"iframe\" e\n\n  let img e = unsafeCoerce \"img\" e\n\n  let input e = unsafeCoerce \"input\" e\n\n  let ins e = unsafeCoerce \"ins\" e\n\n  let label e = unsafeCoerce \"label\" e\n\n  let legend e = unsafeCoerce \"legend\" e\n\n  let li e = unsafeCoerce \"li\" e\n\n  let link e = unsafeCoerce \"link\" e\n\n  let map e = unsafeCoerce \"map\" e\n\n  let meta e = unsafeCoerce \"meta\" e\n\n  let _object e = unsafeCoerce \"object\" e\n\n  let ol e = unsafeCoerce \"ol\" e\n\n  let optgroup e = unsafeCoerce \"optgroup\" e\n\n  let option e = unsafeCoerce \"option\" e\n\n  let p e = unsafeCoerce \"p\" e\n\n  let param e = unsafeCoerce \"param\" e\n\n  let pre e = unsafeCoerce \"pre\" e\n\n  let q e = unsafeCoerce \"q\" e\n\n  let script e = unsafeCoerce \"script\" e\n\n  let select e = unsafeCoerce \"select\" e\n\n  let style e = unsafeCoerce \"style\" e\n\n  let table e = unsafeCoerce \"table\" e\n\n  let tbody e = unsafeCoerce \"tbody\" e\n\n  let td e = unsafeCoerce \"td\" e\n\n  let textarea e = unsafeCoerce \"textarea\" e\n\n  let tfoot e = unsafeCoerce \"tfoot\" e\n\n  let th e = unsafeCoerce \"th\" e\n\n  let thead e = unsafeCoerce \"thead\" e\n\n  let title e = unsafeCoerce \"title\" e\n\n  let tr e = unsafeCoerce \"tr\" e\n\n  let ul e = unsafeCoerce \"ul\" e\n\n  let audio e = unsafeCoerce \"audio\" e\n\n  let video e = unsafeCoerce \"video\" e\n\n  let unsafeCoerceEvent constr (ev : #event t) =\n    if Js.Optdef.test (def constr) && Js.instanceof ev constr\n    then Js.some (Js.Unsafe.coerce ev)\n    else Js.null\n\n  let mouseEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MouseEvent ev\n\n  let keyboardEvent ev = unsafeCoerceEvent Js.Unsafe.global##._KeyboardEvent ev\n\n  let wheelEvent ev = unsafeCoerceEvent Js.Unsafe.global##._WheelEvent ev\n\n  let mouseScrollEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MouseScrollEvent ev\n\n  let popStateEvent ev = unsafeCoerceEvent Js.Unsafe.global##._PopStateEvent ev\n\n  let messageEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MessageEvent ev\nend\n\n(****)\n\nlet eventTarget = Dom.eventTarget\n\nlet eventRelatedTarget (e : #mouseEvent t) =\n  Optdef.get e##.relatedTarget (fun () ->\n      match Js.to_string e##._type with\n      | \"mouseover\" -> Optdef.get e##.fromElement (fun () -> assert false)\n      | \"mouseout\" -> Optdef.get e##.toElement (fun () -> assert false)\n      | _ -> Js.null)\n\nlet eventAbsolutePosition' (e : #mouseEvent t) =\n  let body = document##.body in\n  let html = document##.documentElement in\n  ( e##.clientX + body##.scrollLeft + html##.scrollLeft\n  , e##.clientY + body##.scrollTop + html##.scrollTop )\n\nlet eventAbsolutePosition (e : #mouseEvent t) =\n  Optdef.case\n    e##.pageX\n    (fun () -> eventAbsolutePosition' e)\n    (fun x -> Optdef.case e##.pageY (fun () -> eventAbsolutePosition' e) (fun y -> x, y))\n\nlet elementClientPosition (e : #element t) =\n  let r = e##getBoundingClientRect in\n  let body = document##.body in\n  let html = document##.documentElement in\n  ( truncate (Js.to_float r##.left) - body##.clientLeft - html##.clientLeft\n  , truncate (Js.to_float r##.top) - body##.clientTop - html##.clientTop )\n\nlet getDocumentScroll () =\n  let body = document##.body in\n  let html = document##.documentElement in\n  body##.scrollLeft + html##.scrollLeft, body##.scrollTop + html##.scrollTop\n\nlet buttonPressed (ev : #mouseEvent Js.t) =\n  Js.Optdef.case\n    ev##.which\n    (fun () ->\n      match ev##.button with\n      | 1 -> Left_button\n      | 2 -> Right_button\n      | 4 -> Middle_button\n      | _ -> No_button)\n    (fun x -> x)\n\nlet addMousewheelEventListenerWithOptions e ?capture ?once ?passive h =\n  addEventListenerWithOptions\n    ?capture\n    ?once\n    ?passive\n    e\n    Event.wheel\n    (handler (fun (e : mousewheelEvent t) ->\n         let dx = -Optdef.get e##.wheelDeltaX (fun () -> 0) / 40 in\n         let dy = -Optdef.get e##.wheelDeltaY (fun () -> e##.wheelDelta) / 40 in\n         h (e :> mouseEvent t) ~dx ~dy))\n\nlet addMousewheelEventListener e h capt =\n  addMousewheelEventListenerWithOptions ~capture:capt e h\n\n(*****)\n\nmodule Keyboard_code = struct\n  type t =\n    | Unidentified\n    (* Alphabetic Characters *)\n    | KeyA\n    | KeyB\n    | KeyC\n    | KeyD\n    | KeyE\n    | KeyF\n    | KeyG\n    | KeyH\n    | KeyI\n    | KeyJ\n    | KeyK\n    | KeyL\n    | KeyM\n    | KeyN\n    | KeyO\n    | KeyP\n    | KeyQ\n    | KeyR\n    | KeyS\n    | KeyT\n    | KeyU\n    | KeyV\n    | KeyW\n    | KeyX\n    | KeyY\n    | KeyZ\n    (* Digits *)\n    | Digit0\n    | Digit1\n    | Digit2\n    | Digit3\n    | Digit4\n    | Digit5\n    | Digit6\n    | Digit7\n    | Digit8\n    | Digit9\n    | Minus\n    | Equal\n    (* Whitespace *)\n    | Tab\n    | Enter\n    | Space\n    (* Editing *)\n    | Escape\n    | Backspace\n    | Insert\n    | Delete\n    | CapsLock\n    (* Misc Printable *)\n    | BracketLeft\n    | BracketRight\n    | Semicolon\n    | Quote\n    | Backquote\n    | Backslash\n    | Comma\n    | Period\n    | Slash\n    (* Function keys *)\n    | F1\n    | F2\n    | F3\n    | F4\n    | F5\n    | F6\n    | F7\n    | F8\n    | F9\n    | F10\n    | F11\n    | F12\n    (* Numpad keys *)\n    | Numpad0\n    | Numpad1\n    | Numpad2\n    | Numpad3\n    | Numpad4\n    | Numpad5\n    | Numpad6\n    | Numpad7\n    | Numpad8\n    | Numpad9\n    | NumpadMultiply\n    | NumpadSubtract\n    | NumpadAdd\n    | NumpadDecimal\n    | NumpadEqual\n    | NumpadEnter\n    | NumpadDivide\n    | NumLock\n    (* Modifier keys *)\n    | ControlLeft\n    | ControlRight\n    | MetaLeft\n    | MetaRight\n    | ShiftLeft\n    | ShiftRight\n    | AltLeft\n    | AltRight\n    (* Arrow keys *)\n    | ArrowLeft\n    | ArrowRight\n    | ArrowUp\n    | ArrowDown\n    (* Navigation *)\n    | PageUp\n    | PageDown\n    | Home\n    | End\n    (* Sound *)\n    | VolumeMute\n    | VolumeDown\n    | VolumeUp\n    (* Media *)\n    | MediaTrackPrevious\n    | MediaTrackNext\n    | MediaPlayPause\n    | MediaStop\n    (* Browser special *)\n    | ContextMenu\n    | BrowserSearch\n    | BrowserHome\n    | BrowserFavorites\n    | BrowserRefresh\n    | BrowserStop\n    | BrowserForward\n    | BrowserBack\n    (* Misc *)\n    | OSLeft\n    | OSRight\n    | ScrollLock\n    | PrintScreen\n    | IntlBackslash\n    | IntlYen\n    | Pause\n\n  let try_code v =\n    match Js.to_string v with\n    (* Alphabetic Characters *)\n    | \"KeyA\" -> KeyA\n    | \"KeyB\" -> KeyB\n    | \"KeyC\" -> KeyC\n    | \"KeyD\" -> KeyD\n    | \"KeyE\" -> KeyE\n    | \"KeyF\" -> KeyF\n    | \"KeyG\" -> KeyG\n    | \"KeyH\" -> KeyH\n    | \"KeyI\" -> KeyI\n    | \"KeyJ\" -> KeyJ\n    | \"KeyK\" -> KeyK\n    | \"KeyL\" -> KeyL\n    | \"KeyM\" -> KeyM\n    | \"KeyN\" -> KeyN\n    | \"KeyO\" -> KeyO\n    | \"KeyP\" -> KeyP\n    | \"KeyQ\" -> KeyQ\n    | \"KeyR\" -> KeyR\n    | \"KeyS\" -> KeyS\n    | \"KeyT\" -> KeyT\n    | \"KeyU\" -> KeyU\n    | \"KeyV\" -> KeyV\n    | \"KeyW\" -> KeyW\n    | \"KeyX\" -> KeyX\n    | \"KeyY\" -> KeyY\n    | \"KeyZ\" -> KeyZ\n    (* Digits *)\n    | \"Digit0\" -> Digit0\n    | \"Digit1\" -> Digit1\n    | \"Digit2\" -> Digit2\n    | \"Digit3\" -> Digit3\n    | \"Digit4\" -> Digit4\n    | \"Digit5\" -> Digit5\n    | \"Digit6\" -> Digit6\n    | \"Digit7\" -> Digit7\n    | \"Digit8\" -> Digit8\n    | \"Digit9\" -> Digit9\n    | \"Minus\" -> Minus\n    | \"Equal\" -> Equal\n    (* Whitespace *)\n    | \"Tab\" -> Tab\n    | \"Enter\" -> Enter\n    | \"Space\" -> Space\n    (* Editing *)\n    | \"Escape\" -> Escape\n    | \"Backspace\" -> Backspace\n    | \"Insert\" -> Insert\n    | \"Delete\" -> Delete\n    | \"CapsLock\" -> CapsLock\n    (* Misc Printable *)\n    | \"BracketLeft\" -> BracketLeft\n    | \"BracketRight\" -> BracketRight\n    | \"Semicolon\" -> Semicolon\n    | \"Quote\" -> Quote\n    | \"Backquote\" -> Backquote\n    | \"Backslash\" -> Backslash\n    | \"Comma\" -> Comma\n    | \"Period\" -> Period\n    | \"Slash\" -> Slash\n    (* Function keys *)\n    | \"F1\" -> F1\n    | \"F2\" -> F2\n    | \"F3\" -> F3\n    | \"F4\" -> F4\n    | \"F5\" -> F5\n    | \"F6\" -> F6\n    | \"F7\" -> F7\n    | \"F8\" -> F8\n    | \"F9\" -> F9\n    | \"F10\" -> F10\n    | \"F11\" -> F11\n    | \"F12\" -> F12\n    (* Numpad keys *)\n    | \"Numpad0\" -> Numpad0\n    | \"Numpad1\" -> Numpad1\n    | \"Numpad2\" -> Numpad2\n    | \"Numpad3\" -> Numpad3\n    | \"Numpad4\" -> Numpad4\n    | \"Numpad5\" -> Numpad5\n    | \"Numpad6\" -> Numpad6\n    | \"Numpad7\" -> Numpad7\n    | \"Numpad8\" -> Numpad8\n    | \"Numpad9\" -> Numpad9\n    | \"NumpadMultiply\" -> NumpadMultiply\n    | \"NumpadSubtract\" -> NumpadSubtract\n    | \"NumpadAdd\" -> NumpadAdd\n    | \"NumpadDecimal\" -> NumpadDecimal\n    | \"NumpadEqual\" -> NumpadEqual\n    | \"NumpadEnter\" -> NumpadEnter\n    | \"NumpadDivide\" -> NumpadDivide\n    | \"NumLock\" -> NumLock\n    (* Modifier keys *)\n    | \"ControlLeft\" -> ControlLeft\n    | \"ControlRight\" -> ControlRight\n    | \"MetaLeft\" -> MetaLeft\n    | \"MetaRight\" -> MetaRight\n    | \"ShiftLeft\" -> ShiftLeft\n    | \"ShiftRight\" -> ShiftRight\n    | \"AltLeft\" -> AltLeft\n    | \"AltRight\" -> AltRight\n    (* Arrow keys *)\n    | \"ArrowLeft\" -> ArrowLeft\n    | \"ArrowRight\" -> ArrowRight\n    | \"ArrowUp\" -> ArrowUp\n    | \"ArrowDown\" -> ArrowDown\n    (* Navigation *)\n    | \"PageUp\" -> PageUp\n    | \"PageDown\" -> PageDown\n    | \"Home\" -> Home\n    | \"End\" -> End\n    (* Sound *)\n    | \"VolumeMute\" -> VolumeMute\n    | \"VolumeDown\" -> VolumeDown\n    | \"VolumeUp\" -> VolumeUp\n    (* Media *)\n    | \"MediaTrackPrevious\" -> MediaTrackPrevious\n    | \"MediaTrackNext\" -> MediaTrackNext\n    | \"MediaPlayPause\" -> MediaPlayPause\n    | \"MediaStop\" -> MediaStop\n    (* Browser special *)\n    | \"ContextMenu\" -> ContextMenu\n    | \"BrowserSearch\" -> BrowserSearch\n    | \"BrowserHome\" -> BrowserHome\n    | \"BrowserFavorites\" -> BrowserFavorites\n    | \"BrowserRefresh\" -> BrowserRefresh\n    | \"BrowserStop\" -> BrowserStop\n    | \"BrowserForward\" -> BrowserForward\n    | \"BrowserBack\" -> BrowserBack\n    (* Misc *)\n    | \"OSLeft\" -> OSLeft\n    | \"OSRight\" -> OSRight\n    | \"ScrollLock\" -> ScrollLock\n    | \"PrintScreen\" -> PrintScreen\n    | \"IntlBackslash\" -> IntlBackslash\n    | \"IntlYen\" -> IntlYen\n    | \"Pause\" -> Pause\n    | _ -> Unidentified\n\n  let try_key_code_left = function\n    | 16 -> ShiftLeft\n    | 17 -> ControlLeft\n    | 18 -> AltLeft\n    | 91 -> MetaLeft\n    | _ -> Unidentified\n\n  let try_key_code_right = function\n    | 16 -> ShiftRight\n    | 17 -> ControlRight\n    | 18 -> AltRight\n    | 91 -> MetaRight\n    | _ -> Unidentified\n\n  let try_key_code_numpad = function\n    | 46 -> NumpadDecimal\n    | 45 -> Numpad0\n    | 35 -> Numpad1\n    | 40 -> Numpad2\n    | 34 -> Numpad3\n    | 37 -> Numpad4\n    | 12 -> Numpad5\n    | 39 -> Numpad6\n    | 36 -> Numpad7\n    | 38 -> Numpad8\n    | 33 -> Numpad9\n    | 13 -> NumpadEnter\n    | 111 -> NumpadDivide\n    | 107 -> NumpadAdd\n    | 109 -> NumpadSubtract\n    | 106 -> NumpadMultiply\n    | 110 -> NumpadDecimal\n    | 96 -> Numpad0\n    | 97 -> Numpad1\n    | 98 -> Numpad2\n    | 99 -> Numpad3\n    | 100 -> Numpad4\n    | 101 -> Numpad5\n    | 102 -> Numpad6\n    | 103 -> Numpad7\n    | 104 -> Numpad8\n    | 105 -> Numpad9\n    | _ -> Unidentified\n\n  let try_key_code_normal = function\n    | 27 -> Escape\n    | 112 -> F1\n    | 113 -> F2\n    | 114 -> F3\n    | 115 -> F4\n    | 116 -> F5\n    | 117 -> F6\n    | 118 -> F7\n    | 119 -> F8\n    | 120 -> F9\n    | 121 -> F10\n    | 122 -> F11\n    | 123 -> F12\n    | 42 -> PrintScreen\n    | 145 -> ScrollLock\n    | 19 -> Pause\n    | 192 -> Backquote\n    | 49 -> Digit1\n    | 50 -> Digit2\n    | 51 -> Digit3\n    | 52 -> Digit4\n    | 53 -> Digit5\n    | 54 -> Digit6\n    | 55 -> Digit7\n    | 56 -> Digit8\n    | 57 -> Digit9\n    | 48 -> Digit0\n    | 189 -> Minus\n    | 187 -> Equal\n    | 8 -> Backspace\n    | 9 -> Tab\n    | 81 -> KeyQ\n    | 87 -> KeyW\n    | 69 -> KeyE\n    | 82 -> KeyR\n    | 84 -> KeyT\n    | 89 -> KeyY\n    | 85 -> KeyU\n    | 73 -> KeyI\n    | 79 -> KeyO\n    | 80 -> KeyP\n    | 219 -> BracketLeft\n    | 221 -> BracketRight\n    | 220 -> Backslash\n    | 20 -> CapsLock\n    | 65 -> KeyA\n    | 83 -> KeyS\n    | 68 -> KeyD\n    | 70 -> KeyF\n    | 71 -> KeyG\n    | 72 -> KeyH\n    | 74 -> KeyJ\n    | 75 -> KeyK\n    | 76 -> KeyL\n    | 186 -> Semicolon\n    | 222 -> Quote\n    | 13 -> Enter\n    | 90 -> KeyZ\n    | 88 -> KeyX\n    | 67 -> KeyC\n    | 86 -> KeyV\n    | 66 -> KeyB\n    | 78 -> KeyN\n    | 77 -> KeyM\n    | 188 -> Comma\n    | 190 -> Period\n    | 191 -> Slash\n    | 32 -> Space\n    | 93 -> ContextMenu\n    | 45 -> Insert\n    | 36 -> Home\n    | 33 -> PageUp\n    | 46 -> Delete\n    | 35 -> End\n    | 34 -> PageDown\n    | 37 -> ArrowLeft\n    | 40 -> ArrowDown\n    | 39 -> ArrowRight\n    | 38 -> ArrowUp\n    | _ -> Unidentified\n\n  let make_unidentified _ = Unidentified\n\n  let try_next value f = function\n    | Unidentified -> Optdef.case value make_unidentified f\n    | v -> v\n\n  let run_next value f = function\n    | Unidentified -> f value\n    | v -> v\n\n  let get_key_code evt = evt##.keyCode\n\n  let try_key_location evt =\n    match evt##.location with\n    | 1 -> run_next (get_key_code evt) try_key_code_left\n    | 2 -> run_next (get_key_code evt) try_key_code_right\n    | 3 -> run_next (get_key_code evt) try_key_code_numpad\n    | _ -> make_unidentified\n\n  let ( |> ) x f = f x\n\n  let of_event evt =\n    Unidentified\n    |> try_next evt##.code try_code\n    |> try_key_location evt\n    |> run_next (get_key_code evt) try_key_code_normal\n\n  let of_key_code = try_key_code_normal\nend\n\nmodule Keyboard_key = struct\n  type t = Uchar.t option\n\n  let char_of_int value =\n    if 0 < value then try Some (Uchar.of_int value) with _ -> None else None\n\n  let empty_string _ = Js.string \"\"\n\n  let none _ = None\n\n  let of_event evt =\n    let key = Optdef.get evt##.key empty_string in\n    match key##.length with\n    | 0 -> Optdef.case evt##.charCode none char_of_int\n    | 1 -> char_of_int (int_of_float (Js.to_float (key##charCodeAt 0)))\n    | _ -> None\nend\n\n(*****)\n\nlet element : #Dom.element t -> element t = Js.Unsafe.coerce\n\ntype taggedElement =\n  | A of anchorElement t\n  | Area of areaElement t\n  | Audio of audioElement t\n  | Base of baseElement t\n  | Blockquote of quoteElement t\n  | Body of bodyElement t\n  | Br of brElement t\n  | Button of buttonElement t\n  | Canvas of canvasElement t\n  | Caption of tableCaptionElement t\n  | Col of tableColElement t\n  | Colgroup of tableColElement t\n  | Del of modElement t\n  | Div of divElement t\n  | Dl of dListElement t\n  | Embed of embedElement t\n  | Fieldset of fieldSetElement t\n  | Form of formElement t\n  | Frameset of frameSetElement t\n  | Frame of frameElement t\n  | H1 of headingElement t\n  | H2 of headingElement t\n  | H3 of headingElement t\n  | H4 of headingElement t\n  | H5 of headingElement t\n  | H6 of headingElement t\n  | Head of headElement t\n  | Hr of hrElement t\n  | Html of htmlElement t\n  | Iframe of iFrameElement t\n  | Img of imageElement t\n  | Input of inputElement t\n  | Ins of modElement t\n  | Label of labelElement t\n  | Legend of legendElement t\n  | Li of liElement t\n  | Link of linkElement t\n  | Map of mapElement t\n  | Meta of metaElement t\n  | Object of objectElement t\n  | Ol of oListElement t\n  | Optgroup of optGroupElement t\n  | Option of optionElement t\n  | P of paramElement t\n  | Param of paramElement t\n  | Pre of preElement t\n  | Q of quoteElement t\n  | Script of scriptElement t\n  | Select of selectElement t\n  | Style of styleElement t\n  | Table of tableElement t\n  | Tbody of tableSectionElement t\n  | Td of tableCellElement t\n  | Textarea of textAreaElement t\n  | Tfoot of tableSectionElement t\n  | Th of tableCellElement t\n  | Thead of tableSectionElement t\n  | Title of titleElement t\n  | Tr of tableRowElement t\n  | Ul of uListElement t\n  | Video of videoElement t\n  | Other of element t\n\nlet other e = Other (e : #element t :> element t)\n\nlet tagged (e : #element t) =\n  let tag = Js.to_bytestring e##.tagName##toLowerCase in\n  if String.length tag = 0\n  then other e\n  else\n    match String.unsafe_get tag 0 with\n    | 'a' -> (\n        match tag with\n        | \"a\" -> A (Js.Unsafe.coerce e)\n        | \"area\" -> Area (Js.Unsafe.coerce e)\n        | \"audio\" -> Audio (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'b' -> (\n        match tag with\n        | \"base\" -> Base (Js.Unsafe.coerce e)\n        | \"blockquote\" -> Blockquote (Js.Unsafe.coerce e)\n        | \"body\" -> Body (Js.Unsafe.coerce e)\n        | \"br\" -> Br (Js.Unsafe.coerce e)\n        | \"button\" -> Button (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'c' -> (\n        match tag with\n        | \"canvas\" -> Canvas (Js.Unsafe.coerce e)\n        | \"caption\" -> Caption (Js.Unsafe.coerce e)\n        | \"col\" -> Col (Js.Unsafe.coerce e)\n        | \"colgroup\" -> Colgroup (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'd' -> (\n        match tag with\n        | \"del\" -> Del (Js.Unsafe.coerce e)\n        | \"div\" -> Div (Js.Unsafe.coerce e)\n        | \"dl\" -> Dl (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'e' -> (\n        match tag with\n        | \"embed\" -> Embed (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'f' -> (\n        match tag with\n        | \"fieldset\" -> Fieldset (Js.Unsafe.coerce e)\n        | \"form\" -> Form (Js.Unsafe.coerce e)\n        | \"frameset\" -> Frameset (Js.Unsafe.coerce e)\n        | \"frame\" -> Frame (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'h' -> (\n        match tag with\n        | \"h1\" -> H1 (Js.Unsafe.coerce e)\n        | \"h2\" -> H2 (Js.Unsafe.coerce e)\n        | \"h3\" -> H3 (Js.Unsafe.coerce e)\n        | \"h4\" -> H4 (Js.Unsafe.coerce e)\n        | \"h5\" -> H5 (Js.Unsafe.coerce e)\n        | \"h6\" -> H6 (Js.Unsafe.coerce e)\n        | \"head\" -> Head (Js.Unsafe.coerce e)\n        | \"hr\" -> Hr (Js.Unsafe.coerce e)\n        | \"html\" -> Html (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'i' -> (\n        match tag with\n        | \"iframe\" -> Iframe (Js.Unsafe.coerce e)\n        | \"img\" -> Img (Js.Unsafe.coerce e)\n        | \"input\" -> Input (Js.Unsafe.coerce e)\n        | \"ins\" -> Ins (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'l' -> (\n        match tag with\n        | \"label\" -> Label (Js.Unsafe.coerce e)\n        | \"legend\" -> Legend (Js.Unsafe.coerce e)\n        | \"li\" -> Li (Js.Unsafe.coerce e)\n        | \"link\" -> Link (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'm' -> (\n        match tag with\n        | \"map\" -> Map (Js.Unsafe.coerce e)\n        | \"meta\" -> Meta (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'o' -> (\n        match tag with\n        | \"object\" -> Object (Js.Unsafe.coerce e)\n        | \"ol\" -> Ol (Js.Unsafe.coerce e)\n        | \"optgroup\" -> Optgroup (Js.Unsafe.coerce e)\n        | \"option\" -> Option (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'p' -> (\n        match tag with\n        | \"p\" -> P (Js.Unsafe.coerce e)\n        | \"param\" -> Param (Js.Unsafe.coerce e)\n        | \"pre\" -> Pre (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'q' -> (\n        match tag with\n        | \"q\" -> Q (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 's' -> (\n        match tag with\n        | \"script\" -> Script (Js.Unsafe.coerce e)\n        | \"select\" -> Select (Js.Unsafe.coerce e)\n        | \"style\" -> Style (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 't' -> (\n        match tag with\n        | \"table\" -> Table (Js.Unsafe.coerce e)\n        | \"tbody\" -> Tbody (Js.Unsafe.coerce e)\n        | \"td\" -> Td (Js.Unsafe.coerce e)\n        | \"textarea\" -> Textarea (Js.Unsafe.coerce e)\n        | \"tfoot\" -> Tfoot (Js.Unsafe.coerce e)\n        | \"th\" -> Th (Js.Unsafe.coerce e)\n        | \"thead\" -> Thead (Js.Unsafe.coerce e)\n        | \"title\" -> Title (Js.Unsafe.coerce e)\n        | \"tr\" -> Tr (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'u' -> (\n        match tag with\n        | \"ul\" -> Ul (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'v' -> (\n        match tag with\n        | \"video\" -> Video (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | _ -> other e\n\nlet opt_tagged e = Opt.case e (fun () -> None) (fun e -> Some (tagged e))\n\ntype taggedEvent =\n  | MouseEvent of mouseEvent t\n  | KeyboardEvent of keyboardEvent t\n  | MessageEvent of messageEvent t\n  | MousewheelEvent of mousewheelEvent t\n  | MouseScrollEvent of mouseScrollEvent t\n  | PopStateEvent of popStateEvent t\n  | OtherEvent of event t\n\nlet taggedEvent (ev : #event Js.t) =\n  Js.Opt.case\n    (CoerceTo.mouseEvent ev)\n    (fun () ->\n      Js.Opt.case\n        (CoerceTo.keyboardEvent ev)\n        (fun () ->\n          Js.Opt.case\n            (CoerceTo.wheelEvent ev)\n            (fun () ->\n              Js.Opt.case\n                (CoerceTo.mouseScrollEvent ev)\n                (fun () ->\n                  Js.Opt.case\n                    (CoerceTo.popStateEvent ev)\n                    (fun () ->\n                      Js.Opt.case\n                        (CoerceTo.messageEvent ev)\n                        (fun () -> OtherEvent (ev :> event t))\n                        (fun ev -> MessageEvent ev))\n                    (fun ev -> PopStateEvent ev))\n                (fun ev -> MouseScrollEvent ev))\n            (fun ev -> MousewheelEvent ev))\n        (fun ev -> KeyboardEvent ev))\n    (fun ev -> MouseEvent ev)\n\nlet opt_taggedEvent ev = Opt.case ev (fun () -> None) (fun ev -> Some (taggedEvent ev))\n\nlet stopPropagation ev =\n  let e = Js.Unsafe.coerce ev in\n  Optdef.case\n    e##.stopPropagation\n    (fun () -> e##.cancelBubble := Js._true)\n    (fun _ -> e##_stopPropagation)\n\nlet _requestAnimationFrame : (unit -> unit) Js.callback -> unit =\n  Js.Unsafe.pure_expr (fun _ ->\n      let w = Js.Unsafe.coerce window in\n      let l =\n        [ w##.requestAnimationFrame\n        ; w##.mozRequestAnimationFrame\n        ; w##.webkitRequestAnimationFrame\n        ; w##.oRequestAnimationFrame\n        ; w##.msRequestAnimationFrame\n        ]\n      in\n      try\n        let req = List.find (fun c -> Js.Optdef.test c) l in\n        fun callback -> Js.Unsafe.fun_call req [| Js.Unsafe.inject callback |]\n      with Not_found ->\n        let now () = Js.to_float (new%js Js.date_now)##getTime in\n        let last = ref (now ()) in\n        fun callback ->\n          let t = now () in\n          let dt = !last +. (1000. /. 60.) -. t in\n          let dt = if Poly.(dt < 0.) then 0. else dt in\n          last := t;\n          ignore (window##setTimeout callback (Js.float dt)))\n\n(****)\n\nlet hasPushState () = Js.Optdef.test (Js.Unsafe.coerce window##.history)##.pushState\n\nlet hasPlaceholder () =\n  let i = createInput document in\n  Js.Optdef.test (Js.Unsafe.coerce i)##.placeholder\n\nlet hasRequired () =\n  let i = createInput document in\n  Js.Optdef.test (Js.Unsafe.coerce i)##.required\n\nlet overflow_limit = 2147483_000.\n\n(* ms *)\n\ntype timeout_id_safe = timeout_id option ref\n\nlet setTimeout callback d : timeout_id_safe =\n  let id = ref None in\n  let rec loop d () =\n    let step, remain =\n      if Poly.(d > overflow_limit) then overflow_limit, d -. overflow_limit else d, 0.\n    in\n    let cb = if Poly.(remain = 0.) then callback else loop remain in\n    id := Some (window##setTimeout (Js.wrap_callback cb) (Js.float step))\n  in\n  loop d ();\n  id\n\nlet clearTimeout (id : timeout_id_safe) =\n  match !id with\n  | None -> ()\n  | Some x ->\n      id := None;\n      window##clearTimeout x\n\nlet js_array_of_collection (c : #element collection Js.t) : #element Js.t Js.js_array Js.t\n    =\n  Js.Unsafe.(meth_call (js_expr \"[].slice\") \"call\" [| inject c |])\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nclass type ['node] nodeList = object\n  method item : int -> 'node t opt meth\n\n  method length : int readonly_prop\nend\n\nlet list_of_nodeList (nodeList : 'a nodeList t) =\n  let length = nodeList##.length in\n  let rec add_item acc i =\n    if i < length\n    then\n      match Opt.to_option (nodeList##item i) with\n      | None -> add_item acc (i + 1)\n      | Some e -> add_item (e :: acc) (i + 1)\n    else List.rev acc\n  in\n  add_item [] 0\n\ntype nodeType =\n  | OTHER\n  (* Will not happen *)\n  | ELEMENT\n  | ATTRIBUTE\n  | TEXT\n  | CDATA_SECTION\n  | ENTITY_REFERENCE\n  | ENTITY\n  | PROCESSING_INSTRUCTION\n  | COMMENT\n  | DOCUMENT\n  | DOCUMENT_TYPE\n  | DOCUMENT_FRAGMENT\n  | NOTATION\n\nmodule DocumentPosition = struct\n  type t = int\n\n  type mask = int\n\n  let disconnected = 0x01\n\n  let preceding = 0x02\n\n  let following = 0x04\n\n  let contains = 0x08\n\n  let contained_by = 0x10\n\n  let implementation_specific = 0x20\n\n  let has t mask = t land mask = mask\n\n  let add x y = x lor y\n\n  let ( + ) = add\nend\n\nclass type node = object\n  method nodeName : js_string t readonly_prop\n\n  method nodeValue : js_string t opt readonly_prop\n\n  method nodeType : nodeType readonly_prop\n\n  method parentNode : node t opt prop\n\n  method childNodes : node nodeList t prop\n\n  method firstChild : node t opt prop\n\n  method lastChild : node t opt prop\n\n  method previousSibling : node t opt prop\n\n  method nextSibling : node t opt prop\n\n  method namespaceURI : js_string t opt prop\n\n  method insertBefore : node t -> node t opt -> node t meth\n\n  method replaceChild : node t -> node t -> node t meth\n\n  method removeChild : node t -> node t meth\n\n  method appendChild : node t -> node t meth\n\n  method hasChildNodes : bool t meth\n\n  method cloneNode : bool t -> node t meth\n\n  method compareDocumentPosition : node t -> DocumentPosition.t meth\n\n  method lookupNamespaceURI : js_string t -> js_string t opt meth\n\n  method lookupPrefix : js_string t -> js_string t opt meth\nend\n\nlet appendChild (p : #node t) (n : #node t) = ignore (p##appendChild (n :> node t))\n\nlet removeChild (p : #node t) (n : #node t) = ignore (p##removeChild (n :> node t))\n\nlet replaceChild (p : #node t) (n : #node t) (o : #node t) =\n  ignore (p##replaceChild (n :> node t) (o :> node t))\n\nlet insertBefore (p : #node t) (n : #node t) (o : #node t opt) =\n  ignore (p##insertBefore (n :> node t) (o :> node t opt))\n\n(** Specification of [Attr] objects. *)\nclass type attr = object\n  inherit node\n\n  method name : js_string t readonly_prop\n\n  method specified : bool t readonly_prop\n\n  method value : js_string t prop\n\n  method ownerElement : element t prop\nend\n\n(** Specification of [NamedNodeMap] objects. *)\nand ['node] namedNodeMap = object\n  method getNamedItem : js_string t -> 'node t opt meth\n\n  method setNamedItem : 'node t -> 'node t opt meth\n\n  method removeNamedItem : js_string t -> 'node t opt meth\n\n  method item : int -> 'node t opt meth\n\n  method length : int readonly_prop\nend\n\n(** Specification of [Element] objects. *)\nand element = object\n  inherit node\n\n  method tagName : js_string t readonly_prop\n\n  method getAttribute : js_string t -> js_string t opt meth\n\n  method setAttribute : js_string t -> js_string t -> unit meth\n\n  method removeAttribute : js_string t -> unit meth\n\n  method hasAttribute : js_string t -> bool t meth\n\n  method getAttributeNS : js_string t -> js_string t -> js_string t opt meth\n\n  method setAttributeNS : js_string t -> js_string t -> js_string t -> unit meth\n\n  method removeAttributeNS : js_string t -> js_string t -> unit meth\n\n  method hasAttributeNS : js_string t -> js_string t -> bool t meth\n\n  method getAttributeNode : js_string t -> attr t opt meth\n\n  method setAttributeNode : attr t -> attr t opt meth\n\n  method removeAttributeNode : attr t -> attr t meth\n\n  method getAttributeNodeNS : js_string t -> js_string t -> attr t opt meth\n\n  method setAttributeNodeNS : attr t -> attr t opt meth\n\n  method getElementsByTagName : js_string t -> element nodeList t meth\n\n  method attributes : attr namedNodeMap t readonly_prop\nend\n\nclass type characterData = object\n  inherit node\n\n  method data : js_string t prop\n\n  method length : int readonly_prop\n\n  method subjs_stringData : int -> int -> js_string t meth\n\n  method appendData : js_string t -> unit meth\n\n  method insertData : int -> js_string t -> unit meth\n\n  method deleteData : int -> int -> unit meth\n\n  method replaceData : int -> int -> js_string t -> unit meth\nend\n\nclass type comment = characterData\n\nclass type text = characterData\n\nclass type documentFragment = node\n\nclass type ['element] document = object\n  inherit node\n\n  method documentElement : 'element t readonly_prop\n\n  method createDocumentFragment : documentFragment t meth\n\n  method createElement : js_string t -> 'element t meth\n\n  method createElementNS : js_string t -> js_string t -> 'element t meth\n\n  method createTextNode : js_string t -> text t meth\n\n  method createAttribute : js_string t -> attr t meth\n\n  method createComment : js_string t -> comment t meth\n\n  method getElementById : js_string t -> 'element t opt meth\n\n  method getElementsByTagName : js_string t -> 'element nodeList t meth\n\n  method importNode : element t -> bool t -> 'element t meth\n\n  method adoptNode : element t -> 'element t meth\nend\n\ntype node_type =\n  | Element of element t\n  | Attr of attr t\n  | Text of text t\n  | Other of node t\n\nlet nodeType e =\n  match e##.nodeType with\n  | ELEMENT -> Element (Js.Unsafe.coerce e)\n  | ATTRIBUTE -> Attr (Js.Unsafe.coerce e)\n  | CDATA_SECTION | TEXT -> Text (Js.Unsafe.coerce e)\n  | _ -> Other (e :> node t)\n\nmodule CoerceTo = struct\n  let cast (e : #node Js.t) t =\n    if e##.nodeType == t then Js.some (Js.Unsafe.coerce e) else Js.null\n\n  let element e : element Js.t Js.opt = cast e ELEMENT\n\n  let text e : text Js.t Js.opt =\n    if e##.nodeType == TEXT || e##.nodeType == CDATA_SECTION\n    then Js.some (Js.Unsafe.coerce e)\n    else Js.null\n\n  let attr e : attr Js.t Js.opt = cast e ATTRIBUTE\nend\n\ntype ('a, 'b) event_listener = ('a, 'b -> bool t) meth_callback opt\n(** The type of event listener functions.  The first type parameter\n      ['a] is the type of the target object; the second parameter\n      ['b] is the type of the event object. *)\n\nclass type ['a] event = object\n  method _type : js_string t readonly_prop\n\n  method target : 'a t opt readonly_prop\n\n  method currentTarget : 'a t opt readonly_prop\n\n  (* Legacy methods *)\n  method srcElement : 'a t opt readonly_prop\nend\n\nclass type ['a, 'b] customEvent = object\n  inherit ['a] event\n\n  method detail : 'b Js.opt Js.readonly_prop\nend\n\nlet no_handler : ('a, 'b) event_listener = Js.null\n\nlet window_event () : 'a #event t = Js.Unsafe.pure_js_expr \"event\"\n\n(* The function preventDefault must be called explicitly when\n   using addEventListener... *)\nlet handler f =\n  Js.some\n    (Js.Unsafe.callback (fun e ->\n         (* depending on the internet explorer version, e can be null or undefined. *)\n         if not (Js.Opt.test (some e))\n         then (\n           let e = window_event () in\n           let res = f e in\n           if not (Js.to_bool res) then e##.returnValue := res;\n           res)\n         else\n           let res = f e in\n           if not (Js.to_bool res) then (Js.Unsafe.coerce e)##preventDefault;\n           res))\n\nlet full_handler f =\n  Js.some\n    (Js.Unsafe.meth_callback (fun this e ->\n         (* depending on the internet explorer version, e can be null or undefined *)\n         if not (Js.Opt.test (some e))\n         then (\n           let e = window_event () in\n           let res = f this e in\n           if not (Js.to_bool res) then e##.returnValue := res;\n           res)\n         else\n           let res = f this e in\n           if not (Js.to_bool res) then (Js.Unsafe.coerce e)##preventDefault;\n           res))\n\nlet invoke_handler (f : ('a, 'b) event_listener) (this : 'a) (event : 'b) : bool t =\n  Js.Unsafe.call f this [| Js.Unsafe.inject event |]\n\nlet eventTarget (e : (< .. > as 'a) #event t) : 'a t =\n  let target =\n    Opt.get e##.target (fun () -> Opt.get e##.srcElement (fun () -> raise Not_found))\n  in\n  if Js.instanceof target Js.Unsafe.global##._Node\n  then\n    (* Workaround for Safari bug *)\n    let target' : node Js.t = Js.Unsafe.coerce target in\n    if target'##.nodeType == TEXT\n    then Js.Unsafe.coerce (Opt.get target'##.parentNode (fun () -> assert false))\n    else target\n  else target\n\nmodule Event = struct\n  type 'a typ = Js.js_string Js.t\n\n  let make s = Js.string s\nend\n\ntype event_listener_id = unit -> unit\n\nclass type event_listener_options = object\n  method capture : bool t writeonly_prop\n\n  method once : bool t writeonly_prop\n\n  method passive : bool t writeonly_prop\nend\n\nlet addEventListenerWithOptions (e : (< .. > as 'a) t) typ ?capture ?once ?passive h =\n  if not (Js.Optdef.test (Js.Unsafe.coerce e)##.addEventListener)\n  then\n    let ev = (Js.string \"on\")##concat typ in\n    let callback e = Js.Unsafe.call (h, e, [||]) in\n    let () = (Js.Unsafe.coerce e)##attachEvent ev callback in\n    fun () -> (Js.Unsafe.coerce e)##detachEvent ev callback\n  else\n    let opts : event_listener_options t = Js.Unsafe.obj [||] in\n    let iter t f =\n      match t with\n      | None -> ()\n      | Some b -> f b\n    in\n    iter capture (fun b -> opts##.capture := b);\n    iter once (fun b -> opts##.once := b);\n    iter passive (fun b -> opts##.passive := b);\n    let () = (Js.Unsafe.coerce e)##addEventListener typ h opts in\n    fun () -> (Js.Unsafe.coerce e)##removeEventListener typ h opts\n\nlet addEventListener (e : (< .. > as 'a) t) typ h capt =\n  addEventListenerWithOptions e typ ~capture:capt h\n\nlet removeEventListener id = id ()\n\nlet preventDefault ev =\n  if Js.Optdef.test (Js.Unsafe.coerce ev)##.preventDefault (* IE hack *)\n  then (Js.Unsafe.coerce ev)##preventDefault\n  else (Js.Unsafe.coerce ev)##.returnValue := Js.bool false\n\nlet createCustomEvent ?bubbles ?cancelable ?detail typ =\n  let opt_iter f = function\n    | None -> ()\n    | Some x -> f x\n  in\n  let opts = Unsafe.obj [||] in\n  opt_iter (fun x -> opts##.bubbles := bool x) bubbles;\n  opt_iter (fun x -> opts##.cancelable := bool x) cancelable;\n  opt_iter (fun x -> opts##.detail := some x) detail;\n  let constr :\n      (   ('a, 'b) #customEvent Js.t Event.typ\n       -> < detail : 'b opt prop > t\n       -> ('a, 'b) customEvent t)\n      constr =\n    Unsafe.global##._CustomEvent\n  in\n  new%js constr typ opts\n\n(* IE < 9 *)\n\nclass type stringList = object\n  method item : int -> js_string t opt meth\n\n  method length : int readonly_prop\n\n  method contains : js_string t -> bool t meth\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nclass type console = object\n  method log : _ -> unit meth\n\n  method log_2 : _ -> _ -> unit meth\n\n  method log_3 : _ -> _ -> _ -> unit meth\n\n  method log_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method log_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_6 : _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_7 : _ -> _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_8 : _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method debug : _ -> unit meth\n\n  method debug_2 : _ -> _ -> unit meth\n\n  method debug_3 : _ -> _ -> _ -> unit meth\n\n  method debug_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method debug_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method info : _ -> unit meth\n\n  method info_2 : _ -> _ -> unit meth\n\n  method info_3 : _ -> _ -> _ -> unit meth\n\n  method info_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method info_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method warn : _ -> unit meth\n\n  method warn_2 : _ -> _ -> unit meth\n\n  method warn_3 : _ -> _ -> _ -> unit meth\n\n  method warn_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method warn_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method error : _ -> unit meth\n\n  method error_2 : _ -> _ -> unit meth\n\n  method error_3 : _ -> _ -> _ -> unit meth\n\n  method error_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method error_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method assert_ : bool t -> unit meth\n\n  method assert_1 : bool t -> _ -> unit meth\n\n  method assert_2 : bool t -> _ -> _ -> unit meth\n\n  method assert_3 : bool t -> _ -> _ -> _ -> unit meth\n\n  method assert_4 : bool t -> _ -> _ -> _ -> _ -> unit meth\n\n  method assert_5 : bool t -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method dir : _ -> unit meth\n\n  method dirxml : Dom.node t -> unit meth\n\n  method trace : unit meth\n\n  method group : _ -> unit meth\n\n  method group_2 : _ -> _ -> unit meth\n\n  method group_3 : _ -> _ -> _ -> unit meth\n\n  method group_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method group_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method groupCollapsed : _ -> unit meth\n\n  method groupCollapsed_2 : _ -> _ -> unit meth\n\n  method groupCollapsed_3 : _ -> _ -> _ -> unit meth\n\n  method groupCollapsed_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method groupCollapsed_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method groupEnd : unit meth\n\n  method time : js_string t -> unit meth\n\n  method timeEnd : js_string t -> unit meth\nend\n\nexternal get_console : unit -> console t = \"caml_js_get_console\"\n\nlet console = get_console ()\n","\ntype t = int\nlet equal (x : int) (y : int) = x = y\nlet compare (x : int) (y : int) = compare x y\nlet to_int x = x\nlet pp = Format.pp_print_int\n\nlet intersect x y = x land y <> 0\nlet (++) x y = x lor y\n\nlet dummy = -1\nlet inexistant = 1\nlet letter = 2\nlet not_letter = 4\nlet newline = 8\nlet lastnewline = 16\nlet search_boundary = 32\n\nlet from_char = function\n  (* Should match [cword] definition *)\n  | 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | '\\170' | '\\181' | '\\186'\n  | '\\192'..'\\214' | '\\216'..'\\246' | '\\248'..'\\255' ->\n    letter\n  | '\\n' ->\n    not_letter ++ newline\n  | _ ->\n    not_letter\n","(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\ntype sem = [ `Longest | `Shortest | `First ]\n\ntype rep_kind = [ `Greedy | `Non_greedy ]\n\ntype mark = int\ntype idx = int\n\ntype expr = { id : int; def : def }\n\nand def =\n    Cst of Cset.t\n  | Alt of expr list\n  | Seq of sem * expr * expr\n  | Eps\n  | Rep of rep_kind * sem * expr\n  | Mark of int\n  | Erase of int * int\n  | Before of Category.t\n  | After of Category.t\n  | Pmark of Pmark.t\n\nlet hash_combine h accu = accu * 65599 + h\n\nmodule Marks = struct\n  type t =\n    { marks : (int * int) list\n    ; pmarks : Pmark.Set.t }\n\n  let empty = { marks = [] ; pmarks = Pmark.Set.empty }\n\n  let rec merge_marks_offset old = function\n    | [] ->\n      old\n    | (i, v) :: rem ->\n      let nw' = merge_marks_offset (List.remove_assq i old) rem in\n      if v = -2 then\n        nw'\n      else\n        (i, v) :: nw'\n\n  let merge old nw =\n    { marks = merge_marks_offset old.marks nw.marks\n    ; pmarks = Pmark.Set.union old.pmarks nw.pmarks }\n\n  let rec hash_marks_offset l accu =\n    match l with\n      []          -> accu\n    | (a, i) :: r -> hash_marks_offset r (hash_combine a (hash_combine i accu))\n\n  let hash m accu =\n    hash_marks_offset m.marks (hash_combine (Hashtbl.hash m.pmarks) accu)\n\n  let rec marks_set_idx idx = function\n    | (a, -1) :: rem ->\n      (a, idx) :: marks_set_idx idx rem\n    | marks ->\n      marks\n\n  let marks_set_idx marks idx =\n    { marks with marks = marks_set_idx idx marks.marks }\n\n  let pp_marks ch t =\n    match t.marks with\n    | [] ->\n      ()\n    | (a, i) :: r ->\n      Format.fprintf ch \"%d-%d\" a i;\n      List.iter (fun (a, i) -> Format.fprintf ch \" %d-%d\" a i) r\nend\n\n(****)\n\nlet pp_sem ch k =\n  Format.pp_print_string ch\n    (match k with\n       `Shortest -> \"short\"\n     | `Longest  -> \"long\"\n     | `First    -> \"first\")\n\n\nlet pp_rep_kind fmt = function\n  | `Greedy -> Format.pp_print_string fmt \"Greedy\"\n  | `Non_greedy -> Format.pp_print_string fmt \"Non_greedy\"\n\nlet rec pp ch e =\n  let open Fmt in\n  match e.def with\n    Cst l ->\n    sexp ch \"cst\" Cset.pp l;\n  | Alt l ->\n    sexp ch \"alt\" (list pp) l\n  | Seq (k, e, e') ->\n    sexp ch \"seq\" (triple pp_sem pp pp) (k, e, e')\n  | Eps ->\n    str ch \"eps\"\n  | Rep (_rk, k, e) ->\n    sexp ch \"rep\" (pair pp_sem pp) (k, e)\n  | Mark i ->\n    sexp ch \"mark\" int i\n  | Pmark i ->\n    sexp ch \"pmark\" int (i :> int)\n  | Erase (b, e) ->\n    sexp ch \"erase\" (pair int int) (b, e)\n  | Before c ->\n    sexp ch \"before\" Category.pp c\n  | After c ->\n    sexp ch \"after\" Category.pp c\n\n\n(****)\n\nlet rec first f = function\n  | [] ->\n    None\n  | x :: r ->\n    match f x with\n      None          -> first f r\n    | Some _ as res -> res\n\n(****)\n\ntype ids = int ref\nlet create_ids () = ref 0\n\nlet eps_expr = { id = 0; def = Eps }\n\nlet mk_expr ids def =\n  incr ids;\n  { id = !ids; def = def }\n\nlet empty ids = mk_expr ids (Alt [])\n\nlet cst ids s =\n  if Cset.is_empty s\n  then empty ids\n  else mk_expr ids (Cst s)\n\nlet alt ids = function\n  | []  -> empty ids\n  | [c] -> c\n  | l   -> mk_expr ids (Alt l)\n\nlet seq ids kind x y =\n  match x.def, y.def with\n    Alt [], _                 -> x\n  | _, Alt []                 -> y\n  | Eps, _                    -> y\n  | _, Eps when kind = `First -> x\n  | _                         -> mk_expr ids (Seq (kind, x, y))\n\nlet is_eps expr =\n  match expr.def with\n  | Eps -> true\n  | _ -> false\n\nlet eps ids = mk_expr ids Eps\n\nlet rep ids kind sem x = mk_expr ids (Rep (kind, sem, x))\n\nlet mark ids m = mk_expr ids (Mark m)\n\nlet pmark ids i = mk_expr ids (Pmark i)\n\nlet erase ids m m' = mk_expr ids (Erase (m, m'))\n\nlet before ids c = mk_expr ids (Before c)\n\nlet after ids c = mk_expr ids (After c)\n\n(****)\n\nlet rec rename ids x =\n  match x.def with\n    Cst _ | Eps | Mark _ | Pmark _ | Erase _ | Before _ | After _ ->\n    mk_expr ids x.def\n  | Alt l ->\n    mk_expr ids (Alt (List.map (rename ids) l))\n  | Seq (k, y, z) ->\n    mk_expr ids (Seq (k, rename ids y, rename ids z))\n  | Rep (g, k, y) ->\n    mk_expr ids (Rep (g, k, rename ids y))\n\n(****)\n\ntype hash = int\ntype mark_infos = int array\ntype status = Failed | Match of mark_infos * Pmark.Set.t | Running\n\nmodule E = struct\n  type t =\n    | TSeq of t list * expr * sem\n    | TExp of Marks.t * expr\n    | TMatch of Marks.t\n\n  let rec equal l1 l2 =\n    match l1, l2 with\n    | [], [] ->\n      true\n    | TSeq (l1', e1, _) :: r1, TSeq (l2', e2, _) :: r2 ->\n      e1.id = e2.id && equal l1' l2' && equal r1 r2\n    | TExp (marks1, e1) :: r1, TExp (marks2, e2) :: r2 ->\n      e1.id = e2.id && marks1 = marks2 && equal r1 r2\n    | TMatch marks1 :: r1, TMatch marks2 :: r2 ->\n      marks1 = marks2 && equal r1 r2\n    | _ ->\n      false\n\n  let rec hash l accu =\n    match l with\n    | [] ->\n      accu\n    | TSeq (l', e, _) :: r ->\n      hash r (hash_combine 0x172a1bce (hash_combine e.id (hash l' accu)))\n    | TExp (marks, e) :: r ->\n      hash r\n        (hash_combine 0x2b4c0d77 (hash_combine e.id (Marks.hash marks accu)))\n    | TMatch marks :: r ->\n      hash r (hash_combine 0x1c205ad5 (Marks.hash marks accu))\n\n  let texp marks x = TExp (marks, x)\n\n  let tseq kind x y rem =\n    match x with\n      []                              -> rem\n    | [TExp (marks, {def = Eps ; _})] -> TExp (marks, y) :: rem\n    | _                               -> TSeq (x, y, kind) :: rem\n\n  let rec print_state_rec ch e y =\n    match e with\n    | TMatch marks ->\n      Format.fprintf ch \"@[<2>(Match@ %a)@]\" Marks.pp_marks marks\n    | TSeq (l', x, _kind) ->\n      Format.fprintf ch \"@[<2>(Seq@ \";\n      print_state_lst ch l' x;\n      Format.fprintf ch \"@ %a)@]\" pp x\n    | TExp (marks, {def = Eps; _}) ->\n      Format.fprintf ch \"@[<2>(Exp@ %d@ (%a)@ (eps))@]\" y.id Marks.pp_marks marks\n    | TExp (marks, x) ->\n      Format.fprintf ch \"@[<2>(Exp@ %d@ (%a)@ %a)@]\" x.id Marks.pp_marks marks pp x\n\n  and print_state_lst ch l y =\n    match l with\n      [] ->\n      Format.fprintf ch \"()\"\n    | e :: rem ->\n      print_state_rec ch e y;\n      List.iter\n        (fun e ->\n           Format.fprintf ch \"@ | \";\n           print_state_rec ch e y)\n        rem\n\n  let pp ch t = print_state_lst ch [t] { id = 0; def = Eps }\nend\n\nmodule State = struct\n  type t =\n    { idx: idx\n    ; category: Category.t\n    ; desc: E.t list\n    ; mutable status: status option\n    ; hash: hash }\n\n  let dummy =\n    { idx = -1\n    ; category = Category.dummy\n    ; desc = []\n    ; status = None\n    ; hash = -1 }\n\n  let hash idx cat desc =\n    E.hash desc (hash_combine idx (hash_combine (Category.to_int cat) 0)) land 0x3FFFFFFF\n\n  let mk idx cat desc =\n    { idx\n    ; category = cat\n    ; desc\n    ; status = None\n    ; hash = hash idx cat desc}\n\n  let create cat e = mk 0 cat [E.TExp (Marks.empty, e)]\n\n  let equal x y =\n    (x.hash : int) = y.hash && (x.idx : int) = y.idx &&\n    Category.equal x.category y.category && E.equal x.desc y.desc\n\n  let compare x y =\n    let c = compare (x.hash : int) y.hash in\n    if c <> 0 then c else\n      let c = Category.compare x.category y.category in\n      if c <> 0 then c else\n        compare x.desc y.desc\n\n  type t' = t\n  module Table = Hashtbl.Make(\n    struct\n      type t = t'\n      let equal = equal\n      let hash t = t.hash\n    end)\nend\n\n(**** Find a free index ****)\n\ntype working_area = bool array ref\n\nlet create_working_area () = ref [| false |]\n\nlet index_count w = Array.length !w\n\nlet reset_table a = Array.fill a 0 (Array.length a) false\n\nlet rec mark_used_indices tbl =\n  List.iter (function\n      | E.TSeq (l, _, _) -> mark_used_indices tbl l\n      | E.TExp (marks, _)\n      | E.TMatch marks ->\n        List.iter (fun (_, i) -> if i >= 0 then tbl.(i) <- true)\n          marks.Marks.marks)\n\nlet rec find_free tbl idx len =\n  if idx = len || not tbl.(idx) then idx else find_free tbl (idx + 1) len\n\nlet free_index tbl_ref l =\n  let tbl = !tbl_ref in\n  reset_table tbl;\n  mark_used_indices tbl l;\n  let len = Array.length tbl in\n  let idx = find_free tbl 0 len in\n  if idx = len then tbl_ref := Array.make (2 * len) false;\n  idx\n\n(**** Computation of the next state ****)\n\nlet remove_matches = List.filter (function E.TMatch _ -> false | _ -> true)\n\nlet rec split_at_match_rec l' = function\n  | []            -> assert false\n  | E.TMatch _ :: r -> (List.rev l', remove_matches r)\n  | x :: r        -> split_at_match_rec (x :: l') r\n\nlet split_at_match l = split_at_match_rec [] l\n\nlet rec remove_duplicates prev l y =\n  match l with\n    [] ->\n    ([], prev)\n  | E.TMatch _ as x :: _ -> (* Truncate after first match *)\n    ([x], prev)\n  | E.TSeq (l', x, kind) :: r ->\n    let (l'', prev') = remove_duplicates prev l' x in\n    let (r', prev'') = remove_duplicates prev' r y in\n    (E.tseq kind l'' x r', prev'')\n  | E.TExp (_marks, {def = Eps; _}) as e :: r ->\n    if List.memq y.id prev then\n      remove_duplicates prev r y\n    else\n      let (r', prev') = remove_duplicates (y.id :: prev) r y in\n      (e :: r', prev')\n  | E.TExp (_marks, x) as e :: r ->\n    if List.memq x.id prev then\n      remove_duplicates prev r y\n    else\n      let (r', prev') = remove_duplicates (x.id :: prev) r y in\n      (e :: r', prev')\n\nlet rec set_idx idx = function\n  | [] ->\n    []\n  | E.TMatch marks :: r ->\n    E.TMatch (Marks.marks_set_idx marks idx) :: set_idx idx r\n  | E.TSeq (l', x, kind) :: r ->\n    E.TSeq (set_idx idx l', x, kind) :: set_idx idx r\n  | E.TExp (marks, x) :: r ->\n    E.TExp ((Marks.marks_set_idx marks idx), x) :: set_idx idx r\n\nlet filter_marks b e marks =\n  {marks with Marks.marks = List.filter (fun (i, _) -> i < b || i > e) marks.Marks.marks }\n\nlet rec delta_1 marks c ~next_cat ~prev_cat x rem =\n  (*Format.eprintf \"%d@.\" x.id;*)\n  match x.def with\n    Cst s ->\n    if Cset.mem c s then E.texp marks eps_expr :: rem else rem\n  | Alt l ->\n    delta_2 marks c ~next_cat ~prev_cat l rem\n  | Seq (kind, y, z) ->\n    let y' = delta_1 marks c ~next_cat ~prev_cat y [] in\n    delta_seq c ~next_cat ~prev_cat kind y' z rem\n  | Rep (rep_kind, kind, y) ->\n    let y' = delta_1 marks c ~next_cat ~prev_cat y [] in\n    let (y'', marks') =\n      match\n        first\n          (function E.TMatch marks -> Some marks | _ -> None) y'\n      with\n        None        -> (y', marks)\n      | Some marks' -> (remove_matches y', marks')\n    in\n    begin match rep_kind with\n        `Greedy     -> E.tseq kind y'' x (E.TMatch marks' :: rem)\n      | `Non_greedy -> E.TMatch marks :: E.tseq kind y'' x rem\n    end\n  | Eps ->\n    E.TMatch marks :: rem\n  | Mark i ->\n    let marks = { marks with Marks.marks = (i, -1) :: List.remove_assq i marks.Marks.marks } in\n    E.TMatch marks :: rem\n  | Pmark i ->\n    let marks = { marks with Marks.pmarks = Pmark.Set.add i marks.Marks.pmarks } in\n    E.TMatch marks :: rem\n  | Erase (b, e) ->\n    E.TMatch (filter_marks b e marks) :: rem\n  | Before cat'' ->\n    if Category.intersect next_cat cat'' then E.TMatch marks :: rem else rem\n  | After cat'' ->\n    if Category.intersect prev_cat cat'' then E.TMatch marks :: rem else rem\n\nand delta_2 marks c ~next_cat ~prev_cat l rem =\n  match l with\n    []     -> rem\n  | y :: r ->\n    delta_1 marks c ~next_cat ~prev_cat y\n      (delta_2 marks c ~next_cat ~prev_cat r rem)\n\nand delta_seq c ~next_cat ~prev_cat kind y z rem =\n  match\n    first (function E.TMatch marks -> Some marks | _ -> None) y\n  with\n    None ->\n    E.tseq kind y z rem\n  | Some marks ->\n    match kind with\n      `Longest ->\n      E.tseq kind (remove_matches y) z\n        (delta_1 marks c ~next_cat ~prev_cat z rem)\n    | `Shortest ->\n      delta_1 marks c ~next_cat ~prev_cat z\n        (E.tseq kind (remove_matches y) z rem)\n    | `First ->\n      let (y', y'') = split_at_match y in\n      E.tseq kind y' z\n        (delta_1 marks c ~next_cat ~prev_cat z (E.tseq kind y'' z rem))\n\nlet rec delta_3 c ~next_cat ~prev_cat x rem =\n  match x with\n    E.TSeq (y, z, kind) ->\n    let y' = delta_4 c ~next_cat ~prev_cat y [] in\n    delta_seq c ~next_cat ~prev_cat kind y' z rem\n  | E.TExp (marks, e) ->\n    delta_1 marks c ~next_cat ~prev_cat e rem\n  | E.TMatch _ ->\n    x :: rem\n\nand delta_4 c ~next_cat ~prev_cat l rem =\n  match l with\n    []     -> rem\n  | y :: r ->\n    delta_3 c ~next_cat ~prev_cat y\n      (delta_4 c ~next_cat ~prev_cat r rem)\n\nlet delta tbl_ref next_cat char st =\n  let prev_cat = st.State.category in\n  let (expr', _) =\n    remove_duplicates []\n      (delta_4 char ~next_cat ~prev_cat st.State.desc [])\n      eps_expr in\n  let idx = free_index tbl_ref expr' in\n  let expr'' = set_idx idx expr' in\n  State.mk idx next_cat expr''\n\n(****)\n\nlet rec red_tr = function\n  | [] | [_] as l ->\n    l\n  | ((s1, st1) as tr1) :: ((s2, st2) as tr2) :: rem ->\n    if State.equal st1 st2 then\n      red_tr ((Cset.union s1 s2, st1) :: rem)\n    else\n      tr1 :: red_tr (tr2 :: rem)\n\nlet simpl_tr l =\n  List.sort\n    (fun (s1, _) (s2, _) -> compare s1 s2)\n    (red_tr (List.sort (fun (_, st1) (_, st2) -> State.compare st1 st2) l))\n\n(****)\n\nlet prepend_deriv = List.fold_right (fun (s, x) l -> Cset.prepend s x l)\n\nlet rec restrict s = function\n  | [] -> []\n  | (s', x') :: rem ->\n    let s'' = Cset.inter s s' in\n    if Cset.is_empty s''\n    then restrict s rem\n    else (s'', x') :: restrict s rem\n\nlet rec remove_marks b e rem =\n  if b > e then rem else remove_marks b (e - 1) ((e, -2) :: rem)\n\nlet rec prepend_marks_expr m = function\n  | E.TSeq (l, e', s) -> E.TSeq (prepend_marks_expr_lst m l, e', s)\n  | E.TExp (m', e')   -> E.TExp (Marks.merge m m', e')\n  | E.TMatch m'       -> E.TMatch (Marks.merge m m')\n\nand prepend_marks_expr_lst m l =\n  List.map (prepend_marks_expr m) l\n\nlet prepend_marks m =\n  List.map (fun (s, x) -> (s, prepend_marks_expr_lst m x))\n\nlet rec deriv_1 all_chars categories marks cat x rem =\n  match x.def with\n  | Cst s ->\n    Cset.prepend s [E.texp marks eps_expr] rem\n  | Alt l ->\n    deriv_2 all_chars categories marks cat l rem\n  | Seq (kind, y, z) ->\n    let y' = deriv_1 all_chars categories marks cat y [(all_chars, [])] in\n    deriv_seq all_chars categories cat kind y' z rem\n  | Rep (rep_kind, kind, y) ->\n    let y' = deriv_1 all_chars categories marks cat y [(all_chars, [])] in\n    List.fold_right\n      (fun (s, z) rem ->\n         let (z', marks') =\n           match\n             first\n               (function E.TMatch marks -> Some marks | _ -> None)\n               z\n           with\n             None        -> (z, marks)\n           | Some marks' -> (remove_matches z, marks')\n         in\n         Cset.prepend s\n           (match rep_kind with\n              `Greedy     -> E.tseq kind z' x [E.TMatch marks']\n            | `Non_greedy -> E.TMatch marks :: E.tseq kind z' x [])\n           rem)\n      y' rem\n  | Eps ->\n    Cset.prepend all_chars [E.TMatch marks] rem\n  | Mark i ->\n    Cset.prepend all_chars [E.TMatch {marks with Marks.marks = ((i, -1) :: List.remove_assq i marks.Marks.marks)}] rem\n  | Pmark _ ->\n    Cset.prepend all_chars [E.TMatch marks] rem\n  | Erase (b, e) ->\n    Cset.prepend all_chars\n      [E.TMatch {marks with Marks.marks = (remove_marks b e (filter_marks b e marks).Marks.marks)}] rem\n  | Before cat' ->\n    Cset.prepend (List.assq cat' categories) [E.TMatch marks] rem\n  | After cat' ->\n    if Category.intersect cat cat' then Cset.prepend all_chars [E.TMatch marks] rem else rem\n\nand deriv_2 all_chars categories marks cat l rem =\n  match l with\n    []     -> rem\n  | y :: r -> deriv_1 all_chars categories marks cat y\n                (deriv_2 all_chars categories marks cat r rem)\n\nand deriv_seq all_chars categories cat kind y z rem =\n  if\n    List.exists\n      (fun (_s, xl) ->\n         List.exists (function E.TMatch _ -> true | _ -> false) xl)\n      y\n  then\n    let z' = deriv_1 all_chars categories Marks.empty cat z [(all_chars, [])] in\n    List.fold_right\n      (fun (s, y) rem ->\n         match\n           first (function E.TMatch marks -> Some marks | _ -> None)\n             y\n         with\n           None ->\n           Cset.prepend s (E.tseq kind y z []) rem\n         | Some marks ->\n           let z'' = prepend_marks marks z' in\n           match kind with\n             `Longest ->\n             Cset.prepend s (E.tseq kind (remove_matches y) z []) (\n               prepend_deriv (restrict s z'') rem)\n           | `Shortest ->\n             prepend_deriv (restrict s z'') (\n               Cset.prepend s (E.tseq kind (remove_matches y) z []) rem)\n           | `First ->\n             let (y', y'') = split_at_match y in\n             Cset.prepend s (E.tseq kind y' z []) (\n               prepend_deriv (restrict s z'') (\n                 Cset.prepend s (E.tseq kind y'' z []) rem)))\n      y rem\n  else\n    List.fold_right\n      (fun (s, xl) rem -> Cset.prepend s (E.tseq kind xl z []) rem) y rem\n\nlet rec deriv_3 all_chars categories cat x rem =\n  match x with\n    E.TSeq (y, z, kind) ->\n    let y' = deriv_4 all_chars categories cat y [(all_chars, [])] in\n    deriv_seq all_chars categories cat kind y' z rem\n  | E.TExp (marks, e) ->\n    deriv_1 all_chars categories marks cat e rem\n  | E.TMatch _ ->\n    Cset.prepend all_chars [x] rem\n\nand deriv_4 all_chars categories cat l rem =\n  match l with\n    []     -> rem\n  | y :: r -> deriv_3 all_chars categories cat y\n                (deriv_4 all_chars categories cat r rem)\n\nlet deriv tbl_ref all_chars categories st =\n  let der = deriv_4 all_chars categories st.State.category st.State.desc\n      [(all_chars, [])] in\n  simpl_tr (\n    List.fold_right (fun (s, expr) rem ->\n        let (expr', _) = remove_duplicates [] expr eps_expr in\n(*\nFormat.eprintf \"@[<3>@[%a@]: %a / %a@]@.\" Cset.print s print_state expr print_state expr';\n*)\n        let idx = free_index tbl_ref expr' in\n        let expr'' = set_idx idx expr' in\n        List.fold_right (fun (cat', s') rem ->\n            let s'' = Cset.inter s s' in\n            if Cset.is_empty s''\n            then rem\n            else (s'', State.mk idx cat' expr'') :: rem)\n          categories rem) der [])\n\n(****)\n\nlet flatten_match m =\n  let ma = List.fold_left (fun ma (i, _) -> max ma i) (-1) m in\n  let res = Array.make (ma + 1) (-1) in\n  List.iter (fun (i, v) -> res.(i) <- v) m;\n  res\n\nlet status s =\n  match s.State.status with\n    Some st ->\n    st\n  | None ->\n    let st =\n      match s.State.desc with\n        []              -> Failed\n      | E.TMatch m :: _ -> Match (flatten_match m.Marks.marks, m.Marks.pmarks)\n      | _               -> Running\n    in\n    s.State.status <- Some st;\n    st\n","(* In reality, this can really be represented as a bool array.\n\n   The representation is best thought of as a list of all chars along with a\n   flag:\n\n   (a, 0), (b, 1), (c, 0), (d, 0), ...\n\n   characters belonging to the same color are represented by sequnces of\n   characters with the flag set to 0.\n*)\n\ntype t = Bytes.t\n\nlet make () = Bytes.make 257 '\\000'\n\nlet flatten cm =\n  let c = Bytes.create 256 in\n  let color_repr = Bytes.create 256 in\n  let v = ref 0 in\n  Bytes.set c 0 '\\000';\n  Bytes.set color_repr 0 '\\000';\n  for i = 1 to 255 do\n    if Bytes.get cm i <> '\\000' then incr v;\n    Bytes.set c i (Char.chr !v);\n    Bytes.set color_repr !v (Char.chr i)\n  done;\n  (Bytes.unsafe_to_string c, Bytes.sub_string color_repr 0 (!v + 1), !v + 1)\n\n(* mark all the endpoints of the intervals of the char set with the 1 byte *)\nlet split s cm =\n  Cset.iter s ~f:(fun i j ->\n      Bytes.set cm i '\\001';\n      Bytes.set cm (j + 1) '\\001';\n    )\n","(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\nlet rec iter n f v = if n = 0 then v else iter (n - 1) f (f v)\n\n(****)\n\nlet unknown = -2\nlet break = -3\n\ntype match_info =\n  | Match of Group.t\n  | Failed\n  | Running of { no_match_starts_before : int }\n\ntype state =\n  { idx : int;\n    (* Index of the current position in the position table.\n       Not yet computed transitions point to a dummy state where\n       [idx] is set to [unknown];\n       If [idx] is set to [break] for states that either always\n       succeed or always fail. *)\n    real_idx : int;\n    (* The real index, in case [idx] is set to [break] *)\n    next : state array;\n    (* Transition table, indexed by color *)\n    mutable final :\n      (Category.t *\n       (Automata.idx * Automata.status)) list;\n    (* Mapping from the category of the next character to\n       - the index where the next position should be saved\n       - possibly, the list of marks (and the corresponding indices)\n         corresponding to the best match *)\n    desc : Automata.State.t\n    (* Description of this state of the automata *) }\n\n(* Automata (compiled regular expression) *)\ntype re =\n  { initial : Automata.expr;\n    (* The whole regular expression *)\n    mutable initial_states : (Category.t * state) list;\n    (* Initial states, indexed by initial category *)\n    colors : string;\n    (* Color table *)\n    color_repr : string;\n    (* Table from colors to one character of this color *)\n    ncolor : int;\n    (* Number of colors. *)\n    lnl : int;\n    (* Color of the last newline. -1 if unnecessary *)\n    tbl : Automata.working_area;\n    (* Temporary table used to compute the first available index\n       when computing a new state *)\n    states : state Automata.State.Table.t;\n    (* States of the deterministic automata *)\n    group_names : (string * int) list;\n    (* Named groups in the regular expression *)\n    group_count : int\n    (* Number of groups in the regular expression *) }\n\nlet pp_re ch re = Automata.pp ch re.initial\n\nlet print_re = pp_re\n\nlet group_count re = re.group_count\n\nlet group_names re = re.group_names\n\n(* Information used during matching *)\ntype info =\n  { re : re;\n    (* The automata *)\n    colors : string;\n    (* Color table ([x.colors = x.re.colors])\n       Shortcut used for performance reasons *)\n    mutable positions : int array;\n    (* Array of mark positions\n       The mark are off by one for performance reasons *)\n    pos : int;\n    (* Position where the match is started *)\n    last : int\n    (* Position where the match should stop *) }\n\n\n(****)\n\nlet category re ~color =\n  if color = -1 then\n    Category.inexistant\n    (* Special category for the last newline *)\n  else if color = re.lnl then\n    Category.(lastnewline ++ newline ++ not_letter)\n  else\n    Category.from_char (re.color_repr.[color])\n\n(****)\n\nlet dummy_next = [||]\n\nlet unknown_state =\n  { idx = unknown; real_idx = 0;\n    next = dummy_next; final = [];\n    desc = Automata.State.dummy }\n\nlet mk_state ncol desc =\n  let break_state =\n    match Automata.status desc with\n    | Automata.Running -> false\n    | Automata.Failed\n    | Automata.Match _ -> true\n  in\n  { idx = if break_state then break else desc.Automata.State.idx;\n    real_idx = desc.Automata.State.idx;\n    next = if break_state then dummy_next else Array.make ncol unknown_state;\n    final = [];\n    desc }\n\nlet find_state re desc =\n  try\n    Automata.State.Table.find re.states desc\n  with Not_found ->\n    let st = mk_state re.ncolor desc in\n    Automata.State.Table.add re.states desc st;\n    st\n\n(**** Match with marks ****)\n\nlet delta info cat ~color st =\n  let desc = Automata.delta info.re.tbl cat color st.desc in\n  let len = Array.length info.positions in\n  if desc.Automata.State.idx = len && len > 0 then begin\n    let pos = info.positions in\n    info.positions <- Array.make (2 * len) 0;\n    Array.blit pos 0 info.positions 0 len\n  end;\n  desc\n\nlet validate info (s:string) ~pos st =\n  let color = Char.code (info.colors.[Char.code s.[pos]]) in\n  let cat = category info.re ~color in\n  let desc' = delta info cat ~color st in\n  let st' = find_state info.re desc' in\n  st.next.(color) <- st'\n\nlet rec loop info s ~pos st =\n  if pos < info.last then\n    let st' = st.next.(Char.code info.colors.[Char.code s.[pos]]) in\n    let idx = st'.idx in\n    if idx >= 0 then begin\n      info.positions.(idx) <- pos;\n      loop info s ~pos:(pos + 1) st'\n    end else if idx = break then begin\n      info.positions.(st'.real_idx) <- pos;\n      st'\n    end else begin (* Unknown *)\n      validate info s ~pos st;\n      loop info s ~pos st\n    end\n  else\n    st\n\nlet rec loop_no_mark info s ~pos ~last st =\n  if pos < last then\n    let st' = st.next.(Char.code info.colors.[Char.code s.[pos]]) in\n    if st'.idx >= 0 then\n      loop_no_mark info s ~pos:(pos + 1) ~last st'\n    else if st'.idx = break then\n      st'\n    else begin (* Unknown *)\n      validate info s ~pos st;\n      loop_no_mark info s ~pos ~last st\n    end\n  else\n    st\n\nlet final info st cat =\n  try\n    List.assq cat st.final\n  with Not_found ->\n    let st' = delta info cat ~color:(-1) st in\n    let res = (st'.Automata.State.idx, Automata.status st') in\n    st.final <- (cat, res) :: st.final;\n    res\n\nlet find_initial_state re cat =\n  try\n    List.assq cat re.initial_states\n  with Not_found ->\n    let st = find_state re (Automata.State.create cat re.initial) in\n    re.initial_states <- (cat, st) :: re.initial_states;\n    st\n\nlet get_color re (s:string) pos =\n  if pos < 0 then\n    -1\n  else\n    let slen = String.length s in\n    if pos >= slen then\n      -1\n    else if pos = slen - 1 && re.lnl <> -1 && s.[pos] = '\\n' then\n      (* Special case for the last newline *)\n      re.lnl\n    else\n      Char.code re.colors.[Char.code s.[pos]]\n\nlet rec handle_last_newline info ~pos st ~groups =\n  let st' = st.next.(info.re.lnl) in\n  if st'.idx >= 0 then begin\n    if groups then info.positions.(st'.idx) <- pos;\n    st'\n  end else if st'.idx = break then begin\n    if groups then info.positions.(st'.real_idx) <- pos;\n    st'\n  end else begin (* Unknown *)\n    let color = info.re.lnl in\n    let real_c = Char.code info.colors.[Char.code '\\n'] in\n    let cat = category info.re ~color in\n    let desc' = delta info cat ~color:real_c st in\n    let st' = find_state info.re desc' in\n    st.next.(color) <- st';\n    handle_last_newline info ~pos st ~groups\n  end\n\nlet rec scan_str info (s:string) initial_state ~groups =\n  let pos = info.pos in\n  let last = info.last in\n  if (last = String.length s\n      && info.re.lnl <> -1\n      && last > pos\n      && String.get s (last - 1) = '\\n')\n  then begin\n    let info = { info with last = last - 1 } in\n    let st = scan_str info s initial_state ~groups in\n    if st.idx = break then\n      st\n    else\n      handle_last_newline info ~pos:(last - 1) st ~groups\n  end else if groups then\n    loop info s ~pos initial_state\n  else\n    loop_no_mark info s ~pos ~last initial_state\n\n(* This function adds a final boundary check on the input.\n   This is useful to indicate that the output failed because\n   of insufficient input, or to verify that the output actually\n   matches for regex that have boundary conditions with respect\n   to the input string.\n *)\nlet final_boundary_check ~last ~slen re s ~info ~st ~groups =\n  let final_cat =\n    if last = slen then\n      Category.(search_boundary ++ inexistant)\n    else\n      Category.(search_boundary ++ category re ~color:(get_color re s last))\n  in\n  let (idx, res) = final info st final_cat in\n  (match groups, res with\n  | true, Match _ -> info.positions.(idx) <- last\n  | _ -> ());\n  res\n\nlet match_str ~groups ~partial re s ~pos ~len =\n  let slen = String.length s in\n  let last = if len = -1 then slen else pos + len in\n  let info =\n    { re ; colors = re.colors; pos ; last\n    ; positions =\n        if groups then begin\n          let n = Automata.index_count re.tbl + 1 in\n          if n <= 10 then\n            [|0;0;0;0;0;0;0;0;0;0|]\n          else\n            Array.make n 0\n        end else\n          [||] }\n  in\n  let initial_cat =\n    if pos = 0 then\n      Category.(search_boundary ++ inexistant)\n    else\n      Category.(search_boundary\n                ++ category re ~color:(get_color re s (pos - 1)))\n  in\n  let initial_state = find_initial_state re initial_cat in\n  let st = scan_str info s initial_state ~groups in\n  let res =\n    if st.idx = break || (partial && not groups) then\n      Automata.status st.desc\n    else if partial && groups then\n      match Automata.status st.desc with\n      | Match _ | Failed as status -> status\n      | Running ->\n        (* This could be because it's still not fully matched, or it\n           could be that because we need to run special end of input\n           checks. *)\n        (match final_boundary_check ~last ~slen re s ~info ~st ~groups with\n         | Match _ as status -> status\n         | Failed | Running ->\n           (* A failure here just means that we need more data, i.e.\n              it's a partial match. *)\n           Running)\n    else final_boundary_check ~last ~slen re s ~info ~st ~groups\n  in\n  match res with\n    Automata.Match (marks, pmarks) ->\n    Match { s ; marks; pmarks ; gpos = info.positions; gcount = re.group_count}\n  | Automata.Failed -> Failed\n  | Automata.Running ->\n    let no_match_starts_before = if groups then info.positions.(0) else 0 in\n    Running { no_match_starts_before }\n\nlet mk_re ~initial ~colors ~color_repr ~ncolor ~lnl ~group_names ~group_count =\n  { initial ;\n    initial_states = [];\n    colors;\n    color_repr;\n    ncolor;\n    lnl;\n    tbl = Automata.create_working_area ();\n    states = Automata.State.Table.create 97;\n    group_names;\n    group_count }\n\n(**** Character sets ****)\n\nlet cseq c c' = Cset.seq (Char.code c) (Char.code c')\nlet cadd c s = Cset.add (Char.code c) s\n\nlet trans_set cache cm s =\n  match Cset.one_char s with\n  | Some i -> Cset.csingle cm.[i]\n  | None ->\n    let v = (Cset.hash_rec s, s) in\n    try\n      Cset.CSetMap.find v !cache\n    with Not_found ->\n      let l =\n        Cset.fold_right\n          s\n          ~f:(fun (i, j) l -> Cset.union (cseq cm.[i] cm.[j]) l)\n          ~init:Cset.empty\n      in\n      cache := Cset.CSetMap.add v l !cache;\n      l\n\n(****)\n\ntype regexp =\n    Set of Cset.t\n  | Sequence of regexp list\n  | Alternative of regexp list\n  | Repeat of regexp * int * int option\n  | Beg_of_line | End_of_line\n  | Beg_of_word | End_of_word | Not_bound\n  | Beg_of_str | End_of_str\n  | Last_end_of_line | Start | Stop\n  | Sem of Automata.sem * regexp\n  | Sem_greedy of Automata.rep_kind * regexp\n  | Group of string option * regexp | No_group of regexp | Nest of regexp\n  | Case of regexp | No_case of regexp\n  | Intersection of regexp list\n  | Complement of regexp list\n  | Difference of regexp * regexp\n  | Pmark of Pmark.t * regexp\n\nmodule View = struct\n  type t = regexp =\n      Set of Cset.t\n    | Sequence of regexp list\n    | Alternative of regexp list\n    | Repeat of regexp * int * int option\n    | Beg_of_line | End_of_line\n    | Beg_of_word | End_of_word | Not_bound\n    | Beg_of_str | End_of_str\n    | Last_end_of_line | Start | Stop\n    | Sem of Automata.sem * regexp\n    | Sem_greedy of Automata.rep_kind * regexp\n    | Group of string option * regexp | No_group of regexp | Nest of regexp\n    | Case of regexp | No_case of regexp\n    | Intersection of regexp list\n    | Complement of regexp list\n    | Difference of regexp * regexp\n    | Pmark of Pmark.t * regexp\n\n  let view t = t\nend\n\nlet rec pp fmt t =\n  let open Fmt in\n  let var s re = sexp fmt s pp re in\n  let seq s rel = sexp fmt s (list pp) rel in\n  match t with\n  | Set s ->  sexp fmt \"Set\" Cset.pp s\n  | Sequence sq -> seq \"Sequence\" sq\n  | Alternative alt -> seq \"Alternative\" alt\n  | Repeat (re, start, stop) ->\n    let pp' fmt () = fprintf fmt \"%a@ %d%a\" pp re   start   optint stop in\n    sexp fmt \"Repeat\" pp' ()\n  | Beg_of_line      -> str fmt \"Beg_of_line\"\n  | End_of_line      -> str fmt \"End_of_line\"\n  | Beg_of_word      -> str fmt \"Beg_of_word\"\n  | End_of_word      -> str fmt \"End_of_word\"\n  | Not_bound        -> str fmt \"Not_bound\"\n  | Beg_of_str       -> str fmt \"Beg_of_str\"\n  | End_of_str       -> str fmt \"End_of_str\"\n  | Last_end_of_line -> str fmt \"Last_end_of_line\"\n  | Start            -> str fmt \"Start\"\n  | Stop             -> str fmt \"Stop\"\n  | Sem (sem, re)    ->\n    sexp fmt \"Sem\" (pair Automata.pp_sem pp) (sem, re)\n  | Sem_greedy (k, re) ->\n    sexp fmt \"Sem_greedy\" (pair Automata.pp_rep_kind pp) (k, re)\n  | Group (None, c)   -> var \"Group\" c\n  | Group (Some n, c) -> sexp fmt \"Named_group\" (pair str pp) (n, c)\n  | No_group c     -> var \"No_group\" c\n  | Nest c         -> var \"Nest\" c\n  | Case c         -> var \"Case\" c\n  | No_case c      -> var \"No_case\" c\n  | Intersection c -> seq \"Intersection\" c\n  | Complement c   -> seq \"Complement\" c\n  | Difference (a, b) -> sexp fmt \"Difference\" (pair pp pp) (a, b)\n  | Pmark (m, r)      -> sexp fmt \"Pmark\" (pair Pmark.pp pp) (m, r)\n\nlet rec is_charset = function\n  | Set _ ->\n    true\n  | Alternative l | Intersection l | Complement l ->\n    List.for_all is_charset l\n  | Difference (r, r') ->\n    is_charset r && is_charset r'\n  | Sem (_, r) | Sem_greedy (_, r)\n  | No_group r | Case r | No_case r ->\n    is_charset r\n  | Sequence _ | Repeat _ | Beg_of_line | End_of_line\n  | Beg_of_word | End_of_word | Beg_of_str | End_of_str\n  | Not_bound | Last_end_of_line | Start | Stop\n  | Group _ | Nest _ | Pmark (_,_)->\n    false\n\n(*XXX Use a better algorithm allowing non-contiguous regions? *)\n\nlet cupper =\n  Cset.union (cseq 'A' 'Z')\n    (Cset.union (cseq '\\192' '\\214') (cseq '\\216' '\\222'))\nlet clower = Cset.offset 32 cupper\nlet calpha =\n  List.fold_right cadd ['\\170'; '\\181'; '\\186'; '\\223'; '\\255']\n    (Cset.union clower cupper)\nlet cdigit = cseq '0' '9'\nlet calnum = Cset.union calpha cdigit\nlet cword = cadd '_' calnum\n\nlet colorize c regexp =\n  let lnl = ref false in\n  let rec colorize regexp =\n    match regexp with\n      Set s                     -> Color_map.split s c\n    | Sequence l                -> List.iter colorize l\n    | Alternative l             -> List.iter colorize l\n    | Repeat (r, _, _)          -> colorize r\n    | Beg_of_line | End_of_line -> Color_map.split (Cset.csingle '\\n') c\n    | Beg_of_word | End_of_word\n    | Not_bound                 -> Color_map.split cword c\n    | Beg_of_str | End_of_str\n    | Start | Stop              -> ()\n    | Last_end_of_line          -> lnl := true\n    | Sem (_, r)\n    | Sem_greedy (_, r)\n    | Group (_, r) | No_group r\n    | Nest r | Pmark (_,r)     -> colorize r\n    | Case _ | No_case _\n    | Intersection _\n    | Complement _\n    | Difference _              -> assert false\n  in\n  colorize regexp;\n  !lnl\n\n(**** Compilation ****)\n\nlet rec equal x1 x2 =\n  match x1, x2 with\n    Set s1, Set s2 ->\n    s1 = s2\n  | Sequence l1, Sequence l2 ->\n    eq_list l1 l2\n  | Alternative l1, Alternative l2 ->\n    eq_list l1 l2\n  | Repeat (x1', i1, j1), Repeat (x2', i2, j2) ->\n    i1 = i2 && j1 = j2 && equal x1' x2'\n  | Beg_of_line, Beg_of_line\n  | End_of_line, End_of_line\n  | Beg_of_word, Beg_of_word\n  | End_of_word, End_of_word\n  | Not_bound, Not_bound\n  | Beg_of_str, Beg_of_str\n  | End_of_str, End_of_str\n  | Last_end_of_line, Last_end_of_line\n  | Start, Start\n  | Stop, Stop ->\n    true\n  | Sem (sem1, x1'), Sem (sem2, x2') ->\n    sem1 = sem2 && equal x1' x2'\n  | Sem_greedy (k1, x1'), Sem_greedy (k2, x2') ->\n    k1 = k2 && equal x1' x2'\n  | Group _, Group _ -> (* Do not merge groups! *)\n    false\n  | No_group x1', No_group x2' ->\n    equal x1' x2'\n  | Nest x1', Nest x2' ->\n    equal x1' x2'\n  | Case x1', Case x2' ->\n    equal x1' x2'\n  | No_case x1', No_case x2' ->\n    equal x1' x2'\n  | Intersection l1, Intersection l2 ->\n    eq_list l1 l2\n  | Complement l1, Complement l2 ->\n    eq_list l1 l2\n  | Difference (x1', x1''), Difference (x2', x2'') ->\n    equal x1' x2' && equal x1'' x2''\n  | Pmark (m1, r1), Pmark (m2, r2) ->\n    Pmark.equal m1 m2 && equal r1 r2\n  | _ ->\n    false\n\nand eq_list l1 l2 =\n  match l1, l2 with\n    [], [] ->\n    true\n  | x1 :: r1, x2 :: r2 ->\n    equal x1 x2 && eq_list r1 r2\n  | _ ->\n    false\n\nlet sequence = function\n  | [x] -> x\n  | l   -> Sequence l\n\nlet rec merge_sequences = function\n  | [] ->\n    []\n  | Alternative l' :: r ->\n    merge_sequences (l' @ r)\n  | Sequence (x :: y) :: r ->\n    begin match merge_sequences r with\n        Sequence (x' :: y') :: r' when equal x x' ->\n        Sequence [x; Alternative [sequence y; sequence y']] :: r'\n      | r' ->\n        Sequence (x :: y) :: r'\n    end\n  | x :: r ->\n    x :: merge_sequences r\n\nmodule A = Automata\n\nlet enforce_kind ids kind kind' cr =\n  match kind, kind' with\n    `First, `First -> cr\n  | `First, k       -> A.seq ids k cr (A.eps ids)\n  |  _               -> cr\n\n(* XXX should probably compute a category mask *)\nlet rec translate ids kind ign_group ign_case greedy pos names cache c = function\n  | Set s ->\n    (A.cst ids (trans_set cache c s), kind)\n  | Sequence l ->\n    (trans_seq ids kind ign_group ign_case greedy pos names cache c l, kind)\n  | Alternative l ->\n    begin match merge_sequences l with\n        [r'] ->\n        let (cr, kind') =\n          translate ids kind ign_group ign_case greedy pos names cache c r' in\n        (enforce_kind ids kind kind' cr, kind)\n      | merged_sequences ->\n        (A.alt ids\n           (List.map\n              (fun r' ->\n                 let (cr, kind') =\n                   translate ids kind ign_group ign_case greedy\n                     pos names cache c r' in\n                 enforce_kind ids kind kind' cr)\n              merged_sequences),\n         kind)\n    end\n  | Repeat (r', i, j) ->\n    let (cr, kind') =\n      translate ids kind ign_group ign_case greedy pos names cache c r' in\n    let rem =\n      match j with\n        None ->\n        A.rep ids greedy kind' cr\n      | Some j ->\n        let f =\n          match greedy with\n            `Greedy ->\n            fun rem ->\n              A.alt ids\n                [A.seq ids kind' (A.rename ids cr) rem; A.eps ids]\n          | `Non_greedy ->\n            fun rem ->\n              A.alt ids\n                [A.eps ids; A.seq ids kind' (A.rename ids cr) rem]\n        in\n        iter (j - i) f (A.eps ids)\n    in\n    (iter i (fun rem -> A.seq ids kind' (A.rename ids cr) rem) rem, kind)\n  | Beg_of_line ->\n    (A.after ids Category.(inexistant ++ newline), kind)\n  | End_of_line ->\n    (A.before ids Category.(inexistant ++ newline), kind)\n  | Beg_of_word ->\n    (A.seq ids `First\n       (A.after ids Category.(inexistant ++ not_letter))\n       (A.before ids Category.letter),\n     kind)\n  | End_of_word ->\n    (A.seq ids `First\n       (A.after ids Category.letter)\n       (A.before ids Category.(inexistant ++ not_letter)),\n     kind)\n  | Not_bound ->\n    (A.alt ids [A.seq ids `First\n                  (A.after ids Category.letter)\n                  (A.before ids Category.letter);\n                A.seq ids `First\n                  (A.after ids Category.(inexistant ++ not_letter))\n                  (A.before ids Category.(inexistant ++ not_letter))],\n     kind)\n  | Beg_of_str ->\n    (A.after ids Category.inexistant, kind)\n  | End_of_str ->\n    (A.before ids Category.inexistant, kind)\n  | Last_end_of_line ->\n    (A.before ids Category.(inexistant ++ lastnewline), kind)\n  | Start ->\n    (A.after ids Category.search_boundary, kind)\n  | Stop ->\n    (A.before ids Category.search_boundary, kind)\n  | Sem (kind', r') ->\n    let (cr, kind'') =\n      translate ids kind' ign_group ign_case greedy pos names cache c r' in\n    (enforce_kind ids kind' kind'' cr,\n     kind')\n  | Sem_greedy (greedy', r') ->\n    translate ids kind ign_group ign_case greedy' pos names cache c r'\n  | Group (n, r') ->\n    if ign_group then\n      translate ids kind ign_group ign_case greedy pos names cache c r'\n    else\n      let p = !pos in\n      let () =\n        match n with\n        | Some name -> names := (name, p / 2) :: !names\n        | None -> ()\n      in\n      pos := !pos + 2;\n      let (cr, kind') =\n        translate ids kind ign_group ign_case greedy pos names cache c r' in\n      (A.seq ids `First (A.mark ids p) (\n          A.seq ids `First cr (A.mark ids (p + 1))),\n       kind')\n  | No_group r' ->\n    translate ids kind true ign_case greedy pos names cache c r'\n  | Nest r' ->\n    let b = !pos in\n    let (cr, kind') =\n      translate ids kind ign_group ign_case greedy pos names cache c r'\n    in\n    let e = !pos - 1 in\n    if e < b then\n      (cr, kind')\n    else\n      (A.seq ids `First (A.erase ids b e) cr, kind')\n  | Difference _ | Complement _ | Intersection _ | No_case _ | Case _ ->\n    assert false\n  | Pmark (i, r') ->\n    let (cr, kind') =\n      translate ids kind ign_group ign_case greedy pos names cache c r' in\n    (A.seq ids `First (A.pmark ids i) cr, kind')\n\nand trans_seq ids kind ign_group ign_case greedy pos names cache c = function\n  | [] ->\n    A.eps ids\n  | [r] ->\n    let (cr', kind') =\n      translate ids kind ign_group ign_case greedy pos names cache c r in\n    enforce_kind ids kind kind' cr'\n  | r :: rem ->\n    let (cr', kind') =\n      translate ids kind ign_group ign_case greedy pos names cache c r in\n    let cr'' =\n      trans_seq ids kind ign_group ign_case greedy pos names cache c rem in\n    if A.is_eps cr'' then\n      cr'\n    else if A.is_eps cr' then\n      cr''\n    else\n      A.seq ids kind' cr' cr''\n\n(**** Case ****)\n\nlet case_insens s =\n  Cset.union s (Cset.union (Cset.offset 32 (Cset.inter s cupper))\n                  (Cset.offset (-32) (Cset.inter s clower)))\n\nlet as_set = function\n  | Set s -> s\n  | _     -> assert false\n\n(* XXX Should split alternatives into (1) charsets and (2) more\n   complex regular expressions; alternative should therefore probably\n   be flatten here *)\nlet rec handle_case ign_case = function\n  | Set s ->\n    Set (if ign_case then case_insens s else s)\n  | Sequence l ->\n    Sequence (List.map (handle_case ign_case) l)\n  | Alternative l ->\n    let l' = List.map (handle_case ign_case) l in\n    if is_charset (Alternative l') then\n      Set (List.fold_left (fun s r -> Cset.union s (as_set r)) Cset.empty l')\n    else\n      Alternative l'\n  | Repeat (r, i, j) ->\n    Repeat (handle_case ign_case r, i, j)\n  | Beg_of_line | End_of_line | Beg_of_word | End_of_word | Not_bound\n  | Beg_of_str | End_of_str | Last_end_of_line | Start | Stop as r ->\n    r\n  | Sem (k, r) ->\n    let r' = handle_case ign_case r in\n    if is_charset r' then r' else Sem (k, r')\n  | Sem_greedy (k, r) ->\n    let r' = handle_case ign_case r in\n    if is_charset r' then r' else Sem_greedy (k, r')\n  | Group (n, r) ->\n    Group (n, handle_case ign_case r)\n  | No_group r ->\n    let r' = handle_case ign_case r in\n    if is_charset r' then r' else No_group r'\n  | Nest r ->\n    let r' = handle_case ign_case r in\n    if is_charset r' then r' else Nest r'\n  | Case r ->\n    handle_case false r\n  | No_case r ->\n    handle_case true r\n  | Intersection l ->\n    let l' = List.map (fun r -> handle_case ign_case r) l in\n    Set (List.fold_left (fun s r -> Cset.inter s (as_set r)) Cset.cany l')\n  | Complement l ->\n    let l' = List.map (fun r -> handle_case ign_case r) l in\n    Set (Cset.diff Cset.cany\n           (List.fold_left (fun s r -> Cset.union s (as_set r))\n              Cset.empty l'))\n  | Difference (r, r') ->\n    Set (Cset.inter (as_set (handle_case ign_case r))\n           (Cset.diff Cset.cany (as_set (handle_case ign_case r'))))\n  | Pmark (i,r) -> Pmark (i,handle_case ign_case r)\n\n(****)\n\nlet compile_1 regexp =\n  let regexp = handle_case false regexp in\n  let c = Color_map.make () in\n  let need_lnl = colorize c regexp in\n  let (colors, color_repr, ncolor) = Color_map.flatten c in\n  let lnl = if need_lnl then ncolor else -1 in\n  let ncolor = if need_lnl then ncolor + 1 else ncolor in\n  let ids = A.create_ids () in\n  let pos = ref 0 in\n  let names = ref [] in\n  let (r, kind) =\n    translate ids\n      `First false false `Greedy pos names (ref Cset.CSetMap.empty) colors regexp in\n  let r = enforce_kind ids `First kind r in\n  (*Format.eprintf \"<%d %d>@.\" !ids ncol;*)\n  mk_re ~initial:r ~colors ~color_repr ~ncolor ~lnl ~group_names:(List.rev !names) ~group_count:(!pos / 2)\n\n(****)\n\nlet rec anchored = function\n  | Sequence l ->\n    List.exists anchored l\n  | Alternative l ->\n    List.for_all anchored l\n  | Repeat (r, i, _) ->\n    i > 0 && anchored r\n  | Set _ | Beg_of_line | End_of_line | Beg_of_word | End_of_word\n  | Not_bound | End_of_str | Last_end_of_line | Stop\n  | Intersection _ | Complement _ | Difference _ ->\n    false\n  | Beg_of_str | Start ->\n    true\n  | Sem (_, r) | Sem_greedy (_, r) | Group (_, r) | No_group r | Nest r\n  | Case r | No_case r | Pmark (_, r) ->\n    anchored r\n\n(****)\n\ntype t = regexp\n\nlet str s =\n  let l = ref [] in\n  for i = String.length s - 1 downto 0 do\n    l := Set (Cset.csingle s.[i]) :: !l\n  done;\n  Sequence !l\nlet char c = Set (Cset.csingle c)\n\nlet alt = function\n  | [r] -> r\n  | l   -> Alternative l\nlet seq = function\n  | [r] -> r\n  | l   -> Sequence l\n\nlet empty = alt []\nlet epsilon = seq []\nlet repn r i j =\n  if i < 0 then invalid_arg \"Re.repn\";\n  begin match j with\n    | Some j when j < i -> invalid_arg \"Re.repn\"\n    | _ -> ()\n  end;\n  Repeat (r, i, j)\nlet rep r = repn r 0 None\nlet rep1 r = repn r 1 None\nlet opt r = repn r 0 (Some 1)\nlet bol = Beg_of_line\nlet eol = End_of_line\nlet bow = Beg_of_word\nlet eow = End_of_word\nlet word r = seq [bow; r; eow]\nlet not_boundary = Not_bound\nlet bos = Beg_of_str\nlet eos = End_of_str\nlet whole_string r = seq [bos; r; eos]\nlet leol = Last_end_of_line\nlet start = Start\nlet stop = Stop\nlet longest r = Sem (`Longest, r)\nlet shortest r = Sem (`Shortest, r)\nlet first r = Sem (`First, r)\nlet greedy r = Sem_greedy (`Greedy, r)\nlet non_greedy r = Sem_greedy (`Non_greedy, r)\nlet group ?name r = Group (name, r)\nlet no_group r = No_group r\nlet nest r = Nest r\nlet mark r = let i = Pmark.gen () in (i,Pmark (i,r))\n\nlet set str =\n  let s = ref Cset.empty in\n  for i = 0 to String.length str - 1 do\n    s := Cset.union (Cset.csingle str.[i]) !s\n  done;\n  Set !s\n\nlet rg c c' = Set (cseq c c')\n\nlet inter l =\n  let r = Intersection l in\n  if is_charset r then\n    r\n  else\n    invalid_arg \"Re.inter\"\n\nlet compl l =\n  let r = Complement l in\n  if is_charset r then\n    r\n  else\n    invalid_arg \"Re.compl\"\n\nlet diff r r' =\n  let r'' = Difference (r, r') in\n  if is_charset r'' then\n    r''\n  else\n    invalid_arg \"Re.diff\"\n\nlet any = Set Cset.cany\nlet notnl = Set (Cset.diff Cset.cany (Cset.csingle '\\n'))\n\nlet lower = alt [rg 'a' 'z'; char '\\181'; rg '\\223' '\\246'; rg '\\248' '\\255']\nlet upper = alt [rg 'A' 'Z'; rg '\\192' '\\214'; rg '\\216' '\\222']\nlet alpha = alt [lower; upper; char '\\170'; char '\\186']\nlet digit = rg '0' '9'\nlet alnum = alt [alpha; digit]\nlet wordc = alt [alnum; char '_']\nlet ascii = rg '\\000' '\\127'\nlet blank = set \"\\t \"\nlet cntrl = alt [rg '\\000' '\\031'; rg '\\127' '\\159']\nlet graph = alt [rg '\\033' '\\126'; rg '\\160' '\\255']\nlet print = alt [rg '\\032' '\\126'; rg '\\160' '\\255']\nlet punct =\n  alt [rg '\\033' '\\047'; rg '\\058' '\\064'; rg '\\091' '\\096';\n       rg '\\123' '\\126'; rg '\\160' '\\169'; rg '\\171' '\\180';\n       rg '\\182' '\\185'; rg '\\187' '\\191'; char '\\215'; char '\\247']\nlet space = alt [char ' '; rg '\\009' '\\013']\nlet xdigit = alt [digit; rg 'a' 'f'; rg 'A' 'F']\n\nlet case r = Case r\nlet no_case r = No_case r\n\n(****)\n\nlet compile r =\n  compile_1 (\n    if anchored r then\n      group r\n    else\n      seq [shortest (rep any); group r]\n  )\n\nlet exec_internal name ?(pos=0) ?(len = -1) ~partial ~groups re s =\n  if pos < 0 || len < -1 || pos + len > String.length s then\n    invalid_arg name;\n  match_str ~groups ~partial re s ~pos ~len\n\nlet exec ?pos ?len re s =\n  match exec_internal \"Re.exec\" ?pos ?len ~groups:true ~partial:false re s with\n    Match substr -> substr\n  | _            -> raise Not_found\n\nlet exec_opt ?pos ?len re s =\n  match exec_internal \"Re.exec_opt\" ?pos ?len ~groups:true ~partial:false\n          re s with\n    Match substr -> Some substr\n  | _            -> None\n\nlet execp ?pos ?len re s =\n  match exec_internal ~groups:false ~partial:false \"Re.execp\" ?pos ?len re s with\n    Match _substr -> true\n  | _             -> false\n\nlet exec_partial ?pos ?len re s =\n  match exec_internal ~groups:false ~partial:true \"Re.exec_partial\"\n          ?pos ?len re s with\n    Match _ -> `Full\n  | Running _ -> `Partial\n  | Failed  -> `Mismatch\n\nlet exec_partial_detailed ?pos ?len re s =\n  match exec_internal ~groups:true ~partial:true \"Re.exec_partial_detailed\"\n          ?pos ?len re s with\n    Match group -> `Full group\n  | Running { no_match_starts_before } -> `Partial no_match_starts_before\n  | Failed  -> `Mismatch\n\nmodule Mark = struct\n\n  type t = Pmark.t\n\n  let test (g : Group.t) p =\n    Pmark.Set.mem p g.pmarks\n\n  let all (g : Group.t) = g.pmarks\n\n  module Set = Pmark.Set\n\n  let equal = Pmark.equal\n\n  let compare = Pmark.compare\n\nend\n\ntype split_token =\n  [ `Text of string\n  | `Delim of Group.t\n  ]\n\nmodule Rseq = struct\n  let all ?(pos=0) ?len re s : _ Seq.t =\n    if pos < 0 then invalid_arg \"Re.all\";\n    (* index of the first position we do not consider.\n       !pos < limit is an invariant *)\n    let limit = match len with\n      | None -> String.length s\n      | Some l ->\n        if l<0 || pos+l > String.length s then invalid_arg \"Re.all\";\n        pos+l\n    in\n    (* iterate on matches. When a match is found, search for the next\n       one just after its end *)\n    let rec aux pos () =\n      if pos >= limit\n      then Seq.Nil (* no more matches *)\n      else\n        match match_str ~groups:true ~partial:false re s\n                ~pos ~len:(limit - pos) with\n        | Match substr ->\n          let p1, p2 = Group.offset substr 0 in\n          let pos = if p1=p2 then p2+1 else p2 in\n          Seq.Cons (substr, aux pos)\n        | Running _\n        | Failed -> Seq.Nil\n    in\n    aux pos\n\n  let matches ?pos ?len re s : _ Seq.t =\n    all ?pos ?len re s\n    |> Seq.map (fun sub -> Group.get sub 0)\n\n  let split_full ?(pos=0) ?len re s : _ Seq.t =\n    if pos < 0 then invalid_arg \"Re.split\";\n    let limit = match len with\n      | None -> String.length s\n      | Some l ->\n        if l<0 || pos+l > String.length s then invalid_arg \"Re.split\";\n        pos+l\n    in\n    (* i: start of delimited string\n       pos: first position after last match of [re]\n       limit: first index we ignore (!pos < limit is an invariant) *)\n    let pos0 = pos in\n    let rec aux state i pos () = match state with\n      | `Idle when pos >= limit ->\n        if i < limit then (\n          let sub = String.sub s i (limit - i) in\n          Seq.Cons (`Text sub, aux state (i+1) pos)\n        ) else Seq.Nil\n      | `Idle ->\n        begin match match_str ~groups:true ~partial:false re s ~pos\n                      ~len:(limit - pos) with\n        | Match substr ->\n          let p1, p2 = Group.offset substr 0 in\n          let pos = if p1=p2 then p2+1 else p2 in\n          let old_i = i in\n          let i = p2 in\n          if p1 > pos0 then (\n            (* string does not start by a delimiter *)\n            let text = String.sub s old_i (p1 - old_i) in\n            let state = `Yield (`Delim substr) in\n            Seq.Cons (`Text text, aux state i pos)\n          ) else Seq.Cons (`Delim substr, aux state i pos)\n        | Running _ -> Seq.Nil\n        | Failed ->\n          if i < limit\n          then (\n            let text = String.sub s i (limit - i) in\n            (* yield last string *)\n            Seq.Cons (`Text text, aux state limit pos)\n          ) else\n            Seq.Nil\n        end\n      | `Yield x ->\n        Seq.Cons (x, aux `Idle i pos)\n    in\n    aux `Idle pos pos\n\n  let split ?pos ?len re s : _ Seq.t =\n    let seq = split_full ?pos ?len re s in\n    let rec filter seq () = match seq ()  with\n      | Seq.Nil -> Seq.Nil\n      | Seq.Cons (`Delim _, tl) -> filter tl ()\n      | Seq.Cons (`Text s,tl) -> Seq.Cons (s, filter tl)\n    in filter seq\nend\n\nmodule Rlist = struct\n  let list_of_seq (s:'a Seq.t) : 'a list =\n    Seq.fold_left (fun l x -> x :: l) [] s |> List.rev\n\n  let all ?pos ?len re s = Rseq.all ?pos ?len re s |> list_of_seq\n\n  let matches ?pos ?len re s = Rseq.matches ?pos ?len re s |> list_of_seq\n\n  let split_full ?pos ?len re s = Rseq.split_full ?pos ?len re s |> list_of_seq\n\n  let split ?pos ?len re s = Rseq.split ?pos ?len re s |> list_of_seq\nend\n\nmodule Gen = struct\n  type 'a gen = unit -> 'a option\n  let gen_of_seq (s:'a Seq.t) : 'a gen =\n    let r = ref s in\n    fun () -> match !r () with\n      | Seq.Nil -> None\n      | Seq.Cons (x, tl) ->\n        r := tl;\n        Some x\n\n  let split ?pos ?len re s : _ gen =\n    Rseq.split ?pos ?len re s |> gen_of_seq\n\n  let split_full ?pos ?len re s : _ gen =\n    Rseq.split_full ?pos ?len re s |> gen_of_seq\n\n  let all ?pos ?len re s = Rseq.all ?pos ?len re s |> gen_of_seq\n\n  let matches ?pos ?len re s = Rseq.matches ?pos ?len re s |> gen_of_seq\nend\n\nlet replace ?(pos=0) ?len ?(all=true) re ~f s =\n  if pos < 0 then invalid_arg \"Re.replace\";\n  let limit = match len with\n    | None -> String.length s\n    | Some l ->\n      if l<0 || pos+l > String.length s then invalid_arg \"Re.replace\";\n      pos+l\n  in\n  (* buffer into which we write the result *)\n  let buf = Buffer.create (String.length s) in\n  (* iterate on matched substrings. *)\n  let rec iter pos =\n    if pos < limit\n    then\n      match match_str ~groups:true ~partial:false re s ~pos ~len:(limit-pos) with\n      | Match substr ->\n        let p1, p2 = Group.offset substr 0 in\n        (* add string between previous match and current match *)\n        Buffer.add_substring buf s pos (p1-pos);\n        (* what should we replace the matched group with? *)\n        let replacing = f substr in\n        Buffer.add_string buf replacing;\n        if all then\n          (* if we matched a non-char e.g. ^ we must manually advance by 1 *)\n          iter (\n            if p1=p2 then (\n              (* a non char could be past the end of string. e.g. $ *)\n              if p2 < limit then Buffer.add_char buf s.[p2];\n              p2+1\n            ) else\n              p2)\n        else\n          Buffer.add_substring buf s p2 (limit-p2)\n      | Running _ -> ()\n      | Failed ->\n        Buffer.add_substring buf s pos (limit-pos)\n  in\n  iter pos;\n  Buffer.contents buf\n\nlet replace_string ?pos ?len ?all re ~by s =\n  replace ?pos ?len ?all re s ~f:(fun _ -> by)\n\nlet witness t =\n  let rec witness = function\n    | Set c -> String.make 1 (Char.chr (Cset.pick c))\n    | Sequence xs -> String.concat \"\" (List.map witness xs)\n    | Alternative (x :: _) -> witness x\n    | Alternative [] -> assert false\n    | Repeat (r, from, _to) ->\n      let w = witness r in\n      let b = Buffer.create (String.length w * from) in\n      for _i=1 to from do\n        Buffer.add_string b w\n      done;\n      Buffer.contents b\n    | No_case r -> witness r\n    | Intersection _\n    | Complement _\n    | Difference (_, _) -> assert false\n    | Group (_, r)\n    | No_group r\n    | Nest r\n    | Sem (_, r)\n    | Pmark (_, r)\n    | Case r\n    | Sem_greedy (_, r) -> witness r\n    | Beg_of_line\n    | End_of_line\n    | Beg_of_word\n    | End_of_word\n    | Not_bound\n    | Beg_of_str\n    | Last_end_of_line\n    | Start\n    | Stop\n    | End_of_str -> \"\" in\n  witness (handle_case false t)\n\nmodule Seq = Rseq\nmodule List = Rlist\nmodule Group = Group\n\n(** {2 Deprecated functions} *)\n\nlet split_full_seq = Seq.split_full\nlet split_seq = Seq.split\nlet matches_seq = Seq.matches\nlet all_seq = Seq.all\n\ntype 'a gen        = 'a Gen.gen\nlet all_gen        = Gen.all\nlet matches_gen    = Gen.matches\nlet split_gen      = Gen.split\nlet split_full_gen = Gen.split_full\n\n\ntype substrings = Group.t\n\nlet get = Group.get\nlet get_ofs = Group.offset\nlet get_all = Group.all\nlet get_all_ofs = Group.all_offset\nlet test = Group.test\n\ntype markid = Mark.t\n\nlet marked = Mark.test\nlet mark_set = Mark.all\n\n(**********************************)\n\n(*\nInformation about the previous character:\n- does not exists\n- is a letter\n- is not a letter\n- is a newline\n- is last newline\n\nBeginning of word:\n- previous is not a letter or does not exist\n- current is a letter or does not exist\n\nEnd of word:\n- previous is a letter or does not exist\n- current is not a letter or does not exist\n\nBeginning of line:\n- previous is a newline or does not exist\n\nBeginning of buffer:\n- previous does not exist\n\nEnd of buffer\n- current does not exist\n\nEnd of line\n- current is a newline or does not exist\n*)\n\n(*\nRep: e = T,e | ()\n  - semantics of the comma (shortest/longest/first)\n  - semantics of the union (greedy/non-greedy)\n\nBounded repetition\n  a{0,3} = (a,(a,a?)?)?\n*)\n\ntype groups = Group.t\n\ninclude Rlist\n","(* TyXML\n * http://www.ocsigen.org/tyxml\n * Copyright (C) 2013 Gabriel Radanne <drupyog+caml@zoho.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1301, USA.\n*)\n\nmodule type T = sig\n  type 'a t\n  val return : 'a -> 'a t\n\n  type (-'a, 'b) ft\n  val fmap : ('a, 'b) ft -> 'a t -> 'b t\n\n  type 'a tlist\n  val nil : unit -> 'a tlist\n  val singleton : 'a t -> 'a tlist\n  val cons : 'a t -> 'a tlist -> 'a tlist\n  val append : 'a tlist -> 'a tlist -> 'a tlist\n  val map : ('a, 'b) ft -> 'a tlist -> 'b tlist\nend\n\nmodule type NoWrap =\n  T with type 'a t = 'a\n     and type 'a tlist = 'a list\n     and type (-'a, 'b) ft = 'a -> 'b\n\nmodule NoWrap = struct\n  type 'a t = 'a\n  type 'a tlist = 'a list\n  type (-'a, 'b) ft = 'a -> 'b\n  external return : 'a -> 'a = \"%identity\"\n  let fmap f :  'a t -> 'b t = f\n\n  let nil () = []\n  let singleton x = [x]\n  let cons x xs = x::xs\n  let append x y= x@y\n  let map = List.map\nend\n","(* TyXML\n * http://www.ocsigen.org/tyxml\n * Copyright (C) 2008 Vincent Balat, Mauricio Fernandez\n * Copyright (C) 2011 Pierre Chambart, Grégoire Henry\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1301, USA.\n*)\n\nlet is_control c =\n  let cc = Char.code c in\n  (cc <= 8 || cc = 11 || cc = 12 || (14 <= cc && cc <= 31) || cc = 127)\n\nlet add_unsafe_char b = function\n  | '<' -> Buffer.add_string b \"&lt;\"\n  | '>' -> Buffer.add_string b \"&gt;\"\n  | '\"' -> Buffer.add_string b \"&quot;\"\n  | '&' -> Buffer.add_string b \"&amp;\"\n  | c when is_control c ->\n    Buffer.add_string b \"&#\" ;\n    Buffer.add_string b (string_of_int (Char.code c)) ;\n    Buffer.add_string b \";\"\n  | c -> Buffer.add_char b c\n\nlet encode_unsafe_char s =\n  let b = Buffer.create (String.length s) in\n  String.iter (add_unsafe_char b) s;\n  Buffer.contents b\n\nlet encode_unsafe_char_and_at s =\n  let b = Buffer.create (String.length s) in\n  let f = function\n    | '@' -> Buffer.add_string b \"&#64;\"\n    | c -> add_unsafe_char b c\n  in\n  String.iter f s;\n  Buffer.contents b\n\nlet compose_decl ?(version = \"1.0\") ?(encoding = \"UTF-8\") () =\n  Format.sprintf\n    {|<?xml version=\"%s\" encoding=\"%s\"?>\\n|}\n    version encoding\n\nlet compose_doctype dt args =\n  let pp_args fmt = function\n    | [] -> ()\n    | l ->\n      Format.fprintf fmt \" PUBLIC %a\"\n        (Format.pp_print_list ~pp_sep:Format.pp_print_space\n           (fun fmt -> Format.fprintf fmt \"\\\"%s\\\"\"))\n        l\n  in\n  Format.asprintf\n    \"<!DOCTYPE %s%a>\"\n    dt\n    pp_args args\n\nlet re_end_comment = Re.(compile @@ alt [\n  seq [ bos ; str \">\" ] ;\n  seq [ bos ; str \"->\" ] ;\n  str \"-->\" ;\n  str \"--!>\" ;\n])\nlet escape_comment s =\n  let f g = match Re.Group.get g 0 with\n    | \">\" -> \"&gt;\"\n    | \"->\" -> \"-&gt;\"\n    | \"-->\" -> \"--&gt;\"\n    | \"--!>\" -> \"--!&gt;\"\n    | s -> s\n  in\n  Re.replace ~all:true re_end_comment ~f s\n\n(* copied form js_of_ocaml: compiler/javascript.ml *)\nlet pp_number fmt v =\n  if v = infinity\n  then Format.pp_print_string fmt \"Infinity\"\n  else if v = neg_infinity\n  then Format.pp_print_string fmt \"-Infinity\"\n  else if v <> v\n  then Format.pp_print_string fmt \"NaN\"\n  else\n    let vint = int_of_float v in\n    (* compiler 1000 into 1e3 *)\n    if float_of_int vint = v\n    then\n      let rec div n i =\n        if n <> 0 && n mod 10 = 0\n        then div (n/10) (succ i)\n        else\n        if i > 2\n        then Format.fprintf fmt \"%de%d\" n i\n        else Format.pp_print_int fmt vint in\n      div vint 0\n    else\n      let s1 = Printf.sprintf \"%.12g\" v in\n      if v = float_of_string s1\n      then Format.pp_print_string fmt s1\n      else\n        let s2 = Printf.sprintf \"%.15g\" v in\n        if v = float_of_string s2\n        then Format.pp_print_string fmt s2\n        else  Format.fprintf fmt \"%.18g\" v\n\nlet string_of_number v =\n  Format.asprintf \"%a\" pp_number v\n\nmodule Utf8 = struct\n  type utf8 = string\n\n  let normalize src =\n    let warn = ref false in\n    let buffer = Buffer.create (String.length src) in\n    Uutf.String.fold_utf_8\n      (fun _ _ d ->\n         match d with\n         | `Uchar code -> Uutf.Buffer.add_utf_8 buffer code\n         | `Malformed _ ->\n               Uutf.Buffer.add_utf_8 buffer Uutf.u_rep;\n               warn:=true)\n      () src;\n    (Buffer.contents buffer, !warn)\n\n  let normalization_needed src =\n    let rec loop src i l =\n      i < l &&\n      match src.[i] with\n      (* Characters that need to be encoded in HTML *)\n      | '\\034' | '\\038' | '\\060' |'\\062' ->\n          true\n      (* ASCII characters *)\n      | '\\009' | '\\010' | '\\013' | '\\032'..'\\126' ->\n          loop src (i + 1) l\n      | _ ->\n          true\n    in\n    loop src 0 (String.length src)\n\n  let normalize_html src =\n    if normalization_needed src then begin\n      let warn = ref false in\n      let buffer = Buffer.create (String.length src) in\n      Uutf.String.fold_utf_8\n        (fun _ _ d ->\n           match d with\n           | `Uchar u ->\n               begin match Uchar.to_int u with\n               | 34 ->\n                   Buffer.add_string buffer \"&quot;\"\n               | 38 ->\n                   Buffer.add_string buffer \"&amp;\"\n               | 60 ->\n                   Buffer.add_string buffer \"&lt;\"\n               | 62 ->\n                   Buffer.add_string buffer \"&gt;\"\n               | code ->\n                   let u =\n                     (* Illegal characters in html\n                        http://en.wikipedia.org/wiki/Character_encodings_in_HTML\n                        http://www.w3.org/TR/html5/syntax.html *)\n                     if (* A. control C0 *)\n                       (code <= 31 && code <> 9 && code <> 10 && code <> 13)\n                       (* B. DEL + control C1\n                          - invalid in html\n                          - discouraged in xml;\n                          except 0x85 see http://www.w3.org/TR/newline\n                          but let's discard it anyway *)\n                       || (code >= 127 && code <= 159)\n                       (* C. UTF-16 surrogate halves : already discarded\n                          by uutf || (code >= 0xD800 && code <= 0xDFFF) *)\n                       (* D. BOM related *)\n                       || code land 0xFFFF = 0xFFFE\n                       || code land 0xFFFF = 0xFFFF\n                     then (warn:=true; Uutf.u_rep)\n                     else u\n                   in\n                   Uutf.Buffer.add_utf_8 buffer u\n               end\n           | `Malformed _ ->\n               Uutf.Buffer.add_utf_8 buffer Uutf.u_rep;\n               warn:=true)\n        () src;\n      (Buffer.contents buffer, !warn)\n    end else\n      (src, false)\n\nend\n\nmodule type TagList = sig val emptytags : string list end\n\n(** Format based printers *)\n\nlet pp_noop _fmt _ = ()\n\nmodule Make_fmt\n    (Xml : Xml_sigs.Iterable)\n    (I : TagList) =\nstruct\n  open Xml\n\n  let open_box indent fmt = if indent then Format.pp_open_box fmt 0 else ()\n  let close_box indent fmt = if indent then Format.pp_close_box fmt () else ()\n  let sp indent fmt =\n    if indent then Format.pp_print_space fmt () else Format.pp_print_string fmt \" \"\n  let cut indent fmt =\n    if indent then Format.pp_print_cut fmt () else ()\n\n  module S = Set.Make(String)\n  let is_emptytag = match I.emptytags with\n    | [] -> fun _ -> false\n    | l ->\n      let set = List.fold_left (fun s x -> S.add x s) S.empty l in\n      fun x -> S.mem x set\n\n  let pp_encode encode indent fmt s =\n    let s = encode s in\n    if indent then\n      Format.fprintf fmt \"@[%a@]\" Format.pp_print_text s\n    else\n      Format.pp_print_string fmt s\n\n  let pp_sep indent = function\n    | Space -> fun fmt () -> sp indent fmt\n    | Comma -> fun fmt () -> Format.fprintf fmt \",%t\" (sp indent)\n\n  let pp_attrib_value encode indent fmt a = match acontent a with\n    | AFloat f -> Format.fprintf fmt \"\\\"%a\\\"\" pp_number f\n    | AInt i -> Format.fprintf fmt \"\\\"%d\\\"\" i\n    | AStr s -> Format.fprintf fmt \"\\\"%s\\\"\" (encode s)\n    | AStrL (sep, slist) ->\n      Format.fprintf fmt \"\\\"%a\\\"\"\n        (Format.pp_print_list ~pp_sep:(pp_sep indent sep)\n           (pp_encode encode indent)) slist\n\n  let pp_attrib encode indent fmt a =\n    Format.fprintf fmt\n      \"%t%s=%a\" (sp indent) (aname a) (pp_attrib_value encode indent) a\n\n  let pp_attribs encode indent =\n    Format.pp_print_list ~pp_sep:pp_noop (pp_attrib encode indent)\n\n  let pp_tag_and_attribs encode indent fmt (tag, attrs) =\n    open_box indent fmt ;\n    Format.fprintf fmt \"%s%a%t\" tag (pp_attribs encode indent) attrs (cut indent);\n    close_box indent fmt\n\n  let pp_closedtag encode indent fmt tag attrs =\n    if is_emptytag tag then\n      Format.fprintf fmt \"<%a/>\" (pp_tag_and_attribs encode indent) (tag, attrs)\n    else begin\n      open_box indent fmt ;\n      Format.fprintf fmt \"<%a>%t</%s>\"\n        (pp_tag_and_attribs encode indent) (tag, attrs)\n        (cut indent)\n        tag ;\n      close_box indent fmt\n    end\n\n  let rec pp_tag encode indent fmt tag attrs children =\n    match children with\n    | [] -> pp_closedtag encode indent fmt tag attrs\n    | _ ->\n      open_box indent fmt ;\n      Format.fprintf fmt \"<%t%a>%t%a%t%t</%s>\"\n        (open_box indent)\n        (pp_tag_and_attribs encode indent) (tag, attrs)\n        (cut indent)\n        (pp_elts encode indent) children\n        (close_box indent)\n        (cut indent)\n        tag ;\n      close_box indent fmt\n\n  and pp_elt encode indent fmt elt = match content elt with\n    | Comment texte ->\n      Format.fprintf fmt \"<!--%s-->\" (escape_comment texte)\n\n    | Entity e ->\n      Format.fprintf fmt \"&%s;\" e\n\n    | PCDATA texte ->\n      pp_encode encode indent fmt texte\n\n    | EncodedPCDATA texte ->\n      Format.pp_print_string fmt texte\n\n    | Node (name, xh_attrs, xh_taglist) ->\n      pp_tag encode indent fmt name xh_attrs xh_taglist\n\n    | Leaf (name, xh_attrs) ->\n      pp_closedtag encode indent fmt name xh_attrs\n\n    | Empty -> ()\n\n  and pp_elts encode indent =\n    Format.pp_print_list\n      ~pp_sep:(fun fmt () -> cut indent fmt)\n      (pp_elt encode indent)\n\n  let pp ?(encode=encode_unsafe_char) ?(indent=false) () =\n    pp_elt encode indent\n\nend\n\nmodule Make_typed_fmt\n    (Xml : Xml_sigs.Iterable)\n    (Typed_xml : Xml_sigs.Typed_xml with module Xml := Xml) =\nstruct\n\n  module P = Make_fmt(Xml)(Typed_xml.Info)\n\n  (* Add an xmlns tag on the html element if it's not already present *)\n  let prepare_document doc =\n    let doc = Typed_xml.doc_toelt doc in\n    match Xml.content doc with\n    | Xml.Node (n, a, c) ->\n      let a =\n        if List.exists (fun a -> Xml.aname a = \"xmlns\") a\n        then a\n        else Xml.string_attrib \"xmlns\" Typed_xml.Info.namespace :: a\n      in\n      Xml.node ~a n c\n    | _ -> doc\n\n  let pp_elt ?(encode=encode_unsafe_char) ?(indent=false) () fmt foret =\n    P.pp_elt encode indent fmt (Typed_xml.toelt foret)\n\n  let pp ?(encode = encode_unsafe_char) ?(indent=false) ?advert () fmt doc =\n    Format.pp_open_vbox fmt 0 ;\n    Format.fprintf fmt \"%s@,\" Typed_xml.Info.doctype ;\n\n    begin match advert with\n      | Some s -> Format.fprintf fmt \"<!-- %s -->@,\" s\n      | None -> ()\n    end ;\n\n    P.pp_elt encode indent fmt (prepare_document doc) ;\n    Format.pp_close_box fmt ();\n\nend\n\nmodule Make\n    (Xml : Xml_sigs.Iterable)\n    (I : TagList)\n    (O : Xml_sigs.Output) =\nstruct\n\n  let (++) = O.concat\n\n  open Xml\n\n  let separator_to_string = function\n    | Space -> \" \"\n    | Comma -> \", \"\n\n  let attrib_value_to_string encode a = match acontent a with\n    | AFloat f -> Printf.sprintf \"\\\"%s\\\"\" (string_of_number f)\n    | AInt i -> Printf.sprintf \"\\\"%d\\\"\" i\n    | AStr s -> Printf.sprintf \"\\\"%s\\\"\" (encode s)\n    | AStrL (sep, slist) ->\n      Printf.sprintf \"\\\"%s\\\"\"\n        (encode (String.concat (separator_to_string sep) slist))\n\n  let attrib_to_string encode a =\n    Printf.sprintf \"%s=%s\" (aname a) (attrib_value_to_string encode a)\n\n  let rec xh_print_attrs encode attrs = match attrs with\n    | [] -> O.empty\n    | attr::queue ->\n      O.put (\" \"^ attrib_to_string encode attr)\n      ++ xh_print_attrs encode queue\n\n  and xh_print_closedtag encode tag attrs =\n    if I.emptytags = [] || List.mem tag I.emptytags\n    then\n      (O.put (\"<\"^tag)\n       ++ xh_print_attrs encode attrs\n       ++ O.put \" />\")\n    else\n      (O.put (\"<\"^tag)\n       ++ xh_print_attrs encode attrs\n       ++ O.put (\"></\"^tag^\">\"))\n\n  and xh_print_tag encode tag attrs taglist =\n    if taglist = []\n    then xh_print_closedtag encode tag attrs\n    else\n      (O.put (\"<\"^tag)\n       ++ xh_print_attrs encode attrs\n       ++ O.put \">\"\n       ++ xh_print_taglist encode taglist\n       ++ O.put (\"</\"^tag^\">\"))\n\n  and print_nodes encode name xh_attrs xh_taglist queue =\n    xh_print_tag encode name xh_attrs xh_taglist\n    ++ xh_print_taglist encode queue\n\n  and xh_print_taglist encode taglist =\n    match taglist with\n\n    | [] -> O.empty\n\n    | elt :: queue -> match content elt with\n\n      | Comment texte ->\n        O.put (\"<!--\"^(encode texte)^\"-->\")\n        ++ xh_print_taglist encode queue\n\n      | Entity e ->\n        O.put (\"&\"^e^\";\") (* no encoding *)\n        ++ xh_print_taglist encode queue\n\n      | PCDATA texte ->\n        O.put (encode texte)\n        ++ xh_print_taglist encode queue\n\n      | EncodedPCDATA texte ->\n        O.put texte\n        ++ xh_print_taglist encode queue\n\n      | Node (name, xh_attrs, xh_taglist) ->\n        print_nodes encode name xh_attrs xh_taglist queue\n\n      | Leaf (name, xh_attrs) ->\n        print_nodes encode name xh_attrs [] queue\n\n      | Empty ->\n        xh_print_taglist encode queue\n\n  let print_list ?(encode = encode_unsafe_char) foret =\n    O.make (xh_print_taglist encode foret)\n\nend\n\nmodule Make_typed\n    (Xml : Xml_sigs.Iterable)\n    (Typed_xml : Xml_sigs.Typed_xml with module Xml := Xml)\n    (O : Xml_sigs.Output) =\nstruct\n\n  module P = Make(Xml)(Typed_xml.Info)(O)\n  let (++) = O.concat\n\n  let print_list ?(encode = encode_unsafe_char) foret =\n    O.make (P.xh_print_taglist encode (List.map Typed_xml.toelt foret))\n\n  let print ?(encode = encode_unsafe_char) ?(advert = \"\") doc =\n    let doc = Typed_xml.doc_toelt doc in\n    let doc = match Xml.content doc with\n      | Xml.Node (n, a, c) ->\n        let a =\n          if List.exists (fun a -> Xml.aname a = \"xmlns\") a\n          then a\n          else Xml.string_attrib \"xmlns\" Typed_xml.Info.namespace :: a\n        in\n        Xml.node ~a n c\n      | _ -> doc in\n    O.make\n      (O.put Typed_xml.Info.doctype\n       ++ O.put (if advert <> \"\" then (\"<!-- \" ^ advert ^ \" -->\\n\") else \"\\n\")\n       ++ P.xh_print_taglist encode [doc])\n\nend\n\nmodule Simple_output(M : sig val put: string -> unit end) = struct\n  type out = unit\n  type m = unit -> unit\n  let empty () = ()\n  let concat f1 f2 () = f1 (); f2 ()\n  let put s () = M.put s\n  let make f = f ()\nend\n\nmodule Make_simple\n    (Xml : Xml_sigs.Iterable)\n    (I : TagList) =\nstruct\n\n  let print_list ~output =\n    let module M = Make(Xml)(I)(Simple_output(struct let put = output end)) in\n    M.print_list\n\nend\n\nmodule Make_typed_simple\n    (Xml : Xml_sigs.Iterable)\n    (Typed_xml : Xml_sigs.Typed_xml with  module Xml := Xml) =\nstruct\n\n  let print_list ~output =\n    let module M =\n      Make_typed(Xml)(Typed_xml)(Simple_output(struct let put = output end)) in\n    M.print_list\n\n  let print ~output =\n    let module M =\n      Make_typed(Xml)(Typed_xml)(Simple_output(struct let put = output end)) in\n    M.print\n\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2014 Hugo Heuzard\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js_of_ocaml\nopen! Import\n\nlet js_string_of_float f = (Js.number_of_float f)##toString\n\nlet js_string_of_int i = (Js.number_of_float (float_of_int i))##toString\n\nmodule type XML =\n  Xml_sigs.T\n    with type uri = string\n     and type event_handler = Dom_html.event Js.t -> bool\n     and type mouse_event_handler = Dom_html.mouseEvent Js.t -> bool\n     and type keyboard_event_handler = Dom_html.keyboardEvent Js.t -> bool\n     and type elt = Dom.node Js.t\n\nclass type ['a, 'b] weakMap = object\n  method set : 'a -> 'b -> unit Js.meth\n\n  method get : 'a -> 'b Js.Optdef.t Js.meth\nend\n\nlet retain =\n  let map : (Dom.node Js.t, Obj.t Js.js_array Js.t) weakMap Js.t =\n    let weakMap = Js.Unsafe.global##._WeakMap in\n    new%js weakMap\n  in\n  fun (type a) node ~(keepme : a) ->\n    let prev =\n      Js.Optdef.case (map##get node) (fun () -> new%js Js.array_empty) (fun x -> x)\n    in\n    let (_ : int) = prev##push (Obj.repr keepme) in\n    map##set node prev\n\nmodule Xml = struct\n  module W = Xml_wrap.NoWrap\n\n  type 'a wrap = 'a\n\n  type 'a list_wrap = 'a list\n\n  type uri = string\n\n  let uri_of_string s = s\n\n  let string_of_uri s = s\n\n  type aname = string\n\n  type event_handler = Dom_html.event Js.t -> bool\n\n  type mouse_event_handler = Dom_html.mouseEvent Js.t -> bool\n\n  type keyboard_event_handler = Dom_html.keyboardEvent Js.t -> bool\n\n  type touch_event_handler = Dom_html.touchEvent Js.t -> bool\n\n  type attrib_k =\n    | Event of event_handler\n    | MouseEvent of mouse_event_handler\n    | KeyboardEvent of keyboard_event_handler\n    | TouchEvent of touch_event_handler\n    | Attr of Js.js_string Js.t option React.S.t\n\n  type attrib = aname * attrib_k\n\n  let attr name v = name, Attr (React.S.const (Some v))\n\n  let float_attrib name value : attrib = attr name (js_string_of_float value)\n\n  let int_attrib name value = attr name (js_string_of_int value)\n\n  let string_attrib name value = attr name (Js.string value)\n\n  let space_sep_attrib name values = attr name (Js.string (String.concat \" \" values))\n\n  let comma_sep_attrib name values = attr name (Js.string (String.concat \",\" values))\n\n  let event_handler_attrib name (value : event_handler) = name, Event value\n\n  let mouse_event_handler_attrib name (value : mouse_event_handler) =\n    name, MouseEvent value\n\n  let keyboard_event_handler_attrib name (value : keyboard_event_handler) =\n    name, KeyboardEvent value\n\n  let touch_event_handler_attrib name (value : touch_event_handler) =\n    name, TouchEvent value\n\n  let uri_attrib name value = attr name (Js.string value)\n\n  let uris_attrib name values = attr name (Js.string (String.concat \" \" values))\n\n  (** Element *)\n\n  type elt = Dom.node Js.t\n\n  type ename = string\n\n  let empty () = (Dom_html.document##createDocumentFragment :> Dom.node Js.t)\n\n  let comment c = (Dom_html.document##createComment (Js.string c) :> Dom.node Js.t)\n\n  let pcdata s = (Dom_html.document##createTextNode (Js.string s) :> Dom.node Js.t)\n\n  let encodedpcdata s = (Dom_html.document##createTextNode (Js.string s) :> Dom.node Js.t)\n\n  let entity =\n    let string_fold s ~pos ~init ~f =\n      let r = ref init in\n      for i = pos to String.length s - 1 do\n        let c = s.[i] in\n        r := f !r c\n      done;\n      !r\n    in\n    let invalid_entity e = failwith (Printf.sprintf \"Invalid entity %S\" e) in\n    let int_of_char = function\n      | '0' .. '9' as x -> Some (Char.code x - Char.code '0')\n      | 'a' .. 'f' as x -> Some (Char.code x - Char.code 'a' + 10)\n      | 'A' .. 'F' as x -> Some (Char.code x - Char.code 'A' + 10)\n      | _ -> None\n    in\n    let parse_int ~pos ~base e =\n      string_fold e ~pos ~init:0 ~f:(fun acc x ->\n          match int_of_char x with\n          | Some d when d < base -> (acc * base) + d\n          | Some _ | None -> invalid_entity e)\n    in\n    let is_alpha_num = function\n      | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' -> true\n      | _ -> false\n    in\n    fun e ->\n      let len = String.length e in\n      let str =\n        if len >= 1 && Char.equal e.[0] '#'\n        then\n          let i =\n            if len >= 2 && (Char.equal e.[1] 'x' || Char.equal e.[1] 'X')\n            then parse_int ~pos:2 ~base:16 e\n            else parse_int ~pos:1 ~base:10 e\n          in\n          Js.string_constr##fromCharCode i\n        else if string_fold e ~pos:0 ~init:true ~f:(fun acc x ->\n                    (* This is not quite right according to\n                       https://www.xml.com/axml/target.html#NT-Name.\n                       but it seems to cover all html5 entities\n                       https://dev.w3.org/html5/html-author/charref *)\n                    acc && is_alpha_num x)\n        then\n          match e with\n          | \"quot\" -> Js.string \"\\\"\"\n          | \"amp\" -> Js.string \"&\"\n          | \"apos\" -> Js.string \"'\"\n          | \"lt\" -> Js.string \"<\"\n          | \"gt\" -> Js.string \">\"\n          | \"\" -> invalid_entity e\n          | _ -> Dom_html.decode_html_entities (Js.string (\"&\" ^ e ^ \";\"))\n        else invalid_entity e\n      in\n      (Dom_html.document##createTextNode str :> Dom.node Js.t)\n\n  (* TODO: fix get_prop\n     it only work when html attribute and dom property names correspond.\n     find a way to get dom property name corresponding to html attribute\n  *)\n\n  let get_prop node name =\n    if Js.Optdef.test (Js.Unsafe.get node name) then Some name else None\n\n  let iter_prop_protected node name f =\n    match get_prop node name with\n    | Some n -> ( try f n with _ -> ())\n    | None -> ()\n\n  let attach_attribs node l =\n    List.iter\n      (fun (n', att) ->\n        let n = Js.string n' in\n        match att with\n        | Attr a ->\n            let (keepme : unit React.S.t) =\n              React.S.map\n                (function\n                  | Some v -> (\n                      ignore (node##setAttribute n v);\n                      match n' with\n                      | \"style\" -> node##.style##.cssText := v\n                      | _ ->\n                          iter_prop_protected node n (fun name ->\n                              Js.Unsafe.set node name v))\n                  | None -> (\n                      ignore (node##removeAttribute n);\n                      match n' with\n                      | \"style\" -> node##.style##.cssText := Js.string \"\"\n                      | _ ->\n                          iter_prop_protected node n (fun name ->\n                              Js.Unsafe.set node name Js.null)))\n                a\n            in\n            retain (node :> Dom.node Js.t) ~keepme\n        | Event h -> Js.Unsafe.set node n (Js.wrap_callback (fun ev -> Js.bool (h ev)))\n        | MouseEvent h ->\n            Js.Unsafe.set node n (Js.wrap_callback (fun ev -> Js.bool (h ev)))\n        | KeyboardEvent h ->\n            Js.Unsafe.set node n (Js.wrap_callback (fun ev -> Js.bool (h ev)))\n        | TouchEvent h ->\n            Js.Unsafe.set node n (Js.wrap_callback (fun ev -> Js.bool (h ev))))\n      l\n\n  let leaf ?(a = []) name =\n    let e = Dom_html.document##createElement (Js.string name) in\n    attach_attribs e a;\n    (e :> Dom.node Js.t)\n\n  let node ?(a = []) name children =\n    let e = Dom_html.document##createElement (Js.string name) in\n    attach_attribs e a;\n    List.iter (fun c -> ignore (e##appendChild c)) children;\n    (e :> Dom.node Js.t)\n\n  let cdata s = pcdata s\n\n  let cdata_script s = cdata s\n\n  let cdata_style s = cdata s\nend\n\nmodule Xml_Svg = struct\n  include Xml\n\n  let leaf ?(a = []) name =\n    let e = Dom_html.document##createElementNS Dom_svg.xmlns (Js.string name) in\n    attach_attribs e a;\n    (e :> Dom.node Js.t)\n\n  let node ?(a = []) name children =\n    let e = Dom_html.document##createElementNS Dom_svg.xmlns (Js.string name) in\n    attach_attribs e a;\n    List.iter (fun c -> ignore (e##appendChild c)) children;\n    (e :> Dom.node Js.t)\nend\n\nmodule Svg = Svg_f.Make (Xml_Svg)\nmodule Html = Html_f.Make (Xml) (Svg)\nmodule Html5 = Html\n\nmodule To_dom = Tyxml_cast.MakeTo (struct\n  type 'a elt = 'a Html.elt\n\n  let elt = Html.toelt\nend)\n\nmodule Of_dom = Tyxml_cast.MakeOf (struct\n  type 'a elt = 'a Html.elt\n\n  let elt = Html.tot\nend)\n\nmodule Register = struct\n  let removeChildren (node : #Dom.element Js.t) =\n    let l = node##.childNodes in\n    for i = 0 to l##.length - 1 do\n      Js.Opt.iter (l##item i) (fun x -> ignore (node##removeChild x))\n    done\n\n  let add_to ?(keep = true) node content =\n    if not keep then removeChildren node;\n    List.iter (fun x -> Dom.appendChild node (To_dom.of_element x)) content\n\n  let id ?keep id content =\n    let node = Dom_html.getElementById id in\n    add_to ?keep node content\n\n  let body ?keep content = add_to ?keep Dom_html.document##.body content\n\n  let head ?keep content = add_to ?keep Dom_html.document##.head content\n\n  let html ?head body =\n    (match head with\n    | Some h -> Dom_html.document##.head := To_dom.of_head h\n    | None -> ());\n    Dom_html.document##.body := To_dom.of_body body;\n    ()\nend\n\nmodule Wrap = struct\n  type 'a t = 'a React.signal\n\n  type 'a tlist = 'a ReactiveData.RList.t\n\n  type ('a, 'b) ft = 'a -> 'b\n\n  let return = React.S.const\n\n  let fmap f = React.S.map f\n\n  let nil () = ReactiveData.RList.empty\n\n  let singleton = ReactiveData.RList.singleton_s\n\n  let cons x xs = ReactiveData.RList.concat (singleton x) xs\n\n  let map f = ReactiveData.RList.map f\n\n  let append x y = ReactiveData.RList.concat x y\nend\n\nmodule Util = struct\n  open ReactiveData\n  open RList\n\n  let insertAt dom i x =\n    let nodes = dom##.childNodes in\n    assert (i <= nodes##.length);\n    if i = nodes##.length\n    then ignore (dom##appendChild (x :> Dom.node Js.t))\n    else ignore (dom##insertBefore x (nodes##item i))\n\n  let merge_one_patch (dom : Dom.node Js.t) (p : Dom.node Js.t p) =\n    match p with\n    | I (i, x) ->\n        let i = if i < 0 then dom##.childNodes##.length + 1 + i else i in\n        insertAt dom i x\n    | R i ->\n        let i = if i < 0 then dom##.childNodes##.length + i else i in\n        let nodes = dom##.childNodes in\n        assert (i >= 0 && i < nodes##.length);\n        Js.Opt.iter (nodes##item i) (fun n -> Dom.removeChild dom n)\n    | U (i, x) -> (\n        let i = if i < 0 then dom##.childNodes##.length + i else i in\n        match Js.Opt.to_option (dom##.childNodes##item i) with\n        | Some old -> ignore (dom##replaceChild x old)\n        | _ -> assert false)\n    | X (i, move) -> (\n        let i = if i < 0 then dom##.childNodes##.length + i else i in\n        if move = 0\n        then ()\n        else\n          match Js.Opt.to_option (dom##.childNodes##item i) with\n          | Some i' -> insertAt dom (i + if move > 0 then move + 1 else move) i'\n          | _ -> assert false)\n\n  let rec removeChildren dom =\n    match Js.Opt.to_option dom##.lastChild with\n    | None -> ()\n    | Some c ->\n        ignore (dom##removeChild c);\n        removeChildren dom\n\n  let merge_msg (dom : Dom.node Js.t) (msg : Dom.node Js.t msg) =\n    match msg with\n    | Set l ->\n        (* Format.eprintf \"replace all@.\"; *)\n        removeChildren dom;\n        List.iter (fun l -> ignore (dom##appendChild l)) l\n    | Patch p ->\n        (* Format.eprintf \"patch@.\"; *)\n        List.iter (merge_one_patch dom) p\n\n  let update_children (dom : Dom.node Js.t) (nodes : Dom.node Js.t t) =\n    removeChildren dom;\n    let keepme : unit React.S.t = fold (fun () msg -> merge_msg dom msg) nodes () in\n    retain (dom : Dom.node Js.t) ~keepme;\n    ()\nend\n\nmodule R = struct\n  let filter_attrib (name, a) on =\n    match a with\n    | Xml.Event _ | Xml.MouseEvent _ | Xml.KeyboardEvent _ | Xml.TouchEvent _ ->\n        raise (Invalid_argument \"filter_attrib not implemented for event handler\")\n    | Xml.Attr a -> name, Xml.Attr (React.S.l2 (fun on a -> if on then a else None) on a)\n\n  let attach_attribs = Xml.attach_attribs\n\n  module Xml = struct\n    module W = Wrap\n\n    type 'a wrap = 'a W.t\n\n    type 'a list_wrap = 'a W.tlist\n\n    type uri = Xml.uri\n\n    let string_of_uri = Xml.string_of_uri\n\n    let uri_of_string = Xml.uri_of_string\n\n    type aname = Xml.aname\n\n    type event_handler = Xml.event_handler\n\n    type mouse_event_handler = Xml.mouse_event_handler\n\n    type keyboard_event_handler = Xml.keyboard_event_handler\n\n    type touch_event_handler = Xml.touch_event_handler\n\n    type attrib = Xml.attrib\n\n    let attr name f s =\n      let a = W.fmap f s in\n      name, Xml.Attr a\n\n    let float_attrib name s = attr name (fun f -> Some (js_string_of_float f)) s\n\n    let int_attrib name s = attr name (fun f -> Some (js_string_of_int f)) s\n\n    let string_attrib name s = attr name (fun f -> Some (Js.string f)) s\n\n    let space_sep_attrib name s =\n      attr name (fun f -> Some (Js.string (String.concat \" \" f))) s\n\n    let comma_sep_attrib name s =\n      attr name (fun f -> Some (Js.string (String.concat \",\" f))) s\n\n    let event_handler_attrib name s = Xml.event_handler_attrib name s\n\n    let mouse_event_handler_attrib name s = Xml.mouse_event_handler_attrib name s\n\n    let keyboard_event_handler_attrib name s = Xml.keyboard_event_handler_attrib name s\n\n    let touch_event_handler_attrib name s = Xml.touch_event_handler_attrib name s\n\n    let uri_attrib name s = attr name (fun f -> Some (Js.string f)) s\n\n    let uris_attrib name s = attr name (fun f -> Some (Js.string (String.concat \" \" f))) s\n\n    type elt = Xml.elt\n\n    type ename = Xml.ename\n\n    let empty = Xml.empty\n\n    let comment = Xml.comment\n\n    let pcdata s =\n      let e = Dom_html.document##createTextNode (Js.string \"\") in\n      let keepme = React.S.map (fun s -> e##.data := Js.string s) s in\n      retain (e :> Dom.node Js.t) ~keepme;\n      (e :> Dom.node Js.t)\n\n    let encodedpcdata s = pcdata s\n\n    let entity s = Xml.entity s\n\n    let leaf = Xml.leaf\n\n    let node ?(a = []) name l =\n      let e = Dom_html.document##createElement (Js.string name) in\n      attach_attribs e a;\n      Util.update_children (e :> Dom.node Js.t) l;\n      (e :> Dom.node Js.t)\n\n    let cdata = Xml.cdata\n\n    let cdata_script = Xml.cdata_script\n\n    let cdata_style = Xml.cdata_style\n  end\n\n  module Xml_Svg = struct\n    include Xml\n\n    let leaf = Xml_Svg.leaf\n\n    let node ?(a = []) name l =\n      let e = Dom_html.document##createElementNS Dom_svg.xmlns (Js.string name) in\n      attach_attribs e a;\n      Util.update_children (e :> Dom.node Js.t) l;\n      (e :> Dom.node Js.t)\n  end\n\n  module Svg = Svg_f.Make (Xml_Svg)\n  module Html = Html_f.Make (Xml) (Svg)\n  module Html5 = Html\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2014 Hugo Heuzard\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js_of_ocaml\nopen! Import\n\nmodule MakeTo (C : sig\n  type 'a elt\n\n  val elt : 'a elt -> Dom.node Js.t\nend) : Tyxml_cast_sigs.TO with type 'a elt = 'a C.elt = struct\n  type 'a elt = 'a C.elt\n\n  let rebuild_node _ x = Js.Unsafe.coerce (C.elt x)\n\n  let of_element elt = rebuild_node \"of_element\" elt\n\n  let of_node elt = rebuild_node \"of_node\" elt\n\n  let of_pcdata elt = rebuild_node \"of_pcdata\" elt\n\n  let of_html elt = rebuild_node \"of_html\" elt\n\n  let of_head elt = rebuild_node \"of_head\" elt\n\n  let of_link elt = rebuild_node \"of_link\" elt\n\n  let of_title elt = rebuild_node \"of_title\" elt\n\n  let of_meta elt = rebuild_node \"of_meta\" elt\n\n  let of_base elt = rebuild_node \"of_base\" elt\n\n  let of_style elt = rebuild_node \"of_style\" elt\n\n  let of_body elt = rebuild_node \"of_body\" elt\n\n  let of_form elt = rebuild_node \"of_form\" elt\n\n  let of_optgroup elt = rebuild_node \"of_optgroup\" elt\n\n  let of_option elt = rebuild_node \"of_option\" elt\n\n  let of_select elt = rebuild_node \"of_select\" elt\n\n  let of_input elt = rebuild_node \"of_input\" elt\n\n  let of_textarea elt = rebuild_node \"of_textarea\" elt\n\n  let of_button elt = rebuild_node \"of_button\" elt\n\n  let of_label elt = rebuild_node \"of_label\" elt\n\n  let of_fieldset elt = rebuild_node \"of_fieldset\" elt\n\n  let of_legend elt = rebuild_node \"of_legend\" elt\n\n  let of_ul elt = rebuild_node \"of_ul\" elt\n\n  let of_ol elt = rebuild_node \"of_ol\" elt\n\n  let of_dl elt = rebuild_node \"of_dl\" elt\n\n  let of_li elt = rebuild_node \"of_li\" elt\n\n  let of_div elt = rebuild_node \"of_div\" elt\n\n  let of_p elt = rebuild_node \"of_p\" elt\n\n  let of_heading elt = rebuild_node \"of_heading\" elt\n\n  let of_blockquote elt = rebuild_node \"of_blockquote\" elt\n\n  let of_pre elt = rebuild_node \"of_pre\" elt\n\n  let of_br elt = rebuild_node \"of_br\" elt\n\n  let of_hr elt = rebuild_node \"of_hr\" elt\n\n  let of_ins elt = rebuild_node \"of_ins\" elt\n\n  let of_del elt = rebuild_node \"of_del\" elt\n\n  let of_a elt = rebuild_node \"of_a\" elt\n\n  let of_img elt = rebuild_node \"of_img\" elt\n\n  let of_object elt = rebuild_node \"of_object\" elt\n\n  let of_param elt = rebuild_node \"of_param\" elt\n\n  let of_area elt = rebuild_node \"of_area\" elt\n\n  let of_map elt = rebuild_node \"of_map\" elt\n\n  let of_script elt = rebuild_node \"of_script\" elt\n\n  let of_td elt = rebuild_node \"of_td\" elt\n\n  let of_tr elt = rebuild_node \"of_tr\" elt\n\n  let of_col elt = rebuild_node \"of_col\" elt\n\n  let of_tfoot elt = rebuild_node \"of_tfoot\" elt\n\n  let of_thead elt = rebuild_node \"of_thead\" elt\n\n  let of_tbody elt = rebuild_node \"of_tbody\" elt\n\n  let of_caption elt = rebuild_node \"of_caption\" elt\n\n  let of_table elt = rebuild_node \"of_table\" elt\n\n  let of_canvas elt = rebuild_node \"of_canvas\" elt\n\n  let of_iframe elt = rebuild_node \"of_iframe\" elt\n\n  let of_audio elt = rebuild_node \"of_audio\" elt\n\n  let of_video elt = rebuild_node \"of_video\" elt\n\n  (* Dom_html.headingElement *)\n\n  let of_h1 elt = rebuild_node \"of_h1\" elt\n\n  let of_h2 elt = rebuild_node \"of_h2\" elt\n\n  let of_h3 elt = rebuild_node \"of_h3\" elt\n\n  let of_h4 elt = rebuild_node \"of_h4\" elt\n\n  let of_h5 elt = rebuild_node \"of_h5\" elt\n\n  let of_h6 elt = rebuild_node \"of_h6\" elt\n\n  (* Dom_html.element *)\n\n  let of_abbr elt = rebuild_node \"of_abbr\" elt\n\n  let of_address elt = rebuild_node \"of_address\" elt\n\n  let of_article elt = rebuild_node \"of_article\" elt\n\n  let of_aside elt = rebuild_node \"of_aside\" elt\n\n  let of_b elt = rebuild_node \"of_b\" elt\n\n  let of_bdo elt = rebuild_node \"of_bdo\" elt\n\n  let of_cite elt = rebuild_node \"of_cite\" elt\n\n  let of_code elt = rebuild_node \"of_code\" elt\n\n  let of_colgroup elt = rebuild_node \"of_colgroup\" elt\n\n  let of_command elt = rebuild_node \"of_command\" elt\n\n  let of_datalist elt = rebuild_node \"of_datalist\" elt\n\n  let of_dd elt = rebuild_node \"of_dd\" elt\n\n  let of_details elt = rebuild_node \"of_details\" elt\n\n  let of_dfn elt = rebuild_node \"of_dfn\" elt\n\n  let of_dt elt = rebuild_node \"of_dt\" elt\n\n  let of_em elt = rebuild_node \"of_em\" elt\n\n  let of_embed elt = rebuild_node \"of_embed\" elt\n\n  let of_figcaption elt = rebuild_node \"of_figcaption\" elt\n\n  let of_figure elt = rebuild_node \"of_figure\" elt\n\n  let of_footer elt = rebuild_node \"of_footer\" elt\n\n  let of_header elt = rebuild_node \"of_header\" elt\n\n  let of_hgroup elt = rebuild_node \"of_hgroup\" elt\n\n  let of_i elt = rebuild_node \"of_i\" elt\n\n  let of_kbd elt = rebuild_node \"of_kbd\" elt\n\n  let of_keygen elt = rebuild_node \"of_keygen\" elt\n\n  let of_main elt = rebuild_node \"of_main\" elt\n\n  let of_mark elt = rebuild_node \"of_mark\" elt\n\n  let of_menu elt = rebuild_node \"of_menu\" elt\n\n  let of_meter elt = rebuild_node \"of_meter\" elt\n\n  let of_nav elt = rebuild_node \"of_nav\" elt\n\n  let of_noscript elt = rebuild_node \"of_noscript\" elt\n\n  let of_output elt = rebuild_node \"of_output\" elt\n\n  let of_progress elt = rebuild_node \"of_progress\" elt\n\n  let of_q elt = rebuild_node \"of_q\" elt\n\n  let of_rp elt = rebuild_node \"of_rp\" elt\n\n  let of_rt elt = rebuild_node \"of_rt\" elt\n\n  let of_ruby elt = rebuild_node \"of_ruby\" elt\n\n  let of_samp elt = rebuild_node \"of_samp\" elt\n\n  let of_section elt = rebuild_node \"of_section\" elt\n\n  let of_small elt = rebuild_node \"of_small\" elt\n\n  let of_source elt = rebuild_node \"of_source\" elt\n\n  let of_span elt = rebuild_node \"of_span\" elt\n\n  let of_strong elt = rebuild_node \"of_strong\" elt\n\n  let of_sub elt = rebuild_node \"of_sub\" elt\n\n  let of_summary elt = rebuild_node \"of_summary\" elt\n\n  let of_sup elt = rebuild_node \"of_sup\" elt\n\n  let of_th elt = rebuild_node \"of_th\" elt\n\n  let of_time elt = rebuild_node \"of_time\" elt\n\n  let of_u elt = rebuild_node \"of_u\" elt\n\n  let of_var elt = rebuild_node \"of_var\" elt\n\n  let of_wbr elt = rebuild_node \"of_wbr\" elt\nend\n\nmodule MakeOf (C : sig\n  type 'a elt\n\n  val elt : Dom.node Js.t -> 'a elt\nend) : Tyxml_cast_sigs.OF with type 'a elt = 'a C.elt = struct\n  type 'a elt = 'a C.elt\n\n  let rebuild_node _ x = C.elt (Js.Unsafe.coerce x)\n\n  let of_element elt = rebuild_node \"of_element\" elt\n\n  let of_html elt = rebuild_node \"of_html\" elt\n\n  let of_head elt = rebuild_node \"of_head\" elt\n\n  let of_link elt = rebuild_node \"of_link\" elt\n\n  let of_title elt = rebuild_node \"of_title\" elt\n\n  let of_meta elt = rebuild_node \"of_meta\" elt\n\n  let of_base elt = rebuild_node \"of_base\" elt\n\n  let of_style elt = rebuild_node \"of_style\" elt\n\n  let of_body elt = rebuild_node \"of_body\" elt\n\n  let of_form elt = rebuild_node \"of_form\" elt\n\n  let of_optGroup elt = rebuild_node \"of_optGroup\" elt\n\n  let of_option elt = rebuild_node \"of_option\" elt\n\n  let of_select elt = rebuild_node \"of_select\" elt\n\n  let of_input elt = rebuild_node \"of_input\" elt\n\n  let of_textArea elt = rebuild_node \"of_textArea\" elt\n\n  let of_button elt = rebuild_node \"of_button\" elt\n\n  let of_label elt = rebuild_node \"of_label\" elt\n\n  let of_fieldSet elt = rebuild_node \"of_fieldSet\" elt\n\n  let of_legend elt = rebuild_node \"of_legend\" elt\n\n  let of_uList elt = rebuild_node \"of_uList\" elt\n\n  let of_oList elt = rebuild_node \"of_oList\" elt\n\n  let of_dList elt = rebuild_node \"of_dList\" elt\n\n  let of_li elt = rebuild_node \"of_li\" elt\n\n  let of_div elt = rebuild_node \"of_div\" elt\n\n  let of_paragraph elt = rebuild_node \"of_paragraph\" elt\n\n  let of_heading elt = rebuild_node \"of_heading\" elt\n\n  let of_quote elt = rebuild_node \"of_quote\" elt\n\n  let of_pre elt = rebuild_node \"of_pre\" elt\n\n  let of_br elt = rebuild_node \"of_br\" elt\n\n  let of_hr elt = rebuild_node \"of_hr\" elt\n\n  let of_mod elt = rebuild_node \"of_mod\" elt\n\n  let of_anchor elt = rebuild_node \"of_anchor\" elt\n\n  let of_image elt = rebuild_node \"of_image\" elt\n\n  let of_object elt = rebuild_node \"of_object\" elt\n\n  let of_param elt = rebuild_node \"of_param\" elt\n\n  let of_area elt = rebuild_node \"of_area\" elt\n\n  let of_map elt = rebuild_node \"of_map\" elt\n\n  let of_script elt = rebuild_node \"of_script\" elt\n\n  let of_embed elt = rebuild_node \"of_embed\" elt\n\n  let of_tableCell elt = rebuild_node \"of_tableCell\" elt\n\n  let of_tableRow elt = rebuild_node \"of_tableRow\" elt\n\n  let of_tableCol elt = rebuild_node \"of_tableCol\" elt\n\n  let of_tableSection elt = rebuild_node \"of_tableSection\" elt\n\n  let of_tableCaption elt = rebuild_node \"of_tableCaption\" elt\n\n  let of_table elt = rebuild_node \"of_table\" elt\n\n  let of_canvas elt = rebuild_node \"of_canvas\" elt\n\n  let of_iFrame elt = rebuild_node \"of_iFrame\" elt\n\n  let of_audio elt = rebuild_node \"of_audio\" elt\n\n  let of_video elt = rebuild_node \"of_video\" elt\nend\n","(* based on https://commons.wikimedia.org/wiki/File:Bear_game_05.svg *)\n\nopen Query\n\nlet coords x = RomanWheel.(\n  match x with\n  | Center -> (100.0, 100.0)\n\n  | SpokeVert(S1, Mid) -> (100.0, 45.0)\n  | SpokeVert(S2, Mid) -> (138.88, 61.109)\n  | SpokeVert(S3, Mid) -> (155.0, 100.0)\n  | SpokeVert(S4, Mid) -> (138.89, 138.89)\n  | SpokeVert(S5, Mid) -> (100.0, 155.0)\n  | SpokeVert(S6, Mid) -> (61.109, 138.88)\n  | SpokeVert(S7, Mid) -> (45.0, 100.0)\n  | SpokeVert(S8, Mid) -> (61.109, 61.109)\n\n  | SpokeVert(S1,L) -> (80.213, 27.742)\n  | SpokeVert(S2,L) -> (137.09, 34.922)\n  | SpokeVert(S3,L) -> (172.258, 80.213)\n  | SpokeVert(S4,L) -> (165.078, 137.09)\n  | SpokeVert(S5,L) -> (119.787, 172.258)\n  | SpokeVert(S6,L) -> (62.91, 165.078)\n  | SpokeVert(S7,L) -> (27.742, 119.787)\n  | SpokeVert(S8,L) -> (34.922, 62.91)\n\n  | SpokeVert(S1,R) -> (119.787, 27.742)\n  | SpokeVert(S2,R) -> (165.078, 62.91)\n  | SpokeVert(S3,R) -> (172.258, 119.787)\n  | SpokeVert(S4,R) -> (137.09, 165.078)\n  | SpokeVert(S5,R) -> (80.213, 172.258)\n  | SpokeVert(S6,R) -> (34.922, 137.09)\n  | SpokeVert(S7,R) -> (27.742, 80.213)\n  | SpokeVert(S8,R) -> (62.91, 34.922)\n  )\n\n  let arcs = List.map (fun p ->\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n      path ~a:[a_stroke_width (1., Some `Px); a_fill `None;\n      a_stroke (`Color (\"black\", None)); a_d p] []\n    ))\n    [ \"m46.967 133.03a20 20 0 0 0-12.045 4.0566 75 75 0 0 0 27.959 28.016 20 20 0 0 0 4.0859-12.072 20 20 0 0 0-20-20z\"\n    ; \"m100 155a20 20 0 0 0-19.787 17.258 75 75 0 0 0 19.787 2.7422 75 75 0 0 0 19.797-2.6719 20 20 0 0 0-19.797-17.328z\"\n    ; \"m153.03 133.03a20 20 0 0 0-20 20 20 20 0 0 0 4.0586 12.047 75 75 0 0 0 28.014-27.961 20 20 0 0 0-12.072-4.0859z\"\n    ; \"m172.33 80.203a20 20 0 0 0-17.328 19.797 20 20 0 0 0 17.258 19.787 75 75 0 0 0 2.7422-19.787 75 75 0 0 0-2.6719-19.797z\"\n    ; \"m137.12 34.895a20 20 0 0 0-4.0859 12.072 20 20 0 0 0 20 20 20 20 0 0 0 12.045-4.0566 75 75 0 0 0-27.959-28.016z\"\n    ; \"m100 25a75 75 0 0 0-19.797 2.6719 20 20 0 0 0 19.797 17.328 20 20 0 0 0 19.787-17.258 75 75 0 0 0-19.787-2.7422z\"\n    ; \"m62.91 34.922a75 75 0 0 0-28.016 27.959 20 20 0 0 0 12.072 4.0859 20 20 0 0 0 20-20 20 20 0 0 0-4.0566-11.845z\"\n    ; \"m27.742 80.213a75 75 0 0 0-2.7422 19.787 75 75 0 0 0 2.6719 19.797 20 20 0 0 0 17.328-19.797 20 20 0 0 0-17.258-19.787z\"\n    ]\n\n  let lines = List.map (fun p ->\n    Js_of_ocaml_tyxml.Tyxml_js.Svg.(\n      path ~a:[a_stroke_width (1., Some `Px); a_fill `None;\n      a_stroke (`Color (\"black\", None)); a_d p] []\n    ))\n    [ \"m45 100h110\"\n    ; \"m61.109 138.88 77.782-77.782\"\n    ; \"m100 155-2.1e-5 -110\"\n    ; \"m138.89 138.89-77.782-77.782\"\n    ]\n","(* This file is part of Lwt, released under the MIT license. See LICENSE.md for\n   details, or visit https://github.com/ocsigen/lwt/blob/master/LICENSE.md. *)\n\n\n\nexception Empty\n\ntype 'a t = {\n  mutable prev : 'a t;\n  mutable next : 'a t;\n}\n\ntype 'a node = {\n  node_prev : 'a t;\n  node_next : 'a t;\n  mutable node_data : 'a;\n  mutable node_active : bool;\n}\n\nexternal seq_of_node : 'a node -> 'a t = \"%identity\"\nexternal node_of_seq : 'a t -> 'a node = \"%identity\"\n\n(* +-----------------------------------------------------------------+\n   | Operations on nodes                                             |\n   +-----------------------------------------------------------------+ *)\n\nlet get node =\n  node.node_data\n\nlet set node data =\n  node.node_data <- data\n\nlet remove node =\n  if node.node_active then begin\n    node.node_active <- false;\n    let seq = seq_of_node node in\n    seq.prev.next <- seq.next;\n    seq.next.prev <- seq.prev\n  end\n\n(* +-----------------------------------------------------------------+\n   | Operations on sequences                                         |\n   +-----------------------------------------------------------------+ *)\n\nlet create () =\n  let rec seq = { prev = seq; next = seq } in\n  seq\n\nlet clear seq =\n  seq.prev <- seq;\n  seq.next <- seq\n\nlet is_empty seq = seq.next == seq\n\nlet length seq =\n  let rec loop curr len =\n    if curr == seq then\n      len\n    else\n      let node = node_of_seq curr in loop node.node_next (len + 1)\n  in\n  loop seq.next 0\n\nlet add_l data seq =\n  let node = { node_prev = seq; node_next = seq.next; node_data = data; node_active = true } in\n  seq.next.prev <- seq_of_node node;\n  seq.next <- seq_of_node node;\n  node\n\nlet add_r data seq =\n  let node = { node_prev = seq.prev; node_next = seq; node_data = data; node_active = true } in\n  seq.prev.next <- seq_of_node node;\n  seq.prev <- seq_of_node node;\n  node\n\nlet take_l seq =\n  if is_empty seq then\n    raise Empty\n  else begin\n    let node = node_of_seq seq.next in\n    remove node;\n    node.node_data\n  end\n\nlet take_r seq =\n  if is_empty seq then\n    raise Empty\n  else begin\n    let node = node_of_seq seq.prev in\n    remove node;\n    node.node_data\n  end\n\nlet take_opt_l seq =\n  if is_empty seq then\n    None\n  else begin\n    let node = node_of_seq seq.next in\n    remove node;\n    Some node.node_data\n  end\n\nlet take_opt_r seq =\n  if is_empty seq then\n    None\n  else begin\n    let node = node_of_seq seq.prev in\n    remove node;\n    Some node.node_data\n  end\n\nlet transfer_l s1 s2 =\n  s2.next.prev <- s1.prev;\n  s1.prev.next <- s2.next;\n  s2.next <- s1.next;\n  s1.next.prev <- s2;\n  s1.prev <- s1;\n  s1.next <- s1\n\nlet transfer_r s1 s2 =\n  s2.prev.next <- s1.next;\n  s1.next.prev <- s2.prev;\n  s2.prev <- s1.prev;\n  s1.prev.next <- s2;\n  s1.prev <- s1;\n  s1.next <- s1\n\nlet iter_l f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node.node_data;\n      loop node.node_next\n    end\n  in\n  loop seq.next\n\nlet iter_r f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node.node_data;\n      loop node.node_prev\n    end\n  in\n  loop seq.prev\n\nlet iter_node_l f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node;\n      loop node.node_next\n    end\n  in\n  loop seq.next\n\nlet iter_node_r f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node;\n      loop node.node_prev\n    end\n  in\n  loop seq.prev\n\nlet fold_l f seq acc =\n  let rec loop curr acc =\n    if curr == seq then\n      acc\n    else\n      let node = node_of_seq curr in\n      if node.node_active then\n        loop node.node_next (f node.node_data acc)\n      else\n        loop node.node_next acc\n  in\n  loop seq.next acc\n\nlet fold_r f seq acc =\n  let rec loop curr acc =\n    if curr == seq then\n      acc\n    else\n      let node = node_of_seq curr in\n      if node.node_active then\n        loop node.node_prev (f node.node_data acc)\n      else\n        loop node.node_prev acc\n  in\n  loop seq.prev acc\n\nlet find_node_l f seq =\n  let rec loop curr =\n    if curr != seq then\n      let node = node_of_seq curr in\n      if node.node_active then\n        if f node.node_data then\n          node\n        else\n          loop node.node_next\n      else\n        loop node.node_next\n    else\n      raise Not_found\n  in\n  loop seq.next\n\nlet find_node_r f seq =\n  let rec loop curr =\n    if curr != seq then\n      let node = node_of_seq curr in\n      if node.node_active then\n        if f node.node_data then\n          node\n        else\n          loop node.node_prev\n      else\n        loop node.node_prev\n    else\n      raise Not_found\n  in\n  loop seq.prev\n\nlet find_node_opt_l f seq =\n  try Some (find_node_l f seq) with Not_found -> None\n\nlet find_node_opt_r f seq =\n  try Some (find_node_r f seq) with Not_found -> None\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js_of_ocaml\nopen! Import\n\nlet sleep d =\n  let t, w = Lwt.task () in\n  let id = Dom_html.setTimeout (Lwt.wakeup w) (d *. 1000.) in\n  Lwt.on_cancel t (fun () -> Dom_html.clearTimeout id);\n  t\n\nlet yield () = sleep 0.\n\nlet wakeup = function\n  | 1 ->\n      ignore\n        (Dom_html.window##setTimeout (Js.wrap_callback Lwt.wakeup_paused) (Js.float 0.))\n  | _ -> ()\n\nlet () = Lwt.register_pause_notifier wakeup\n\nlet prerr_string s = Firebug.console##log (Js.string s)\n\nlet _ =\n  Lwt.async_exception_hook :=\n    fun exn ->\n      prerr_string \"Exception during Lwt.async: \";\n      prerr_string (Printexc.to_string exn);\n      Printexc.print_backtrace stderr\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Vincent Balat\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js_of_ocaml\nopen! Import\n\nlet ( >>= ) = Lwt.bind\n\nlet async f = Lwt.async (fun () -> Lwt_js.yield () >>= f)\n\nlet opt_map f = function\n  | None -> None\n  | Some x -> Some (f x)\n\nlet make_event event_kind ?use_capture ?passive target =\n  let el = ref Js.null in\n  let t, w = Lwt.task () in\n  let cancel () = Js.Opt.iter !el Dom_html.removeEventListener in\n  Lwt.on_cancel t cancel;\n  el :=\n    Js.some\n      (Dom.addEventListenerWithOptions\n         ?capture:(opt_map Js.bool use_capture)\n         ?passive:(opt_map Js.bool passive)\n         target\n         event_kind\n         (Dom_html.handler (fun (ev : #Dom_html.event Js.t) ->\n              cancel ();\n              Lwt.wakeup w ev;\n              Js.bool true))\n         (* true because we do not want to prevent default ->\n                              the user can use the preventDefault function\n                              above. *));\n  t\n\nlet catch_cancel f x =\n  Lwt.catch\n    (fun () -> f x)\n    (function\n      | Lwt.Canceled -> Lwt.return ()\n      | e -> Lwt.fail e)\n\nlet with_error_log f x =\n  Lwt.catch\n    (fun () -> f x)\n    (fun e ->\n      Firebug.console##log (Js.string (Printexc.to_string e));\n      Lwt.return ())\n\nlet seq_loop evh ?(cancel_handler = false) ?use_capture ?passive target handler =\n  let cancelled = ref false in\n  let cur = ref (Lwt.fail (Failure \"Lwt_js_event\")) in\n  (* Using Lwt.fail as default, to be polymorphic *)\n  let cur_handler = ref (Lwt.return ()) in\n  let lt, _lw = Lwt.task () in\n  Lwt.on_cancel lt (fun () ->\n      Lwt.cancel !cur;\n      if cancel_handler then Lwt.cancel !cur_handler;\n      cancelled := true);\n  let rec aux () =\n    if not !cancelled\n       (* In the case it has been cancelled\n                         during the previous handler,\n                         we do not reinstall the event handler *)\n    then (\n      let t = evh ?use_capture ?passive target in\n      cur := t;\n      t\n      >>= fun e ->\n      cur_handler := with_error_log (handler e) lt;\n      !cur_handler >>= aux)\n    else Lwt.return ()\n  in\n  Lwt.async (catch_cancel aux);\n  lt\n\nlet async_loop evh ?use_capture ?passive target handler =\n  let cancelled = ref false in\n  let cur = ref (Lwt.fail (Failure \"Lwt_js_event\")) in\n  let lt, _lw = Lwt.task () in\n  Lwt.on_cancel lt (fun () ->\n      Lwt.cancel !cur;\n      cancelled := true);\n  let rec aux () =\n    if not !cancelled\n    then (\n      let t = evh ?use_capture ?passive target in\n      cur := t;\n      t\n      >>= fun e ->\n      Lwt.async (fun () -> with_error_log (handler e) lt);\n      aux ())\n    else Lwt.return ()\n  in\n  Lwt.async (catch_cancel aux);\n  lt\n\nlet buffered_loop\n    evh\n    ?(cancel_handler = false)\n    ?(cancel_queue = true)\n    ?use_capture\n    ?passive\n    target\n    handler =\n  let cancelled = ref false in\n  let queue = ref [] in\n  let cur = ref (Lwt.fail (Failure \"Lwt_js_event\")) in\n  let cur_handler = ref (Lwt.return ()) in\n  let lt, _lw = Lwt.task () in\n  let spawn = Lwt_condition.create () in\n  Lwt.on_cancel lt (fun () ->\n      Lwt.cancel !cur;\n      if cancel_handler then Lwt.cancel !cur_handler;\n      if cancel_queue then queue := [];\n      cancelled := true);\n  let rec spawner () =\n    if not !cancelled\n    then (\n      let t = evh ?use_capture ?passive target in\n      cur := t;\n      t\n      >>= fun e ->\n      queue := e :: !queue;\n      Lwt_condition.signal spawn ();\n      spawner ())\n    else Lwt.return ()\n  in\n  let rec runner () =\n    cur_handler := Lwt.return ();\n    if not !cancelled\n    then (\n      match !queue with\n      | [] -> Lwt_condition.wait spawn >>= runner\n      | e :: tl ->\n          queue := tl;\n          cur_handler := with_error_log (handler e) lt;\n          !cur_handler >>= runner)\n    else Lwt.return ()\n  in\n  Lwt.async (catch_cancel spawner);\n  Lwt.async runner;\n  lt\n\nlet func_limited_loop event limited_func ?use_capture ?passive target handler =\n  let count = ref 0 in\n  async_loop event ?use_capture ?passive target (fun ev lt ->\n      incr count;\n      let nb = !count in\n      limited_func () >>= fun _ -> if !count = nb then handler ev lt else Lwt.return ())\n\nlet limited_loop event ?(elapsed_time = 0.1) =\n  func_limited_loop event (fun () -> Lwt_js.sleep elapsed_time)\n\nlet click ?use_capture ?passive target =\n  make_event Dom_html.Event.click ?use_capture ?passive target\n\nlet copy ?use_capture ?passive target =\n  make_event Dom_html.Event.copy ?use_capture ?passive target\n\nlet cut ?use_capture ?passive target =\n  make_event Dom_html.Event.cut ?use_capture ?passive target\n\nlet paste ?use_capture ?passive target =\n  make_event Dom_html.Event.paste ?use_capture ?passive target\n\nlet dblclick ?use_capture ?passive target =\n  make_event Dom_html.Event.dblclick ?use_capture ?passive target\n\nlet mousedown ?use_capture ?passive target =\n  make_event Dom_html.Event.mousedown ?use_capture ?passive target\n\nlet mouseup ?use_capture ?passive target =\n  make_event Dom_html.Event.mouseup ?use_capture ?passive target\n\nlet mouseover ?use_capture ?passive target =\n  make_event Dom_html.Event.mouseover ?use_capture ?passive target\n\nlet mousemove ?use_capture ?passive target =\n  make_event Dom_html.Event.mousemove ?use_capture ?passive target\n\nlet mouseout ?use_capture ?passive target =\n  make_event Dom_html.Event.mouseout ?use_capture ?passive target\n\nlet keypress ?use_capture ?passive target =\n  make_event Dom_html.Event.keypress ?use_capture ?passive target\n\nlet keydown ?use_capture ?passive target =\n  make_event Dom_html.Event.keydown ?use_capture ?passive target\n\nlet keyup ?use_capture ?passive target =\n  make_event Dom_html.Event.keyup ?use_capture ?passive target\n\nlet change ?use_capture ?passive target =\n  make_event Dom_html.Event.change ?use_capture ?passive target\n\nlet input ?use_capture ?passive target =\n  make_event Dom_html.Event.input ?use_capture ?passive target\n\nlet timeupdate ?use_capture ?passive target =\n  make_event Dom_html.Event.timeupdate ?use_capture ?passive target\n\nlet dragstart ?use_capture ?passive target =\n  make_event Dom_html.Event.dragstart ?use_capture ?passive target\n\nlet dragend ?use_capture ?passive target =\n  make_event Dom_html.Event.dragend ?use_capture ?passive target\n\nlet dragenter ?use_capture ?passive target =\n  make_event Dom_html.Event.dragenter ?use_capture ?passive target\n\nlet dragover ?use_capture ?passive target =\n  make_event Dom_html.Event.dragover ?use_capture ?passive target\n\nlet dragleave ?use_capture ?passive target =\n  make_event Dom_html.Event.dragleave ?use_capture ?passive target\n\nlet drag ?use_capture ?passive target =\n  make_event Dom_html.Event.drag ?use_capture ?passive target\n\nlet drop ?use_capture ?passive target =\n  make_event Dom_html.Event.drop ?use_capture ?passive target\n\nlet focus ?use_capture ?passive target =\n  make_event Dom_html.Event.focus ?use_capture ?passive target\n\nlet blur ?use_capture ?passive target =\n  make_event Dom_html.Event.blur ?use_capture ?passive target\n\nlet scroll ?use_capture ?passive target =\n  make_event Dom_html.Event.scroll ?use_capture ?passive target\n\nlet submit ?use_capture ?passive target =\n  make_event Dom_html.Event.submit ?use_capture ?passive target\n\nlet select ?use_capture ?passive target =\n  make_event Dom_html.Event.select ?use_capture ?passive target\n\nlet abort ?use_capture ?passive target =\n  make_event Dom_html.Event.abort ?use_capture ?passive target\n\nlet error ?use_capture ?passive target =\n  make_event Dom_html.Event.error ?use_capture ?passive target\n\nlet load ?use_capture ?passive target =\n  make_event Dom_html.Event.load ?use_capture ?passive target\n\nlet canplay ?use_capture ?passive target =\n  make_event Dom_html.Event.canplay ?use_capture ?passive target\n\nlet canplaythrough ?use_capture ?passive target =\n  make_event Dom_html.Event.canplaythrough ?use_capture ?passive target\n\nlet durationchange ?use_capture ?passive target =\n  make_event Dom_html.Event.durationchange ?use_capture ?passive target\n\nlet emptied ?use_capture ?passive target =\n  make_event Dom_html.Event.emptied ?use_capture ?passive target\n\nlet ended ?use_capture ?passive target =\n  make_event Dom_html.Event.ended ?use_capture ?passive target\n\nlet loadeddata ?use_capture ?passive target =\n  make_event Dom_html.Event.loadeddata ?use_capture ?passive target\n\nlet loadedmetadata ?use_capture ?passive target =\n  make_event Dom_html.Event.loadedmetadata ?use_capture ?passive target\n\nlet loadstart ?use_capture ?passive target =\n  make_event Dom_html.Event.loadstart ?use_capture ?passive target\n\nlet pause ?use_capture ?passive target =\n  make_event Dom_html.Event.pause ?use_capture ?passive target\n\nlet play ?use_capture ?passive target =\n  make_event Dom_html.Event.play ?use_capture ?passive target\n\nlet playing ?use_capture ?passive target =\n  make_event Dom_html.Event.playing ?use_capture ?passive target\n\nlet ratechange ?use_capture ?passive target =\n  make_event Dom_html.Event.ratechange ?use_capture ?passive target\n\nlet seeked ?use_capture ?passive target =\n  make_event Dom_html.Event.seeked ?use_capture ?passive target\n\nlet seeking ?use_capture ?passive target =\n  make_event Dom_html.Event.seeking ?use_capture ?passive target\n\nlet stalled ?use_capture ?passive target =\n  make_event Dom_html.Event.stalled ?use_capture ?passive target\n\nlet suspend ?use_capture ?passive target =\n  make_event Dom_html.Event.suspend ?use_capture ?passive target\n\nlet volumechange ?use_capture ?passive target =\n  make_event Dom_html.Event.volumechange ?use_capture ?passive target\n\nlet waiting ?use_capture ?passive target =\n  make_event Dom_html.Event.waiting ?use_capture ?passive target\n\n(* special case for mousewheel, because it depends on the browser *)\nlet mousewheel ?use_capture ?passive target =\n  let el = ref Js.null in\n  let t, w = Lwt.task () in\n  let cancel () = Js.Opt.iter !el Dom_html.removeEventListener in\n  Lwt.on_cancel t cancel;\n  el :=\n    Js.some\n      (Dom_html.addMousewheelEventListenerWithOptions\n         ?capture:(opt_map Js.bool use_capture)\n         ?passive:(opt_map Js.bool passive)\n         target\n         (fun (ev : #Dom_html.event Js.t) ~dx ~dy ->\n           Firebug.console##log ev;\n           cancel ();\n           Lwt.wakeup w (ev, (dx, dy));\n           Js.bool true)\n         (* true because we do not want to prevent default ->\n                           the user can use the preventDefault function\n                           above. *));\n  t\n\n(* let _DOMMouseScroll ?use_capture ?passive target =\n   make_event Dom_html.Event._DOMMouseScroll ?use_capture ?passive target\n*)\n\nlet wheel ?use_capture ?passive target =\n  make_event Dom_html.Event.wheel ?use_capture ?passive target\n\nlet touchstart ?use_capture ?passive target =\n  make_event Dom_html.Event.touchstart ?use_capture ?passive target\n\nlet touchmove ?use_capture ?passive target =\n  make_event Dom_html.Event.touchmove ?use_capture ?passive target\n\nlet touchend ?use_capture ?passive target =\n  make_event Dom_html.Event.touchend ?use_capture ?passive target\n\nlet touchcancel ?use_capture ?passive target =\n  make_event Dom_html.Event.touchcancel ?use_capture ?passive target\n\nlet lostpointercapture ?use_capture ?passive target =\n  make_event Dom_html.Event.lostpointercapture ?use_capture ?passive target\n\nlet gotpointercapture ?use_capture ?passive target =\n  make_event Dom_html.Event.gotpointercapture ?use_capture ?passive target\n\nlet pointerenter ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerenter ?use_capture ?passive target\n\nlet pointercancel ?use_capture ?passive target =\n  make_event Dom_html.Event.pointercancel ?use_capture ?passive target\n\nlet pointerdown ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerdown ?use_capture ?passive target\n\nlet pointerleave ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerleave ?use_capture ?passive target\n\nlet pointermove ?use_capture ?passive target =\n  make_event Dom_html.Event.pointermove ?use_capture ?passive target\n\nlet pointerout ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerout ?use_capture ?passive target\n\nlet pointerover ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerover ?use_capture ?passive target\n\nlet pointerup ?use_capture ?passive target =\n  make_event Dom_html.Event.pointerup ?use_capture ?passive target\n\nlet transitionend ?use_capture ?passive elt =\n  make_event Dom_html.Event.transitionend ?use_capture ?passive elt\n\nlet transitionstart ?use_capture ?passive elt =\n  make_event Dom_html.Event.transitionstart ?use_capture ?passive elt\n\nlet transitionrun ?use_capture ?passive elt =\n  make_event Dom_html.Event.transitionrun ?use_capture ?passive elt\n\nlet transitioncancel ?use_capture ?passive elt =\n  make_event Dom_html.Event.transitioncancel ?use_capture ?passive elt\n\nlet clicks ?cancel_handler ?use_capture ?passive t =\n  seq_loop click ?cancel_handler ?use_capture ?passive t\n\nlet copies ?cancel_handler ?use_capture ?passive t =\n  seq_loop copy ?cancel_handler ?use_capture ?passive t\n\nlet cuts ?cancel_handler ?use_capture ?passive t =\n  seq_loop cut ?cancel_handler ?use_capture ?passive t\n\nlet pastes ?cancel_handler ?use_capture ?passive t =\n  seq_loop paste ?cancel_handler ?use_capture ?passive t\n\nlet dblclicks ?cancel_handler ?use_capture ?passive t =\n  seq_loop dblclick ?cancel_handler ?use_capture ?passive t\n\nlet mousedowns ?cancel_handler ?use_capture ?passive t =\n  seq_loop mousedown ?cancel_handler ?use_capture ?passive t\n\nlet mouseups ?cancel_handler ?use_capture ?passive t =\n  seq_loop mouseup ?cancel_handler ?use_capture ?passive t\n\nlet mouseovers ?cancel_handler ?use_capture ?passive t =\n  seq_loop mouseover ?cancel_handler ?use_capture ?passive t\n\nlet mousemoves ?cancel_handler ?use_capture ?passive t =\n  seq_loop mousemove ?cancel_handler ?use_capture ?passive t\n\nlet mouseouts ?cancel_handler ?use_capture ?passive t =\n  seq_loop mouseout ?cancel_handler ?use_capture ?passive t\n\nlet keypresses ?cancel_handler ?use_capture ?passive t =\n  seq_loop keypress ?cancel_handler ?use_capture ?passive t\n\nlet keydowns ?cancel_handler ?use_capture ?passive t =\n  seq_loop keydown ?cancel_handler ?use_capture ?passive t\n\nlet keyups ?cancel_handler ?use_capture ?passive t =\n  seq_loop keyup ?cancel_handler ?use_capture ?passive t\n\nlet changes ?cancel_handler ?use_capture ?passive t =\n  seq_loop change ?cancel_handler ?use_capture ?passive t\n\nlet inputs ?cancel_handler ?use_capture ?passive t =\n  seq_loop input ?cancel_handler ?use_capture ?passive t\n\nlet timeupdates ?cancel_handler ?use_capture ?passive t =\n  seq_loop timeupdate ?cancel_handler ?use_capture ?passive t\n\nlet dragstarts ?cancel_handler ?use_capture ?passive t =\n  seq_loop dragstart ?cancel_handler ?use_capture ?passive t\n\nlet dragends ?cancel_handler ?use_capture ?passive t =\n  seq_loop dragend ?cancel_handler ?use_capture ?passive t\n\nlet dragenters ?cancel_handler ?use_capture ?passive t =\n  seq_loop dragenter ?cancel_handler ?use_capture ?passive t\n\nlet dragovers ?cancel_handler ?use_capture ?passive t =\n  seq_loop dragover ?cancel_handler ?use_capture ?passive t\n\nlet dragleaves ?cancel_handler ?use_capture ?passive t =\n  seq_loop dragleave ?cancel_handler ?use_capture ?passive t\n\nlet drags ?cancel_handler ?use_capture ?passive t =\n  seq_loop drag ?cancel_handler ?use_capture ?passive t\n\nlet drops ?cancel_handler ?use_capture ?passive t =\n  seq_loop drop ?cancel_handler ?use_capture ?passive t\n\nlet mousewheels ?cancel_handler ?use_capture ?passive t =\n  seq_loop mousewheel ?cancel_handler ?use_capture ?passive t\n\nlet wheels ?cancel_handler ?use_capture ?passive t =\n  seq_loop wheel ?cancel_handler ?use_capture ?passive t\n\nlet touchstarts ?cancel_handler ?use_capture ?passive t =\n  seq_loop touchstart ?cancel_handler ?use_capture ?passive t\n\nlet touchmoves ?cancel_handler ?use_capture ?passive t =\n  seq_loop touchmove ?cancel_handler ?use_capture ?passive t\n\nlet touchends ?cancel_handler ?use_capture ?passive t =\n  seq_loop touchend ?cancel_handler ?use_capture ?passive t\n\nlet touchcancels ?cancel_handler ?use_capture ?passive t =\n  seq_loop touchcancel ?cancel_handler ?use_capture ?passive t\n\nlet focuses ?cancel_handler ?use_capture ?passive t =\n  seq_loop focus ?cancel_handler ?use_capture ?passive t\n\nlet blurs ?cancel_handler ?use_capture ?passive t =\n  seq_loop blur ?cancel_handler ?use_capture ?passive t\n\nlet scrolls ?cancel_handler ?use_capture ?passive t =\n  seq_loop scroll ?cancel_handler ?use_capture ?passive t\n\nlet submits ?cancel_handler ?use_capture ?passive t =\n  seq_loop submit ?cancel_handler ?use_capture ?passive t\n\nlet selects ?cancel_handler ?use_capture ?passive t =\n  seq_loop select ?cancel_handler ?use_capture ?passive t\n\nlet aborts ?cancel_handler ?use_capture ?passive t =\n  seq_loop abort ?cancel_handler ?use_capture ?passive t\n\nlet errors ?cancel_handler ?use_capture ?passive t =\n  seq_loop error ?cancel_handler ?use_capture ?passive t\n\nlet loads ?cancel_handler ?use_capture ?passive t =\n  seq_loop load ?cancel_handler ?use_capture ?passive t\n\nlet canplays ?cancel_handler ?use_capture ?passive t =\n  seq_loop canplay ?cancel_handler ?use_capture ?passive t\n\nlet canplaythroughs ?cancel_handler ?use_capture ?passive t =\n  seq_loop canplaythrough ?cancel_handler ?use_capture ?passive t\n\nlet durationchanges ?cancel_handler ?use_capture ?passive t =\n  seq_loop durationchange ?cancel_handler ?use_capture ?passive t\n\nlet emptieds ?cancel_handler ?use_capture ?passive t =\n  seq_loop emptied ?cancel_handler ?use_capture ?passive t\n\nlet endeds ?cancel_handler ?use_capture ?passive t =\n  seq_loop ended ?cancel_handler ?use_capture ?passive t\n\nlet loadeddatas ?cancel_handler ?use_capture ?passive t =\n  seq_loop loadeddata ?cancel_handler ?use_capture ?passive t\n\nlet loadedmetadatas ?cancel_handler ?use_capture ?passive t =\n  seq_loop loadedmetadata ?cancel_handler ?use_capture ?passive t\n\nlet loadstarts ?cancel_handler ?use_capture ?passive t =\n  seq_loop loadstart ?cancel_handler ?use_capture ?passive t\n\nlet pauses ?cancel_handler ?use_capture ?passive t =\n  seq_loop pause ?cancel_handler ?use_capture ?passive t\n\nlet plays ?cancel_handler ?use_capture ?passive t =\n  seq_loop play ?cancel_handler ?use_capture ?passive t\n\nlet playings ?cancel_handler ?use_capture ?passive t =\n  seq_loop playing ?cancel_handler ?use_capture ?passive t\n\nlet ratechanges ?cancel_handler ?use_capture ?passive t =\n  seq_loop ratechange ?cancel_handler ?use_capture ?passive t\n\nlet seekeds ?cancel_handler ?use_capture ?passive t =\n  seq_loop seeked ?cancel_handler ?use_capture ?passive t\n\nlet seekings ?cancel_handler ?use_capture ?passive t =\n  seq_loop seeking ?cancel_handler ?use_capture ?passive t\n\nlet stalleds ?cancel_handler ?use_capture ?passive t =\n  seq_loop stalled ?cancel_handler ?use_capture ?passive t\n\nlet suspends ?cancel_handler ?use_capture ?passive t =\n  seq_loop suspend ?cancel_handler ?use_capture ?passive t\n\nlet volumechanges ?cancel_handler ?use_capture ?passive t =\n  seq_loop volumechange ?cancel_handler ?use_capture ?passive t\n\nlet waitings ?cancel_handler ?use_capture ?passive t =\n  seq_loop waiting ?cancel_handler ?use_capture ?passive t\n\nlet lostpointercaptures ?cancel_handler ?use_capture ?passive t =\n  seq_loop lostpointercapture ?cancel_handler ?use_capture ?passive t\n\nlet gotpointercaptures ?cancel_handler ?use_capture ?passive t =\n  seq_loop gotpointercapture ?cancel_handler ?use_capture ?passive t\n\nlet pointerenters ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerenter ?cancel_handler ?use_capture ?passive t\n\nlet pointercancels ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointercancel ?cancel_handler ?use_capture ?passive t\n\nlet pointerdowns ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerdown ?cancel_handler ?use_capture ?passive t\n\nlet pointerleaves ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerleave ?cancel_handler ?use_capture ?passive t\n\nlet pointermoves ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointermove ?cancel_handler ?use_capture ?passive t\n\nlet pointerouts ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerout ?cancel_handler ?use_capture ?passive t\n\nlet pointerovers ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerover ?cancel_handler ?use_capture ?passive t\n\nlet pointerups ?cancel_handler ?use_capture ?passive t =\n  seq_loop pointerup ?cancel_handler ?use_capture ?passive t\n\nlet transitionends ?cancel_handler ?use_capture ?passive t =\n  seq_loop transitionend ?cancel_handler ?use_capture ?passive t\n\nlet transitionstarts ?cancel_handler ?use_capture ?passive t =\n  seq_loop transitionstart ?cancel_handler ?use_capture ?passive t\n\nlet transitionruns ?cancel_handler ?use_capture ?passive t =\n  seq_loop transitionrun ?cancel_handler ?use_capture ?passive t\n\nlet transitioncancels ?cancel_handler ?use_capture ?passive t =\n  seq_loop transitioncancel ?cancel_handler ?use_capture ?passive t\n\nlet request_animation_frame () =\n  let t, s = Lwt.wait () in\n  let (_ : Dom_html.animation_frame_request_id) =\n    Dom_html.window##requestAnimationFrame\n      (Js.wrap_callback (fun (_ : Js.number_t) -> Lwt.wakeup s ()))\n  in\n  t\n\nlet onload () = make_event Dom_html.Event.load Dom_html.window\n\nlet domContentLoaded =\n  let complete = Js.string \"complete\" in\n  let doc = Dom_html.window##.document in\n  fun () ->\n    if doc##.readyState == complete\n    then Lwt.return_unit\n    else\n      let t, w = Lwt.task () in\n      let wakeup w _ = if Lwt.is_sleeping t then Lwt.wakeup w () in\n      let wakeup_exn w e = if Lwt.is_sleeping t then Lwt.wakeup_exn w e in\n      (* https://github.com/dperini/ContentLoaded/blob/master/src/contentloaded.js *)\n      let regular = make_event Dom_html.Event.domContentLoaded doc in\n      Lwt.on_any regular (wakeup w) (wakeup_exn w);\n      (* ie8 *)\n      let readystatechange =\n        async_loop\n          (make_event (Dom.Event.make \"readystatechange\"))\n          doc\n          (fun e _ ->\n            if doc##.readyState == complete then wakeup w e;\n            Lwt.return_unit)\n      in\n      (* fallback, just in case *)\n      let init = make_event Dom_html.Event.load Dom_html.window in\n      Lwt.on_any init (wakeup w) (wakeup_exn w);\n      (* clean and return *)\n      Lwt.bind t (fun _e ->\n          Lwt.cancel regular;\n          Lwt.cancel readystatechange;\n          Lwt.cancel init;\n          Lwt.return_unit)\n\nlet onunload () = make_event Dom_html.Event.unload Dom_html.window\n\nlet onbeforeunload () = make_event Dom_html.Event.beforeunload Dom_html.window\n\nlet onresize () = make_event Dom_html.Event.resize Dom_html.window\n\nlet onorientationchange () = make_event Dom_html.Event.orientationchange Dom_html.window\n\nlet onpopstate () = make_event Dom_html.Event.popstate Dom_html.window\n\nlet onhashchange () = make_event Dom_html.Event.hashchange Dom_html.window\n\nlet onorientationchange_or_onresize () = Lwt.pick [ onresize (); onorientationchange () ]\n\nlet onresizes t = seq_loop (fun ?use_capture:_ ?passive:_ () -> onresize ()) () t\n\nlet onorientationchanges t =\n  seq_loop (fun ?use_capture:_ ?passive:_ () -> onorientationchange ()) () t\n\nlet onpopstates t = seq_loop (fun ?use_capture:_ ?passive:_ () -> onpopstate ()) () t\n\nlet onhashchanges t = seq_loop (fun ?use_capture:_ ?passive:_ () -> onhashchange ()) () t\n\nlet onorientationchanges_or_onresizes t =\n  seq_loop (fun ?use_capture:_ ?passive:_ () -> onorientationchange_or_onresize ()) () t\n\nlet limited_onresizes ?elapsed_time t =\n  limited_loop (fun ?use_capture:_ ?passive:_ () -> onresize ()) ?elapsed_time () t\n\nlet limited_onorientationchanges ?elapsed_time t =\n  limited_loop\n    (fun ?use_capture:_ ?passive:_ () -> onorientationchange ())\n    ?elapsed_time\n    ()\n    t\n\nlet limited_onorientationchanges_or_onresizes ?elapsed_time t =\n  limited_loop\n    (fun ?use_capture:_ ?passive:_ () -> onorientationchange_or_onresize ())\n    ?elapsed_time\n    ()\n    t\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                         The OCaml programmers                          *)\n(*                                                                        *)\n(*   Copyright 2018 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype 'a t = 'a option = None | Some of 'a\n\nlet none = None\nlet some v = Some v\nlet value o ~default = match o with Some v -> v | None -> default\nlet get = function Some v -> v | None -> invalid_arg \"option is None\"\nlet bind o f = match o with None -> None | Some v -> f v\nlet join = function Some o -> o | None -> None\nlet map f o = match o with None -> None | Some v -> Some (f v)\nlet fold ~none ~some = function Some v -> some v | None -> none\nlet iter f = function Some v -> f v | None -> ()\nlet is_none = function None -> true | Some _ -> false\nlet is_some = function None -> false | Some _ -> true\n\nlet equal eq o0 o1 = match o0, o1 with\n| Some v0, Some v1 -> eq v0 v1\n| None, None -> true\n| _ -> false\n\nlet compare cmp o0 o1 = match o0, o1 with\n| Some v0, Some v1 -> cmp v0 v1\n| None, None -> 0\n| None, Some _ -> -1\n| Some _, None -> 1\n\nlet to_result ~none = function None -> Error none | Some v -> Ok v\nlet to_list = function None -> [] | Some v -> [v]\nlet to_seq = function None -> Seq.empty | Some v -> Seq.return v\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Ensure that [at_exit] functions are called at the end of every program *)\n\nlet _ = do_at_exit()\n"]}
